"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_pnpm_tw-elements_1_0_0-beta3_postcss_8_4_27_node_modules_tw-elements_dis-5bd434"],{

/***/ "./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Me)
/* harmony export */ });
/* harmony import */ var _chart_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart.es.js */ "./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/chart.es.js");

/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
var D = function() {
  if (typeof window < "u") {
    if (window.devicePixelRatio)
      return window.devicePixelRatio;
    var e = window.screen;
    if (e)
      return (e.deviceXDPI || 1) / (e.logicalXDPI || 1);
  }
  return 1;
}(), m = {
  // @todo move this in Chart.helpers.toTextLines
  toTextLines: function(e) {
    var t = [], r;
    for (e = [].concat(e); e.length; )
      r = e.pop(), typeof r == "string" ? t.unshift.apply(t, r.split(`
`)) : Array.isArray(r) ? e.push.apply(e, r) : (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e) || t.unshift("" + r);
    return t;
  },
  // @todo move this in Chart.helpers.canvas.textSize
  // @todo cache calls of measureText if font doesn't change?!
  textSize: function(e, t, r) {
    var a = [].concat(t), i = a.length, n = e.font, o = 0, s;
    for (e.font = r.string, s = 0; s < i; ++s)
      o = Math.max(e.measureText(a[s]).width, o);
    return e.font = n, {
      height: i * r.lineHeight,
      width: o
    };
  },
  /**
   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
   * @todo move this method in Chart.helpers.bound
   * https://doc.qt.io/qt-5/qtglobal.html#qBound
   */
  bound: function(e, t, r) {
    return Math.max(e, Math.min(t, r));
  },
  /**
   * Returns an array of pair [value, state] where state is:
   * * -1: value is only in a0 (removed)
   * *  1: value is only in a1 (added)
   */
  arrayDiff: function(e, t) {
    var r = e.slice(), a = [], i, n, o, s;
    for (i = 0, o = t.length; i < o; ++i)
      s = t[i], n = r.indexOf(s), n === -1 ? a.push([s, 1]) : r.splice(n, 1);
    for (i = 0, o = r.length; i < o; ++i)
      a.push([r[i], -1]);
    return a;
  },
  /**
   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
   */
  rasterize: function(e) {
    return Math.round(e * D) / D;
  }
};
function A(e, t) {
  var r = t.x, a = t.y;
  if (r === null)
    return { x: 0, y: -1 };
  if (a === null)
    return { x: 1, y: 0 };
  var i = e.x - r, n = e.y - a, o = Math.sqrt(i * i + n * n);
  return {
    x: o ? i / o : 0,
    y: o ? n / o : -1
  };
}
function ae(e, t, r, a, i) {
  switch (i) {
    case "center":
      r = a = 0;
      break;
    case "bottom":
      r = 0, a = 1;
      break;
    case "right":
      r = 1, a = 0;
      break;
    case "left":
      r = -1, a = 0;
      break;
    case "top":
      r = 0, a = -1;
      break;
    case "start":
      r = -r, a = -a;
      break;
    case "end":
      break;
    default:
      i *= Math.PI / 180, r = Math.cos(i), a = Math.sin(i);
      break;
  }
  return {
    x: e,
    y: t,
    vx: r,
    vy: a
  };
}
var te = 0, j = 1, N = 2, O = 4, F = 8;
function M(e, t, r) {
  var a = te;
  return e < r.left ? a |= j : e > r.right && (a |= N), t < r.top ? a |= F : t > r.bottom && (a |= O), a;
}
function ie(e, t) {
  for (var r = e.x0, a = e.y0, i = e.x1, n = e.y1, o = M(r, a, t), s = M(i, n, t), l, u, v; !(!(o | s) || o & s); )
    l = o || s, l & F ? (u = r + (i - r) * (t.top - a) / (n - a), v = t.top) : l & O ? (u = r + (i - r) * (t.bottom - a) / (n - a), v = t.bottom) : l & N ? (v = a + (n - a) * (t.right - r) / (i - r), u = t.right) : l & j && (v = a + (n - a) * (t.left - r) / (i - r), u = t.left), l === o ? (r = u, a = v, o = M(r, a, t)) : (i = u, n = v, s = M(i, n, t));
  return {
    x0: r,
    x1: i,
    y0: a,
    y1: n
  };
}
function P(e, t) {
  var r = t.anchor, a = e, i, n;
  return t.clamp && (a = ie(a, t.area)), r === "start" ? (i = a.x0, n = a.y0) : r === "end" ? (i = a.x1, n = a.y1) : (i = (a.x0 + a.x1) / 2, n = (a.y0 + a.y1) / 2), ae(i, n, e.vx, e.vy, t.align);
}
var E = {
  arc: function(e, t) {
    var r = (e.startAngle + e.endAngle) / 2, a = Math.cos(r), i = Math.sin(r), n = e.innerRadius, o = e.outerRadius;
    return P({
      x0: e.x + a * n,
      y0: e.y + i * n,
      x1: e.x + a * o,
      y1: e.y + i * o,
      vx: a,
      vy: i
    }, t);
  },
  point: function(e, t) {
    var r = A(e, t.origin), a = r.x * e.options.radius, i = r.y * e.options.radius;
    return P({
      x0: e.x - a,
      y0: e.y - i,
      x1: e.x + a,
      y1: e.y + i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  bar: function(e, t) {
    var r = A(e, t.origin), a = e.x, i = e.y, n = 0, o = 0;
    return e.horizontal ? (a = Math.min(e.x, e.base), n = Math.abs(e.base - e.x)) : (i = Math.min(e.y, e.base), o = Math.abs(e.base - e.y)), P({
      x0: a,
      y0: i + o,
      x1: a + n,
      y1: i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  fallback: function(e, t) {
    var r = A(e, t.origin);
    return P({
      x0: e.x,
      y0: e.y,
      x1: e.x + (e.width || 0),
      y1: e.y + (e.height || 0),
      vx: r.x,
      vy: r.y
    }, t);
  }
}, x = m.rasterize;
function ne(e) {
  var t = e.borderWidth || 0, r = e.padding, a = e.size.height, i = e.size.width, n = -i / 2, o = -a / 2;
  return {
    frame: {
      x: n - r.left - t,
      y: o - r.top - t,
      w: i + r.width + t * 2,
      h: a + r.height + t * 2
    },
    text: {
      x: n,
      y: o,
      w: i,
      h: a
    }
  };
}
function oe(e, t) {
  var r = t.chart.getDatasetMeta(t.datasetIndex).vScale;
  if (!r)
    return null;
  if (r.xCenter !== void 0 && r.yCenter !== void 0)
    return { x: r.xCenter, y: r.yCenter };
  var a = r.getBasePixel();
  return e.horizontal ? { x: a, y: null } : { x: null, y: a };
}
function se(e) {
  return e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.A ? E.arc : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.P ? E.point : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.B ? E.bar : E.fallback;
}
function le(e, t, r, a, i, n) {
  var o = Math.PI / 2;
  if (n) {
    var s = Math.min(n, i / 2, a / 2), l = t + s, u = r + s, v = t + a - s, d = r + i - s;
    e.moveTo(t, u), l < v && u < d ? (e.arc(l, u, s, -Math.PI, -o), e.arc(v, u, s, -o, 0), e.arc(v, d, s, 0, o), e.arc(l, d, s, o, Math.PI)) : l < v ? (e.moveTo(l, r), e.arc(v, u, s, -o, o), e.arc(l, u, s, o, Math.PI + o)) : u < d ? (e.arc(l, u, s, -Math.PI, 0), e.arc(l, d, s, 0, Math.PI)) : e.arc(l, u, s, -Math.PI, Math.PI), e.closePath(), e.moveTo(t, r);
  } else
    e.rect(t, r, a, i);
}
function ue(e, t, r) {
  var a = r.backgroundColor, i = r.borderColor, n = r.borderWidth;
  !a && (!i || !n) || (e.beginPath(), le(
    e,
    x(t.x) + n / 2,
    x(t.y) + n / 2,
    x(t.w) - n,
    x(t.h) - n,
    r.borderRadius
  ), e.closePath(), a && (e.fillStyle = a, e.fill()), i && n && (e.strokeStyle = i, e.lineWidth = n, e.lineJoin = "miter", e.stroke()));
}
function ve(e, t, r) {
  var a = r.lineHeight, i = e.w, n = e.x, o = e.y + a / 2;
  return t === "center" ? n += i / 2 : (t === "end" || t === "right") && (n += i), {
    h: a,
    w: i,
    x: n,
    y: o
  };
}
function de(e, t, r) {
  var a = e.shadowBlur, i = r.stroked, n = x(r.x), o = x(r.y), s = x(r.w);
  i && e.strokeText(t, n, o, s), r.filled && (a && i && (e.shadowBlur = 0), e.fillText(t, n, o, s), a && i && (e.shadowBlur = a));
}
function fe(e, t, r, a) {
  var i = a.textAlign, n = a.color, o = !!n, s = a.font, l = t.length, u = a.textStrokeColor, v = a.textStrokeWidth, d = u && v, y;
  if (!(!l || !o && !d))
    for (r = ve(r, i, s), e.font = s.string, e.textAlign = i, e.textBaseline = "middle", e.shadowBlur = a.textShadowBlur, e.shadowColor = a.textShadowColor, o && (e.fillStyle = n), d && (e.lineJoin = "round", e.lineWidth = v, e.strokeStyle = u), y = 0, l = t.length; y < l; ++y)
      de(e, t[y], {
        stroked: d,
        filled: o,
        w: r.w,
        x: r.x,
        y: r.y + r.h * y
      });
}
var L = function(e, t, r, a) {
  var i = this;
  i._config = e, i._index = a, i._model = null, i._rects = null, i._ctx = t, i._el = r;
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(L.prototype, {
  /**
   * @private
   */
  _modelize: function(e, t, r, a) {
    var i = this, n = i._index, o = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.t)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.font, {}], a, n)), s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.color, _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.d.color], a, n);
    return {
      align: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.align, "center"], a, n),
      anchor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.anchor, "center"], a, n),
      area: a.chart.chartArea,
      backgroundColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.backgroundColor, null], a, n),
      borderColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderColor, null], a, n),
      borderRadius: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderRadius, 0], a, n),
      borderWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderWidth, 0], a, n),
      clamp: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clamp, !1], a, n),
      clip: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clip, !1], a, n),
      color: s,
      display: e,
      font: o,
      lines: t,
      offset: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.offset, 4], a, n),
      opacity: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.opacity, 1], a, n),
      origin: oe(i._el, a),
      padding: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.padding, 4], a, n)),
      positioner: se(i._el),
      rotation: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.rotation, 0], a, n) * (Math.PI / 180),
      size: m.textSize(i._ctx, t, o),
      textAlign: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textAlign, "start"], a, n),
      textShadowBlur: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowBlur, 0], a, n),
      textShadowColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowColor, s], a, n),
      textStrokeColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeColor, s], a, n),
      textStrokeWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeWidth, 0], a, n)
    };
  },
  update: function(e) {
    var t = this, r = null, a = null, i = t._index, n = t._config, o, s, l, u = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([n.display, !0], e, i);
    u && (o = e.dataset.data[i], s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.v)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(n.formatter, [o, e]), o), l = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(s) ? [] : m.toTextLines(s), l.length && (r = t._modelize(u, l, n, e), a = ne(r))), t._model = r, t._rects = a;
  },
  geometry: function() {
    return this._rects ? this._rects.frame : {};
  },
  rotation: function() {
    return this._model ? this._model.rotation : 0;
  },
  visible: function() {
    return this._model && this._model.opacity;
  },
  model: function() {
    return this._model;
  },
  draw: function(e, t) {
    var r = this, a = e.ctx, i = r._model, n = r._rects, o;
    this.visible() && (a.save(), i.clip && (o = i.area, a.beginPath(), a.rect(
      o.left,
      o.top,
      o.right - o.left,
      o.bottom - o.top
    ), a.clip()), a.globalAlpha = m.bound(0, i.opacity, 1), a.translate(x(t.x), x(t.y)), a.rotate(i.rotation), ue(a, n.frame, i), fe(a, i.lines, n.text, i), a.restore());
  }
});
var he = Number.MIN_SAFE_INTEGER || -9007199254740991, ye = Number.MAX_SAFE_INTEGER || 9007199254740991;
function b(e, t, r) {
  var a = Math.cos(r), i = Math.sin(r), n = t.x, o = t.y;
  return {
    x: n + a * (e.x - n) - i * (e.y - o),
    y: o + i * (e.x - n) + a * (e.y - o)
  };
}
function W(e, t) {
  var r = ye, a = he, i = t.origin, n, o, s, l, u;
  for (n = 0; n < e.length; ++n)
    o = e[n], s = o.x - i.x, l = o.y - i.y, u = t.vx * s + t.vy * l, r = Math.min(r, u), a = Math.max(a, u);
  return {
    min: r,
    max: a
  };
}
function I(e, t) {
  var r = t.x - e.x, a = t.y - e.y, i = Math.sqrt(r * r + a * a);
  return {
    vx: (t.x - e.x) / i,
    vy: (t.y - e.y) / i,
    origin: e,
    ln: i
  };
}
var G = function() {
  this._rotation = 0, this._rect = {
    x: 0,
    y: 0,
    w: 0,
    h: 0
  };
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(G.prototype, {
  center: function() {
    var e = this._rect;
    return {
      x: e.x + e.w / 2,
      y: e.y + e.h / 2
    };
  },
  update: function(e, t, r) {
    this._rotation = r, this._rect = {
      x: t.x + e.x,
      y: t.y + e.y,
      w: t.w,
      h: t.h
    };
  },
  contains: function(e) {
    var t = this, r = 1, a = t._rect;
    return e = b(e, t.center(), -t._rotation), !(e.x < a.x - r || e.y < a.y - r || e.x > a.x + a.w + r * 2 || e.y > a.y + a.h + r * 2);
  },
  // Separating Axis Theorem
  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
  intersects: function(e) {
    var t = this._points(), r = e._points(), a = [
      I(t[0], t[1]),
      I(t[0], t[3])
    ], i, n, o;
    for (this._rotation !== e._rotation && a.push(
      I(r[0], r[1]),
      I(r[0], r[3])
    ), i = 0; i < a.length; ++i)
      if (n = W(t, a[i]), o = W(r, a[i]), n.max < o.min || o.max < n.min)
        return !1;
    return !0;
  },
  /**
   * @private
   */
  _points: function() {
    var e = this, t = e._rect, r = e._rotation, a = e.center();
    return [
      b({ x: t.x, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y + t.h }, a, r),
      b({ x: t.x, y: t.y + t.h }, a, r)
    ];
  }
});
function H(e, t, r) {
  var a = t.positioner(e, t), i = a.vx, n = a.vy;
  if (!i && !n)
    return { x: a.x, y: a.y };
  var o = r.w, s = r.h, l = t.rotation, u = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)), v = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(i), Math.abs(n));
  return u *= i * d, v *= n * d, u += t.offset * i, v += t.offset * n, {
    x: a.x + u,
    y: a.y + v
  };
}
function xe(e, t) {
  var r, a, i, n;
  for (r = e.length - 1; r >= 0; --r)
    for (i = e[r].$layout, a = r - 1; a >= 0 && i._visible; --a)
      n = e[a].$layout, n._visible && i._box.intersects(n._box) && t(i, n);
  return e;
}
function _e(e) {
  var t, r, a, i, n, o, s;
  for (t = 0, r = e.length; t < r; ++t)
    a = e[t], i = a.$layout, i._visible && (s = new Proxy(a._el, { get: (l, u) => l.getProps([u], !0)[u] }), n = a.geometry(), o = H(s, a.model(), n), i._box.update(o, n, a.rotation()));
  return xe(e, function(l, u) {
    var v = l._hidable, d = u._hidable;
    v && d || d ? u._visible = !1 : v && (l._visible = !1);
  });
}
var w = {
  prepare: function(e) {
    var t = [], r, a, i, n, o;
    for (r = 0, i = e.length; r < i; ++r)
      for (a = 0, n = e[r].length; a < n; ++a)
        o = e[r][a], t.push(o), o.$layout = {
          _box: new G(),
          _hidable: !1,
          _visible: !0,
          _set: r,
          _idx: o._index
        };
    return t.sort(function(s, l) {
      var u = s.$layout, v = l.$layout;
      return u._idx === v._idx ? v._set - u._set : v._idx - u._idx;
    }), this.update(t), t;
  },
  update: function(e) {
    var t = !1, r, a, i, n, o;
    for (r = 0, a = e.length; r < a; ++r)
      i = e[r], n = i.model(), o = i.$layout, o._hidable = n && n.display === "auto", o._visible = i.visible(), t |= o._hidable;
    t && _e(e);
  },
  lookup: function(e, t) {
    var r, a;
    for (r = e.length - 1; r >= 0; --r)
      if (a = e[r].$layout, a && a._visible && a._box.contains(t))
        return e[r];
    return null;
  },
  draw: function(e, t) {
    var r, a, i, n, o, s;
    for (r = 0, a = t.length; r < a; ++r)
      i = t[r], n = i.$layout, n._visible && (o = i.geometry(), s = H(i._el, i.model(), o), n._box.update(s, o, i.rotation()), i.draw(e, s));
  }
}, ce = function(e) {
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e))
    return null;
  var t = e, r, a, i;
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.b)(e))
    if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.label))
      t = e.label;
    else if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.r))
      t = e.r;
    else
      for (t = "", r = Object.keys(e), i = 0, a = r.length; i < a; ++i)
        t += (i !== 0 ? ", " : "") + r[i] + ": " + e[r[i]];
  return "" + t;
}, be = {
  align: "center",
  anchor: "center",
  backgroundColor: null,
  borderColor: null,
  borderRadius: 0,
  borderWidth: 0,
  clamp: !1,
  clip: !1,
  color: void 0,
  display: !0,
  font: {
    family: void 0,
    lineHeight: 1.2,
    size: void 0,
    style: void 0,
    weight: null
  },
  formatter: ce,
  labels: void 0,
  listeners: {},
  offset: 4,
  opacity: 1,
  padding: {
    top: 4,
    right: 4,
    bottom: 4,
    left: 4
  },
  rotation: 0,
  textAlign: "start",
  textStrokeColor: void 0,
  textStrokeWidth: 0,
  textShadowBlur: 0,
  textShadowColor: void 0
}, h = "$datalabels", U = "$default";
function pe(e, t) {
  var r = e.datalabels, a = {}, i = [], n, o;
  return r === !1 ? null : (r === !0 && (r = {}), t = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [t, r]), n = t.labels || {}, o = Object.keys(n), delete t.labels, o.length ? o.forEach(function(s) {
    n[s] && i.push((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [
      t,
      n[s],
      { _key: s }
    ]));
  }) : i.push(t), a = i.reduce(function(s, l) {
    return (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.e)(l.listeners || {}, function(u, v) {
      s[v] = s[v] || {}, s[v][l._key || U] = u;
    }), delete l.listeners, s;
  }, {}), {
    labels: i,
    listeners: a
  });
}
function R(e, t, r, a) {
  if (t) {
    var i = r.$context, n = r.$groups, o;
    t[n._set] && (o = t[n._set][n._key], o && (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(o, [i, a]) === !0 && (e[h]._dirty = !0, r.update(i)));
  }
}
function me(e, t, r, a, i) {
  var n, o;
  !r && !a || (r ? a ? r !== a && (o = n = !0) : o = !0 : n = !0, o && R(e, t.leave, r, i), n && R(e, t.enter, a, i));
}
function we(e, t) {
  var r = e[h], a = r._listeners, i, n;
  if (!(!a.enter && !a.leave)) {
    if (t.type === "mousemove")
      n = w.lookup(r._labels, t);
    else if (t.type !== "mouseout")
      return;
    i = r._hovered, r._hovered = n, me(e, a, i, n, t);
  }
}
function ge(e, t) {
  var r = e[h], a = r._listeners.click, i = a && w.lookup(r._labels, t);
  i && R(e, a, i, t);
}
var Me = {
  id: "datalabels",
  defaults: be,
  beforeInit: function(e) {
    e[h] = {
      _actives: []
    };
  },
  beforeUpdate: function(e) {
    var t = e[h];
    t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];
  },
  afterDatasetUpdate: function(e, t, r) {
    var a = t.index, i = e[h], n = i._datasets[a] = [], o = e.isDatasetVisible(a), s = e.data.datasets[a], l = pe(s, r), u = t.meta.data || [], v = e.ctx, d, y, $, T, S, B, c, _;
    for (v.save(), d = 0, $ = u.length; d < $; ++d)
      if (c = u[d], c[h] = [], o && c && e.getDataVisibility(d) && !c.skip)
        for (y = 0, T = l.labels.length; y < T; ++y)
          S = l.labels[y], B = S._key, _ = new L(S, v, c, d), _.$groups = {
            _set: a,
            _key: B || U
          }, _.$context = {
            active: !1,
            chart: e,
            dataIndex: d,
            dataset: s,
            datasetIndex: a
          }, _.update(_.$context), c[h].push(_), n.push(_);
    v.restore(), (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(i._listeners, l.listeners, {
      merger: function(k, C, X) {
        C[k] = C[k] || {}, C[k][t.index] = X[k], i._listened = !0;
      }
    });
  },
  afterUpdate: function(e) {
    e[h]._labels = w.prepare(e[h]._datasets);
  },
  // Draw labels on top of all dataset elements
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
  afterDatasetsDraw: function(e) {
    w.draw(e, e[h]._labels);
  },
  beforeEvent: function(e, t) {
    if (e[h]._listened) {
      var r = t.event;
      switch (r.type) {
        case "mousemove":
        case "mouseout":
          we(e, r);
          break;
        case "click":
          ge(e, r);
          break;
      }
    }
  },
  afterEvent: function(e) {
    var t = e[h], r = t._actives, a = t._actives = e.getActiveElements(), i = m.arrayDiff(r, a), n, o, s, l, u, v, d;
    for (n = 0, o = i.length; n < o; ++n)
      if (u = i[n], u[1])
        for (d = u[0].element[h] || [], s = 0, l = d.length; s < l; ++s)
          v = d[s], v.$context.active = u[1] === 1, v.update(v.$context);
    (t._dirty || i.length) && (w.update(t._labels), e.render()), delete t._dirty;
  }
};

//# sourceMappingURL=chartjs-plugin-datalabels.es.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcG5wbV90dy1lbGVtZW50c18xXzBfMC1iZXRhM19wb3N0Y3NzXzhfNF8yN19ub2RlX21vZHVsZXNfdHctZWxlbWVudHNfZGlzLTViZDQzNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5STtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQSw4Q0FBOEMsK0NBQUM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixnQkFBZ0IsSUFBSTtBQUM5QztBQUNBO0FBQ0Esc0JBQXNCLDJDQUFDLHdCQUF3QiwyQ0FBQywwQkFBMEIsMkNBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyUUFBMlEsT0FBTztBQUNsUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQUMsQ0FBQywrQ0FBQyxZQUFZLGVBQWUsK0NBQUMsV0FBVywyQ0FBQztBQUMvRTtBQUNBLGFBQWEsK0NBQUM7QUFDZCxjQUFjLCtDQUFDO0FBQ2Y7QUFDQSx1QkFBdUIsK0NBQUM7QUFDeEIsbUJBQW1CLCtDQUFDO0FBQ3BCLG9CQUFvQiwrQ0FBQztBQUNyQixtQkFBbUIsK0NBQUM7QUFDcEIsYUFBYSwrQ0FBQztBQUNkLFlBQVksK0NBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQUM7QUFDZixlQUFlLCtDQUFDO0FBQ2hCO0FBQ0EsZUFBZSwrQ0FBQyxDQUFDLCtDQUFDO0FBQ2xCO0FBQ0EsZ0JBQWdCLCtDQUFDO0FBQ2pCO0FBQ0EsaUJBQWlCLCtDQUFDO0FBQ2xCLHNCQUFzQiwrQ0FBQztBQUN2Qix1QkFBdUIsK0NBQUM7QUFDeEIsdUJBQXVCLCtDQUFDO0FBQ3hCLHVCQUF1QiwrQ0FBQztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBLGdGQUFnRiwrQ0FBQztBQUNqRixxQ0FBcUMsK0NBQUMsQ0FBQywrQ0FBQywrQkFBK0IsK0NBQUM7QUFDeEUsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsc0JBQXNCO0FBQ2hDLFVBQVUsNEJBQTRCO0FBQ3RDLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQyxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQyxtRUFBbUUsdUNBQXVDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0EsQ0FBQztBQUNELE1BQU0sK0NBQUM7QUFDUDtBQUNBO0FBQ0EsTUFBTSwrQ0FBRTtBQUNSLFNBQVMsK0NBQUM7QUFDVjtBQUNBLGNBQWMsK0NBQUM7QUFDZjtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhCQUE4QjtBQUM5QiwrQ0FBK0MsT0FBTywrQ0FBQyxHQUFHLDZCQUE2QjtBQUN2RixtQkFBbUIsK0NBQUMsR0FBRztBQUN2QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNILFdBQVcsK0NBQUMsa0JBQWtCO0FBQzlCLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQ0FBQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCLCtDQUFDO0FBQ2xCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0EsNkRBQTZELE9BQU87QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3R3LWVsZW1lbnRzQDEuMC4wLWJldGEzX3Bvc3Rjc3NAOC40LjI3L25vZGVfbW9kdWxlcy90dy1lbGVtZW50cy9kaXN0L2pzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbSBhcyBnLCBpIGFzIHAsIHQgYXMgcSwgciBhcyBmLCBkIGFzIEosIGEgYXMgSywgdiBhcyBWLCBjIGFzIHosIGUgYXMgWSwgQSBhcyBRLCBQIGFzIFosIEIgYXMgZWUsIGIgYXMgcmUgfSBmcm9tIFwiLi9jaGFydC5lcy5qc1wiO1xuLyohXG4gKiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIHYyLjIuMFxuICogaHR0cHM6Ly9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLm5ldGxpZnkuYXBwXG4gKiAoYykgMjAxNy0yMDIyIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIEQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIikge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB2YXIgZSA9IHdpbmRvdy5zY3JlZW47XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4gKGUuZGV2aWNlWERQSSB8fCAxKSAvIChlLmxvZ2ljYWxYRFBJIHx8IDEpO1xuICB9XG4gIHJldHVybiAxO1xufSgpLCBtID0ge1xuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy50b1RleHRMaW5lc1xuICB0b1RleHRMaW5lczogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gW10sIHI7XG4gICAgZm9yIChlID0gW10uY29uY2F0KGUpOyBlLmxlbmd0aDsgKVxuICAgICAgciA9IGUucG9wKCksIHR5cGVvZiByID09IFwic3RyaW5nXCIgPyB0LnVuc2hpZnQuYXBwbHkodCwgci5zcGxpdChgXG5gKSkgOiBBcnJheS5pc0FycmF5KHIpID8gZS5wdXNoLmFwcGx5KGUsIHIpIDogcChlKSB8fCB0LnVuc2hpZnQoXCJcIiArIHIpO1xuICAgIHJldHVybiB0O1xuICB9LFxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG4gIHRleHRTaXplOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgdmFyIGEgPSBbXS5jb25jYXQodCksIGkgPSBhLmxlbmd0aCwgbiA9IGUuZm9udCwgbyA9IDAsIHM7XG4gICAgZm9yIChlLmZvbnQgPSByLnN0cmluZywgcyA9IDA7IHMgPCBpOyArK3MpXG4gICAgICBvID0gTWF0aC5tYXgoZS5tZWFzdXJlVGV4dChhW3NdKS53aWR0aCwgbyk7XG4gICAgcmV0dXJuIGUuZm9udCA9IG4sIHtcbiAgICAgIGhlaWdodDogaSAqIHIubGluZUhlaWdodCxcbiAgICAgIHdpZHRoOiBvXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuICAgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG4gICAqL1xuICBib3VuZDogZnVuY3Rpb24oZSwgdCwgcikge1xuICAgIHJldHVybiBNYXRoLm1heChlLCBNYXRoLm1pbih0LCByKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG4gICAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuICAgKi9cbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSBlLnNsaWNlKCksIGEgPSBbXSwgaSwgbiwgbywgcztcbiAgICBmb3IgKGkgPSAwLCBvID0gdC5sZW5ndGg7IGkgPCBvOyArK2kpXG4gICAgICBzID0gdFtpXSwgbiA9IHIuaW5kZXhPZihzKSwgbiA9PT0gLTEgPyBhLnB1c2goW3MsIDFdKSA6IHIuc3BsaWNlKG4sIDEpO1xuICAgIGZvciAoaSA9IDAsIG8gPSByLmxlbmd0aDsgaSA8IG87ICsraSlcbiAgICAgIGEucHVzaChbcltpXSwgLTFdKTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzcwXG4gICAqL1xuICByYXN0ZXJpemU6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChlICogRCkgLyBEO1xuICB9XG59O1xuZnVuY3Rpb24gQShlLCB0KSB7XG4gIHZhciByID0gdC54LCBhID0gdC55O1xuICBpZiAociA9PT0gbnVsbClcbiAgICByZXR1cm4geyB4OiAwLCB5OiAtMSB9O1xuICBpZiAoYSA9PT0gbnVsbClcbiAgICByZXR1cm4geyB4OiAxLCB5OiAwIH07XG4gIHZhciBpID0gZS54IC0gciwgbiA9IGUueSAtIGEsIG8gPSBNYXRoLnNxcnQoaSAqIGkgKyBuICogbik7XG4gIHJldHVybiB7XG4gICAgeDogbyA/IGkgLyBvIDogMCxcbiAgICB5OiBvID8gbiAvIG8gOiAtMVxuICB9O1xufVxuZnVuY3Rpb24gYWUoZSwgdCwgciwgYSwgaSkge1xuICBzd2l0Y2ggKGkpIHtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByID0gYSA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICByID0gMCwgYSA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHIgPSAxLCBhID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByID0gLTEsIGEgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgciA9IDAsIGEgPSAtMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgciA9IC1yLCBhID0gLWE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaSAqPSBNYXRoLlBJIC8gMTgwLCByID0gTWF0aC5jb3MoaSksIGEgPSBNYXRoLnNpbihpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogZSxcbiAgICB5OiB0LFxuICAgIHZ4OiByLFxuICAgIHZ5OiBhXG4gIH07XG59XG52YXIgdGUgPSAwLCBqID0gMSwgTiA9IDIsIE8gPSA0LCBGID0gODtcbmZ1bmN0aW9uIE0oZSwgdCwgcikge1xuICB2YXIgYSA9IHRlO1xuICByZXR1cm4gZSA8IHIubGVmdCA/IGEgfD0gaiA6IGUgPiByLnJpZ2h0ICYmIChhIHw9IE4pLCB0IDwgci50b3AgPyBhIHw9IEYgOiB0ID4gci5ib3R0b20gJiYgKGEgfD0gTyksIGE7XG59XG5mdW5jdGlvbiBpZShlLCB0KSB7XG4gIGZvciAodmFyIHIgPSBlLngwLCBhID0gZS55MCwgaSA9IGUueDEsIG4gPSBlLnkxLCBvID0gTShyLCBhLCB0KSwgcyA9IE0oaSwgbiwgdCksIGwsIHUsIHY7ICEoIShvIHwgcykgfHwgbyAmIHMpOyApXG4gICAgbCA9IG8gfHwgcywgbCAmIEYgPyAodSA9IHIgKyAoaSAtIHIpICogKHQudG9wIC0gYSkgLyAobiAtIGEpLCB2ID0gdC50b3ApIDogbCAmIE8gPyAodSA9IHIgKyAoaSAtIHIpICogKHQuYm90dG9tIC0gYSkgLyAobiAtIGEpLCB2ID0gdC5ib3R0b20pIDogbCAmIE4gPyAodiA9IGEgKyAobiAtIGEpICogKHQucmlnaHQgLSByKSAvIChpIC0gciksIHUgPSB0LnJpZ2h0KSA6IGwgJiBqICYmICh2ID0gYSArIChuIC0gYSkgKiAodC5sZWZ0IC0gcikgLyAoaSAtIHIpLCB1ID0gdC5sZWZ0KSwgbCA9PT0gbyA/IChyID0gdSwgYSA9IHYsIG8gPSBNKHIsIGEsIHQpKSA6IChpID0gdSwgbiA9IHYsIHMgPSBNKGksIG4sIHQpKTtcbiAgcmV0dXJuIHtcbiAgICB4MDogcixcbiAgICB4MTogaSxcbiAgICB5MDogYSxcbiAgICB5MTogblxuICB9O1xufVxuZnVuY3Rpb24gUChlLCB0KSB7XG4gIHZhciByID0gdC5hbmNob3IsIGEgPSBlLCBpLCBuO1xuICByZXR1cm4gdC5jbGFtcCAmJiAoYSA9IGllKGEsIHQuYXJlYSkpLCByID09PSBcInN0YXJ0XCIgPyAoaSA9IGEueDAsIG4gPSBhLnkwKSA6IHIgPT09IFwiZW5kXCIgPyAoaSA9IGEueDEsIG4gPSBhLnkxKSA6IChpID0gKGEueDAgKyBhLngxKSAvIDIsIG4gPSAoYS55MCArIGEueTEpIC8gMiksIGFlKGksIG4sIGUudngsIGUudnksIHQuYWxpZ24pO1xufVxudmFyIEUgPSB7XG4gIGFyYzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gKGUuc3RhcnRBbmdsZSArIGUuZW5kQW5nbGUpIC8gMiwgYSA9IE1hdGguY29zKHIpLCBpID0gTWF0aC5zaW4ociksIG4gPSBlLmlubmVyUmFkaXVzLCBvID0gZS5vdXRlclJhZGl1cztcbiAgICByZXR1cm4gUCh7XG4gICAgICB4MDogZS54ICsgYSAqIG4sXG4gICAgICB5MDogZS55ICsgaSAqIG4sXG4gICAgICB4MTogZS54ICsgYSAqIG8sXG4gICAgICB5MTogZS55ICsgaSAqIG8sXG4gICAgICB2eDogYSxcbiAgICAgIHZ5OiBpXG4gICAgfSwgdCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSBBKGUsIHQub3JpZ2luKSwgYSA9IHIueCAqIGUub3B0aW9ucy5yYWRpdXMsIGkgPSByLnkgKiBlLm9wdGlvbnMucmFkaXVzO1xuICAgIHJldHVybiBQKHtcbiAgICAgIHgwOiBlLnggLSBhLFxuICAgICAgeTA6IGUueSAtIGksXG4gICAgICB4MTogZS54ICsgYSxcbiAgICAgIHkxOiBlLnkgKyBpLFxuICAgICAgdng6IHIueCxcbiAgICAgIHZ5OiByLnlcbiAgICB9LCB0KTtcbiAgfSxcbiAgYmFyOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSBBKGUsIHQub3JpZ2luKSwgYSA9IGUueCwgaSA9IGUueSwgbiA9IDAsIG8gPSAwO1xuICAgIHJldHVybiBlLmhvcml6b250YWwgPyAoYSA9IE1hdGgubWluKGUueCwgZS5iYXNlKSwgbiA9IE1hdGguYWJzKGUuYmFzZSAtIGUueCkpIDogKGkgPSBNYXRoLm1pbihlLnksIGUuYmFzZSksIG8gPSBNYXRoLmFicyhlLmJhc2UgLSBlLnkpKSwgUCh7XG4gICAgICB4MDogYSxcbiAgICAgIHkwOiBpICsgbyxcbiAgICAgIHgxOiBhICsgbixcbiAgICAgIHkxOiBpLFxuICAgICAgdng6IHIueCxcbiAgICAgIHZ5OiByLnlcbiAgICB9LCB0KTtcbiAgfSxcbiAgZmFsbGJhY2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IEEoZSwgdC5vcmlnaW4pO1xuICAgIHJldHVybiBQKHtcbiAgICAgIHgwOiBlLngsXG4gICAgICB5MDogZS55LFxuICAgICAgeDE6IGUueCArIChlLndpZHRoIHx8IDApLFxuICAgICAgeTE6IGUueSArIChlLmhlaWdodCB8fCAwKSxcbiAgICAgIHZ4OiByLngsXG4gICAgICB2eTogci55XG4gICAgfSwgdCk7XG4gIH1cbn0sIHggPSBtLnJhc3Rlcml6ZTtcbmZ1bmN0aW9uIG5lKGUpIHtcbiAgdmFyIHQgPSBlLmJvcmRlcldpZHRoIHx8IDAsIHIgPSBlLnBhZGRpbmcsIGEgPSBlLnNpemUuaGVpZ2h0LCBpID0gZS5zaXplLndpZHRoLCBuID0gLWkgLyAyLCBvID0gLWEgLyAyO1xuICByZXR1cm4ge1xuICAgIGZyYW1lOiB7XG4gICAgICB4OiBuIC0gci5sZWZ0IC0gdCxcbiAgICAgIHk6IG8gLSByLnRvcCAtIHQsXG4gICAgICB3OiBpICsgci53aWR0aCArIHQgKiAyLFxuICAgICAgaDogYSArIHIuaGVpZ2h0ICsgdCAqIDJcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHg6IG4sXG4gICAgICB5OiBvLFxuICAgICAgdzogaSxcbiAgICAgIGg6IGFcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBvZShlLCB0KSB7XG4gIHZhciByID0gdC5jaGFydC5nZXREYXRhc2V0TWV0YSh0LmRhdGFzZXRJbmRleCkudlNjYWxlO1xuICBpZiAoIXIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChyLnhDZW50ZXIgIT09IHZvaWQgMCAmJiByLnlDZW50ZXIgIT09IHZvaWQgMClcbiAgICByZXR1cm4geyB4OiByLnhDZW50ZXIsIHk6IHIueUNlbnRlciB9O1xuICB2YXIgYSA9IHIuZ2V0QmFzZVBpeGVsKCk7XG4gIHJldHVybiBlLmhvcml6b250YWwgPyB7IHg6IGEsIHk6IG51bGwgfSA6IHsgeDogbnVsbCwgeTogYSB9O1xufVxuZnVuY3Rpb24gc2UoZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIFEgPyBFLmFyYyA6IGUgaW5zdGFuY2VvZiBaID8gRS5wb2ludCA6IGUgaW5zdGFuY2VvZiBlZSA/IEUuYmFyIDogRS5mYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGxlKGUsIHQsIHIsIGEsIGksIG4pIHtcbiAgdmFyIG8gPSBNYXRoLlBJIC8gMjtcbiAgaWYgKG4pIHtcbiAgICB2YXIgcyA9IE1hdGgubWluKG4sIGkgLyAyLCBhIC8gMiksIGwgPSB0ICsgcywgdSA9IHIgKyBzLCB2ID0gdCArIGEgLSBzLCBkID0gciArIGkgLSBzO1xuICAgIGUubW92ZVRvKHQsIHUpLCBsIDwgdiAmJiB1IDwgZCA/IChlLmFyYyhsLCB1LCBzLCAtTWF0aC5QSSwgLW8pLCBlLmFyYyh2LCB1LCBzLCAtbywgMCksIGUuYXJjKHYsIGQsIHMsIDAsIG8pLCBlLmFyYyhsLCBkLCBzLCBvLCBNYXRoLlBJKSkgOiBsIDwgdiA/IChlLm1vdmVUbyhsLCByKSwgZS5hcmModiwgdSwgcywgLW8sIG8pLCBlLmFyYyhsLCB1LCBzLCBvLCBNYXRoLlBJICsgbykpIDogdSA8IGQgPyAoZS5hcmMobCwgdSwgcywgLU1hdGguUEksIDApLCBlLmFyYyhsLCBkLCBzLCAwLCBNYXRoLlBJKSkgOiBlLmFyYyhsLCB1LCBzLCAtTWF0aC5QSSwgTWF0aC5QSSksIGUuY2xvc2VQYXRoKCksIGUubW92ZVRvKHQsIHIpO1xuICB9IGVsc2VcbiAgICBlLnJlY3QodCwgciwgYSwgaSk7XG59XG5mdW5jdGlvbiB1ZShlLCB0LCByKSB7XG4gIHZhciBhID0gci5iYWNrZ3JvdW5kQ29sb3IsIGkgPSByLmJvcmRlckNvbG9yLCBuID0gci5ib3JkZXJXaWR0aDtcbiAgIWEgJiYgKCFpIHx8ICFuKSB8fCAoZS5iZWdpblBhdGgoKSwgbGUoXG4gICAgZSxcbiAgICB4KHQueCkgKyBuIC8gMixcbiAgICB4KHQueSkgKyBuIC8gMixcbiAgICB4KHQudykgLSBuLFxuICAgIHgodC5oKSAtIG4sXG4gICAgci5ib3JkZXJSYWRpdXNcbiAgKSwgZS5jbG9zZVBhdGgoKSwgYSAmJiAoZS5maWxsU3R5bGUgPSBhLCBlLmZpbGwoKSksIGkgJiYgbiAmJiAoZS5zdHJva2VTdHlsZSA9IGksIGUubGluZVdpZHRoID0gbiwgZS5saW5lSm9pbiA9IFwibWl0ZXJcIiwgZS5zdHJva2UoKSkpO1xufVxuZnVuY3Rpb24gdmUoZSwgdCwgcikge1xuICB2YXIgYSA9IHIubGluZUhlaWdodCwgaSA9IGUudywgbiA9IGUueCwgbyA9IGUueSArIGEgLyAyO1xuICByZXR1cm4gdCA9PT0gXCJjZW50ZXJcIiA/IG4gKz0gaSAvIDIgOiAodCA9PT0gXCJlbmRcIiB8fCB0ID09PSBcInJpZ2h0XCIpICYmIChuICs9IGkpLCB7XG4gICAgaDogYSxcbiAgICB3OiBpLFxuICAgIHg6IG4sXG4gICAgeTogb1xuICB9O1xufVxuZnVuY3Rpb24gZGUoZSwgdCwgcikge1xuICB2YXIgYSA9IGUuc2hhZG93Qmx1ciwgaSA9IHIuc3Ryb2tlZCwgbiA9IHgoci54KSwgbyA9IHgoci55KSwgcyA9IHgoci53KTtcbiAgaSAmJiBlLnN0cm9rZVRleHQodCwgbiwgbywgcyksIHIuZmlsbGVkICYmIChhICYmIGkgJiYgKGUuc2hhZG93Qmx1ciA9IDApLCBlLmZpbGxUZXh0KHQsIG4sIG8sIHMpLCBhICYmIGkgJiYgKGUuc2hhZG93Qmx1ciA9IGEpKTtcbn1cbmZ1bmN0aW9uIGZlKGUsIHQsIHIsIGEpIHtcbiAgdmFyIGkgPSBhLnRleHRBbGlnbiwgbiA9IGEuY29sb3IsIG8gPSAhIW4sIHMgPSBhLmZvbnQsIGwgPSB0Lmxlbmd0aCwgdSA9IGEudGV4dFN0cm9rZUNvbG9yLCB2ID0gYS50ZXh0U3Ryb2tlV2lkdGgsIGQgPSB1ICYmIHYsIHk7XG4gIGlmICghKCFsIHx8ICFvICYmICFkKSlcbiAgICBmb3IgKHIgPSB2ZShyLCBpLCBzKSwgZS5mb250ID0gcy5zdHJpbmcsIGUudGV4dEFsaWduID0gaSwgZS50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCBlLnNoYWRvd0JsdXIgPSBhLnRleHRTaGFkb3dCbHVyLCBlLnNoYWRvd0NvbG9yID0gYS50ZXh0U2hhZG93Q29sb3IsIG8gJiYgKGUuZmlsbFN0eWxlID0gbiksIGQgJiYgKGUubGluZUpvaW4gPSBcInJvdW5kXCIsIGUubGluZVdpZHRoID0gdiwgZS5zdHJva2VTdHlsZSA9IHUpLCB5ID0gMCwgbCA9IHQubGVuZ3RoOyB5IDwgbDsgKyt5KVxuICAgICAgZGUoZSwgdFt5XSwge1xuICAgICAgICBzdHJva2VkOiBkLFxuICAgICAgICBmaWxsZWQ6IG8sXG4gICAgICAgIHc6IHIudyxcbiAgICAgICAgeDogci54LFxuICAgICAgICB5OiByLnkgKyByLmggKiB5XG4gICAgICB9KTtcbn1cbnZhciBMID0gZnVuY3Rpb24oZSwgdCwgciwgYSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIGkuX2NvbmZpZyA9IGUsIGkuX2luZGV4ID0gYSwgaS5fbW9kZWwgPSBudWxsLCBpLl9yZWN0cyA9IG51bGwsIGkuX2N0eCA9IHQsIGkuX2VsID0gcjtcbn07XG5nKEwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vZGVsaXplOiBmdW5jdGlvbihlLCB0LCByLCBhKSB7XG4gICAgdmFyIGkgPSB0aGlzLCBuID0gaS5faW5kZXgsIG8gPSBxKGYoW3IuZm9udCwge31dLCBhLCBuKSksIHMgPSBmKFtyLmNvbG9yLCBKLmNvbG9yXSwgYSwgbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsaWduOiBmKFtyLmFsaWduLCBcImNlbnRlclwiXSwgYSwgbiksXG4gICAgICBhbmNob3I6IGYoW3IuYW5jaG9yLCBcImNlbnRlclwiXSwgYSwgbiksXG4gICAgICBhcmVhOiBhLmNoYXJ0LmNoYXJ0QXJlYSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZihbci5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBhLCBuKSxcbiAgICAgIGJvcmRlckNvbG9yOiBmKFtyLmJvcmRlckNvbG9yLCBudWxsXSwgYSwgbiksXG4gICAgICBib3JkZXJSYWRpdXM6IGYoW3IuYm9yZGVyUmFkaXVzLCAwXSwgYSwgbiksXG4gICAgICBib3JkZXJXaWR0aDogZihbci5ib3JkZXJXaWR0aCwgMF0sIGEsIG4pLFxuICAgICAgY2xhbXA6IGYoW3IuY2xhbXAsICExXSwgYSwgbiksXG4gICAgICBjbGlwOiBmKFtyLmNsaXAsICExXSwgYSwgbiksXG4gICAgICBjb2xvcjogcyxcbiAgICAgIGRpc3BsYXk6IGUsXG4gICAgICBmb250OiBvLFxuICAgICAgbGluZXM6IHQsXG4gICAgICBvZmZzZXQ6IGYoW3Iub2Zmc2V0LCA0XSwgYSwgbiksXG4gICAgICBvcGFjaXR5OiBmKFtyLm9wYWNpdHksIDFdLCBhLCBuKSxcbiAgICAgIG9yaWdpbjogb2UoaS5fZWwsIGEpLFxuICAgICAgcGFkZGluZzogSyhmKFtyLnBhZGRpbmcsIDRdLCBhLCBuKSksXG4gICAgICBwb3NpdGlvbmVyOiBzZShpLl9lbCksXG4gICAgICByb3RhdGlvbjogZihbci5yb3RhdGlvbiwgMF0sIGEsIG4pICogKE1hdGguUEkgLyAxODApLFxuICAgICAgc2l6ZTogbS50ZXh0U2l6ZShpLl9jdHgsIHQsIG8pLFxuICAgICAgdGV4dEFsaWduOiBmKFtyLnRleHRBbGlnbiwgXCJzdGFydFwiXSwgYSwgbiksXG4gICAgICB0ZXh0U2hhZG93Qmx1cjogZihbci50ZXh0U2hhZG93Qmx1ciwgMF0sIGEsIG4pLFxuICAgICAgdGV4dFNoYWRvd0NvbG9yOiBmKFtyLnRleHRTaGFkb3dDb2xvciwgc10sIGEsIG4pLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiBmKFtyLnRleHRTdHJva2VDb2xvciwgc10sIGEsIG4pLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiBmKFtyLnRleHRTdHJva2VXaWR0aCwgMF0sIGEsIG4pXG4gICAgfTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSB0aGlzLCByID0gbnVsbCwgYSA9IG51bGwsIGkgPSB0Ll9pbmRleCwgbiA9IHQuX2NvbmZpZywgbywgcywgbCwgdSA9IGYoW24uZGlzcGxheSwgITBdLCBlLCBpKTtcbiAgICB1ICYmIChvID0gZS5kYXRhc2V0LmRhdGFbaV0sIHMgPSBWKHoobi5mb3JtYXR0ZXIsIFtvLCBlXSksIG8pLCBsID0gcChzKSA/IFtdIDogbS50b1RleHRMaW5lcyhzKSwgbC5sZW5ndGggJiYgKHIgPSB0Ll9tb2RlbGl6ZSh1LCBsLCBuLCBlKSwgYSA9IG5lKHIpKSksIHQuX21vZGVsID0gciwgdC5fcmVjdHMgPSBhO1xuICB9LFxuICBnZW9tZXRyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY3RzID8gdGhpcy5fcmVjdHMuZnJhbWUgOiB7fTtcbiAgfSxcbiAgcm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCA/IHRoaXMuX21vZGVsLnJvdGF0aW9uIDogMDtcbiAgfSxcbiAgdmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLm9wYWNpdHk7XG4gIH0sXG4gIG1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IHRoaXMsIGEgPSBlLmN0eCwgaSA9IHIuX21vZGVsLCBuID0gci5fcmVjdHMsIG87XG4gICAgdGhpcy52aXNpYmxlKCkgJiYgKGEuc2F2ZSgpLCBpLmNsaXAgJiYgKG8gPSBpLmFyZWEsIGEuYmVnaW5QYXRoKCksIGEucmVjdChcbiAgICAgIG8ubGVmdCxcbiAgICAgIG8udG9wLFxuICAgICAgby5yaWdodCAtIG8ubGVmdCxcbiAgICAgIG8uYm90dG9tIC0gby50b3BcbiAgICApLCBhLmNsaXAoKSksIGEuZ2xvYmFsQWxwaGEgPSBtLmJvdW5kKDAsIGkub3BhY2l0eSwgMSksIGEudHJhbnNsYXRlKHgodC54KSwgeCh0LnkpKSwgYS5yb3RhdGUoaS5yb3RhdGlvbiksIHVlKGEsIG4uZnJhbWUsIGkpLCBmZShhLCBpLmxpbmVzLCBuLnRleHQsIGkpLCBhLnJlc3RvcmUoKSk7XG4gIH1cbn0pO1xudmFyIGhlID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTEsIHllID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbmZ1bmN0aW9uIGIoZSwgdCwgcikge1xuICB2YXIgYSA9IE1hdGguY29zKHIpLCBpID0gTWF0aC5zaW4ociksIG4gPSB0LngsIG8gPSB0Lnk7XG4gIHJldHVybiB7XG4gICAgeDogbiArIGEgKiAoZS54IC0gbikgLSBpICogKGUueSAtIG8pLFxuICAgIHk6IG8gKyBpICogKGUueCAtIG4pICsgYSAqIChlLnkgLSBvKVxuICB9O1xufVxuZnVuY3Rpb24gVyhlLCB0KSB7XG4gIHZhciByID0geWUsIGEgPSBoZSwgaSA9IHQub3JpZ2luLCBuLCBvLCBzLCBsLCB1O1xuICBmb3IgKG4gPSAwOyBuIDwgZS5sZW5ndGg7ICsrbilcbiAgICBvID0gZVtuXSwgcyA9IG8ueCAtIGkueCwgbCA9IG8ueSAtIGkueSwgdSA9IHQudnggKiBzICsgdC52eSAqIGwsIHIgPSBNYXRoLm1pbihyLCB1KSwgYSA9IE1hdGgubWF4KGEsIHUpO1xuICByZXR1cm4ge1xuICAgIG1pbjogcixcbiAgICBtYXg6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIEkoZSwgdCkge1xuICB2YXIgciA9IHQueCAtIGUueCwgYSA9IHQueSAtIGUueSwgaSA9IE1hdGguc3FydChyICogciArIGEgKiBhKTtcbiAgcmV0dXJuIHtcbiAgICB2eDogKHQueCAtIGUueCkgLyBpLFxuICAgIHZ5OiAodC55IC0gZS55KSAvIGksXG4gICAgb3JpZ2luOiBlLFxuICAgIGxuOiBpXG4gIH07XG59XG52YXIgRyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yb3RhdGlvbiA9IDAsIHRoaXMuX3JlY3QgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHc6IDAsXG4gICAgaDogMFxuICB9O1xufTtcbmcoRy5wcm90b3R5cGUsIHtcbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMuX3JlY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUueCArIGUudyAvIDIsXG4gICAgICB5OiBlLnkgKyBlLmggLyAyXG4gICAgfTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgdGhpcy5fcm90YXRpb24gPSByLCB0aGlzLl9yZWN0ID0ge1xuICAgICAgeDogdC54ICsgZS54LFxuICAgICAgeTogdC55ICsgZS55LFxuICAgICAgdzogdC53LFxuICAgICAgaDogdC5oXG4gICAgfTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMsIHIgPSAxLCBhID0gdC5fcmVjdDtcbiAgICByZXR1cm4gZSA9IGIoZSwgdC5jZW50ZXIoKSwgLXQuX3JvdGF0aW9uKSwgIShlLnggPCBhLnggLSByIHx8IGUueSA8IGEueSAtIHIgfHwgZS54ID4gYS54ICsgYS53ICsgciAqIDIgfHwgZS55ID4gYS55ICsgYS5oICsgciAqIDIpO1xuICB9LFxuICAvLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuICAvLyBodHRwczovL2dhbWVkZXZlbG9wbWVudC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL2NvbGxpc2lvbi1kZXRlY3Rpb24tdXNpbmctdGhlLXNlcGFyYXRpbmctYXhpcy10aGVvcmVtLS1nYW1lZGV2LTE2OVxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSB0aGlzLl9wb2ludHMoKSwgciA9IGUuX3BvaW50cygpLCBhID0gW1xuICAgICAgSSh0WzBdLCB0WzFdKSxcbiAgICAgIEkodFswXSwgdFszXSlcbiAgICBdLCBpLCBuLCBvO1xuICAgIGZvciAodGhpcy5fcm90YXRpb24gIT09IGUuX3JvdGF0aW9uICYmIGEucHVzaChcbiAgICAgIEkoclswXSwgclsxXSksXG4gICAgICBJKHJbMF0sIHJbM10pXG4gICAgKSwgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKG4gPSBXKHQsIGFbaV0pLCBvID0gVyhyLCBhW2ldKSwgbi5tYXggPCBvLm1pbiB8fCBvLm1heCA8IG4ubWluKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9LFxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcywgdCA9IGUuX3JlY3QsIHIgPSBlLl9yb3RhdGlvbiwgYSA9IGUuY2VudGVyKCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGIoeyB4OiB0LngsIHk6IHQueSB9LCBhLCByKSxcbiAgICAgIGIoeyB4OiB0LnggKyB0LncsIHk6IHQueSB9LCBhLCByKSxcbiAgICAgIGIoeyB4OiB0LnggKyB0LncsIHk6IHQueSArIHQuaCB9LCBhLCByKSxcbiAgICAgIGIoeyB4OiB0LngsIHk6IHQueSArIHQuaCB9LCBhLCByKVxuICAgIF07XG4gIH1cbn0pO1xuZnVuY3Rpb24gSChlLCB0LCByKSB7XG4gIHZhciBhID0gdC5wb3NpdGlvbmVyKGUsIHQpLCBpID0gYS52eCwgbiA9IGEudnk7XG4gIGlmICghaSAmJiAhbilcbiAgICByZXR1cm4geyB4OiBhLngsIHk6IGEueSB9O1xuICB2YXIgbyA9IHIudywgcyA9IHIuaCwgbCA9IHQucm90YXRpb24sIHUgPSBNYXRoLmFicyhvIC8gMiAqIE1hdGguY29zKGwpKSArIE1hdGguYWJzKHMgLyAyICogTWF0aC5zaW4obCkpLCB2ID0gTWF0aC5hYnMobyAvIDIgKiBNYXRoLnNpbihsKSkgKyBNYXRoLmFicyhzIC8gMiAqIE1hdGguY29zKGwpKSwgZCA9IDEgLyBNYXRoLm1heChNYXRoLmFicyhpKSwgTWF0aC5hYnMobikpO1xuICByZXR1cm4gdSAqPSBpICogZCwgdiAqPSBuICogZCwgdSArPSB0Lm9mZnNldCAqIGksIHYgKz0gdC5vZmZzZXQgKiBuLCB7XG4gICAgeDogYS54ICsgdSxcbiAgICB5OiBhLnkgKyB2XG4gIH07XG59XG5mdW5jdGlvbiB4ZShlLCB0KSB7XG4gIHZhciByLCBhLCBpLCBuO1xuICBmb3IgKHIgPSBlLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKVxuICAgIGZvciAoaSA9IGVbcl0uJGxheW91dCwgYSA9IHIgLSAxOyBhID49IDAgJiYgaS5fdmlzaWJsZTsgLS1hKVxuICAgICAgbiA9IGVbYV0uJGxheW91dCwgbi5fdmlzaWJsZSAmJiBpLl9ib3guaW50ZXJzZWN0cyhuLl9ib3gpICYmIHQoaSwgbik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2UoZSkge1xuICB2YXIgdCwgciwgYSwgaSwgbiwgbywgcztcbiAgZm9yICh0ID0gMCwgciA9IGUubGVuZ3RoOyB0IDwgcjsgKyt0KVxuICAgIGEgPSBlW3RdLCBpID0gYS4kbGF5b3V0LCBpLl92aXNpYmxlICYmIChzID0gbmV3IFByb3h5KGEuX2VsLCB7IGdldDogKGwsIHUpID0+IGwuZ2V0UHJvcHMoW3VdLCAhMClbdV0gfSksIG4gPSBhLmdlb21ldHJ5KCksIG8gPSBIKHMsIGEubW9kZWwoKSwgbiksIGkuX2JveC51cGRhdGUobywgbiwgYS5yb3RhdGlvbigpKSk7XG4gIHJldHVybiB4ZShlLCBmdW5jdGlvbihsLCB1KSB7XG4gICAgdmFyIHYgPSBsLl9oaWRhYmxlLCBkID0gdS5faGlkYWJsZTtcbiAgICB2ICYmIGQgfHwgZCA/IHUuX3Zpc2libGUgPSAhMSA6IHYgJiYgKGwuX3Zpc2libGUgPSAhMSk7XG4gIH0pO1xufVxudmFyIHcgPSB7XG4gIHByZXBhcmU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IFtdLCByLCBhLCBpLCBuLCBvO1xuICAgIGZvciAociA9IDAsIGkgPSBlLmxlbmd0aDsgciA8IGk7ICsrcilcbiAgICAgIGZvciAoYSA9IDAsIG4gPSBlW3JdLmxlbmd0aDsgYSA8IG47ICsrYSlcbiAgICAgICAgbyA9IGVbcl1bYV0sIHQucHVzaChvKSwgby4kbGF5b3V0ID0ge1xuICAgICAgICAgIF9ib3g6IG5ldyBHKCksXG4gICAgICAgICAgX2hpZGFibGU6ICExLFxuICAgICAgICAgIF92aXNpYmxlOiAhMCxcbiAgICAgICAgICBfc2V0OiByLFxuICAgICAgICAgIF9pZHg6IG8uX2luZGV4XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHQuc29ydChmdW5jdGlvbihzLCBsKSB7XG4gICAgICB2YXIgdSA9IHMuJGxheW91dCwgdiA9IGwuJGxheW91dDtcbiAgICAgIHJldHVybiB1Ll9pZHggPT09IHYuX2lkeCA/IHYuX3NldCAtIHUuX3NldCA6IHYuX2lkeCAtIHUuX2lkeDtcbiAgICB9KSwgdGhpcy51cGRhdGUodCksIHQ7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gITEsIHIsIGEsIGksIG4sIG87XG4gICAgZm9yIChyID0gMCwgYSA9IGUubGVuZ3RoOyByIDwgYTsgKytyKVxuICAgICAgaSA9IGVbcl0sIG4gPSBpLm1vZGVsKCksIG8gPSBpLiRsYXlvdXQsIG8uX2hpZGFibGUgPSBuICYmIG4uZGlzcGxheSA9PT0gXCJhdXRvXCIsIG8uX3Zpc2libGUgPSBpLnZpc2libGUoKSwgdCB8PSBvLl9oaWRhYmxlO1xuICAgIHQgJiYgX2UoZSk7XG4gIH0sXG4gIGxvb2t1cDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByLCBhO1xuICAgIGZvciAociA9IGUubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpXG4gICAgICBpZiAoYSA9IGVbcl0uJGxheW91dCwgYSAmJiBhLl92aXNpYmxlICYmIGEuX2JveC5jb250YWlucyh0KSlcbiAgICAgICAgcmV0dXJuIGVbcl07XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciwgYSwgaSwgbiwgbywgcztcbiAgICBmb3IgKHIgPSAwLCBhID0gdC5sZW5ndGg7IHIgPCBhOyArK3IpXG4gICAgICBpID0gdFtyXSwgbiA9IGkuJGxheW91dCwgbi5fdmlzaWJsZSAmJiAobyA9IGkuZ2VvbWV0cnkoKSwgcyA9IEgoaS5fZWwsIGkubW9kZWwoKSwgbyksIG4uX2JveC51cGRhdGUocywgbywgaS5yb3RhdGlvbigpKSwgaS5kcmF3KGUsIHMpKTtcbiAgfVxufSwgY2UgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChwKGUpKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgdCA9IGUsIHIsIGEsIGk7XG4gIGlmIChyZShlKSlcbiAgICBpZiAoIXAoZS5sYWJlbCkpXG4gICAgICB0ID0gZS5sYWJlbDtcbiAgICBlbHNlIGlmICghcChlLnIpKVxuICAgICAgdCA9IGUucjtcbiAgICBlbHNlXG4gICAgICBmb3IgKHQgPSBcIlwiLCByID0gT2JqZWN0LmtleXMoZSksIGkgPSAwLCBhID0gci5sZW5ndGg7IGkgPCBhOyArK2kpXG4gICAgICAgIHQgKz0gKGkgIT09IDAgPyBcIiwgXCIgOiBcIlwiKSArIHJbaV0gKyBcIjogXCIgKyBlW3JbaV1dO1xuICByZXR1cm4gXCJcIiArIHQ7XG59LCBiZSA9IHtcbiAgYWxpZ246IFwiY2VudGVyXCIsXG4gIGFuY2hvcjogXCJjZW50ZXJcIixcbiAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICBib3JkZXJDb2xvcjogbnVsbCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMCxcbiAgY2xhbXA6ICExLFxuICBjbGlwOiAhMSxcbiAgY29sb3I6IHZvaWQgMCxcbiAgZGlzcGxheTogITAsXG4gIGZvbnQ6IHtcbiAgICBmYW1pbHk6IHZvaWQgMCxcbiAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgc2l6ZTogdm9pZCAwLFxuICAgIHN0eWxlOiB2b2lkIDAsXG4gICAgd2VpZ2h0OiBudWxsXG4gIH0sXG4gIGZvcm1hdHRlcjogY2UsXG4gIGxhYmVsczogdm9pZCAwLFxuICBsaXN0ZW5lcnM6IHt9LFxuICBvZmZzZXQ6IDQsXG4gIG9wYWNpdHk6IDEsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDQsXG4gICAgcmlnaHQ6IDQsXG4gICAgYm90dG9tOiA0LFxuICAgIGxlZnQ6IDRcbiAgfSxcbiAgcm90YXRpb246IDAsXG4gIHRleHRBbGlnbjogXCJzdGFydFwiLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHZvaWQgMCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB0ZXh0U2hhZG93Qmx1cjogMCxcbiAgdGV4dFNoYWRvd0NvbG9yOiB2b2lkIDBcbn0sIGggPSBcIiRkYXRhbGFiZWxzXCIsIFUgPSBcIiRkZWZhdWx0XCI7XG5mdW5jdGlvbiBwZShlLCB0KSB7XG4gIHZhciByID0gZS5kYXRhbGFiZWxzLCBhID0ge30sIGkgPSBbXSwgbiwgbztcbiAgcmV0dXJuIHIgPT09ICExID8gbnVsbCA6IChyID09PSAhMCAmJiAociA9IHt9KSwgdCA9IGcoe30sIFt0LCByXSksIG4gPSB0LmxhYmVscyB8fCB7fSwgbyA9IE9iamVjdC5rZXlzKG4pLCBkZWxldGUgdC5sYWJlbHMsIG8ubGVuZ3RoID8gby5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBuW3NdICYmIGkucHVzaChnKHt9LCBbXG4gICAgICB0LFxuICAgICAgbltzXSxcbiAgICAgIHsgX2tleTogcyB9XG4gICAgXSkpO1xuICB9KSA6IGkucHVzaCh0KSwgYSA9IGkucmVkdWNlKGZ1bmN0aW9uKHMsIGwpIHtcbiAgICByZXR1cm4gWShsLmxpc3RlbmVycyB8fCB7fSwgZnVuY3Rpb24odSwgdikge1xuICAgICAgc1t2XSA9IHNbdl0gfHwge30sIHNbdl1bbC5fa2V5IHx8IFVdID0gdTtcbiAgICB9KSwgZGVsZXRlIGwubGlzdGVuZXJzLCBzO1xuICB9LCB7fSksIHtcbiAgICBsYWJlbHM6IGksXG4gICAgbGlzdGVuZXJzOiBhXG4gIH0pO1xufVxuZnVuY3Rpb24gUihlLCB0LCByLCBhKSB7XG4gIGlmICh0KSB7XG4gICAgdmFyIGkgPSByLiRjb250ZXh0LCBuID0gci4kZ3JvdXBzLCBvO1xuICAgIHRbbi5fc2V0XSAmJiAobyA9IHRbbi5fc2V0XVtuLl9rZXldLCBvICYmIHoobywgW2ksIGFdKSA9PT0gITAgJiYgKGVbaF0uX2RpcnR5ID0gITAsIHIudXBkYXRlKGkpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lKGUsIHQsIHIsIGEsIGkpIHtcbiAgdmFyIG4sIG87XG4gICFyICYmICFhIHx8IChyID8gYSA/IHIgIT09IGEgJiYgKG8gPSBuID0gITApIDogbyA9ICEwIDogbiA9ICEwLCBvICYmIFIoZSwgdC5sZWF2ZSwgciwgaSksIG4gJiYgUihlLCB0LmVudGVyLCBhLCBpKSk7XG59XG5mdW5jdGlvbiB3ZShlLCB0KSB7XG4gIHZhciByID0gZVtoXSwgYSA9IHIuX2xpc3RlbmVycywgaSwgbjtcbiAgaWYgKCEoIWEuZW50ZXIgJiYgIWEubGVhdmUpKSB7XG4gICAgaWYgKHQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIilcbiAgICAgIG4gPSB3Lmxvb2t1cChyLl9sYWJlbHMsIHQpO1xuICAgIGVsc2UgaWYgKHQudHlwZSAhPT0gXCJtb3VzZW91dFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGkgPSByLl9ob3ZlcmVkLCByLl9ob3ZlcmVkID0gbiwgbWUoZSwgYSwgaSwgbiwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlKGUsIHQpIHtcbiAgdmFyIHIgPSBlW2hdLCBhID0gci5fbGlzdGVuZXJzLmNsaWNrLCBpID0gYSAmJiB3Lmxvb2t1cChyLl9sYWJlbHMsIHQpO1xuICBpICYmIFIoZSwgYSwgaSwgdCk7XG59XG52YXIgTWUgPSB7XG4gIGlkOiBcImRhdGFsYWJlbHNcIixcbiAgZGVmYXVsdHM6IGJlLFxuICBiZWZvcmVJbml0OiBmdW5jdGlvbihlKSB7XG4gICAgZVtoXSA9IHtcbiAgICAgIF9hY3RpdmVzOiBbXVxuICAgIH07XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gZVtoXTtcbiAgICB0Ll9saXN0ZW5lZCA9ICExLCB0Ll9saXN0ZW5lcnMgPSB7fSwgdC5fZGF0YXNldHMgPSBbXSwgdC5fbGFiZWxzID0gW107XG4gIH0sXG4gIGFmdGVyRGF0YXNldFVwZGF0ZTogZnVuY3Rpb24oZSwgdCwgcikge1xuICAgIHZhciBhID0gdC5pbmRleCwgaSA9IGVbaF0sIG4gPSBpLl9kYXRhc2V0c1thXSA9IFtdLCBvID0gZS5pc0RhdGFzZXRWaXNpYmxlKGEpLCBzID0gZS5kYXRhLmRhdGFzZXRzW2FdLCBsID0gcGUocywgciksIHUgPSB0Lm1ldGEuZGF0YSB8fCBbXSwgdiA9IGUuY3R4LCBkLCB5LCAkLCBULCBTLCBCLCBjLCBfO1xuICAgIGZvciAodi5zYXZlKCksIGQgPSAwLCAkID0gdS5sZW5ndGg7IGQgPCAkOyArK2QpXG4gICAgICBpZiAoYyA9IHVbZF0sIGNbaF0gPSBbXSwgbyAmJiBjICYmIGUuZ2V0RGF0YVZpc2liaWxpdHkoZCkgJiYgIWMuc2tpcClcbiAgICAgICAgZm9yICh5ID0gMCwgVCA9IGwubGFiZWxzLmxlbmd0aDsgeSA8IFQ7ICsreSlcbiAgICAgICAgICBTID0gbC5sYWJlbHNbeV0sIEIgPSBTLl9rZXksIF8gPSBuZXcgTChTLCB2LCBjLCBkKSwgXy4kZ3JvdXBzID0ge1xuICAgICAgICAgICAgX3NldDogYSxcbiAgICAgICAgICAgIF9rZXk6IEIgfHwgVVxuICAgICAgICAgIH0sIF8uJGNvbnRleHQgPSB7XG4gICAgICAgICAgICBhY3RpdmU6ICExLFxuICAgICAgICAgICAgY2hhcnQ6IGUsXG4gICAgICAgICAgICBkYXRhSW5kZXg6IGQsXG4gICAgICAgICAgICBkYXRhc2V0OiBzLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBhXG4gICAgICAgICAgfSwgXy51cGRhdGUoXy4kY29udGV4dCksIGNbaF0ucHVzaChfKSwgbi5wdXNoKF8pO1xuICAgIHYucmVzdG9yZSgpLCBnKGkuX2xpc3RlbmVycywgbC5saXN0ZW5lcnMsIHtcbiAgICAgIG1lcmdlcjogZnVuY3Rpb24oaywgQywgWCkge1xuICAgICAgICBDW2tdID0gQ1trXSB8fCB7fSwgQ1trXVt0LmluZGV4XSA9IFhba10sIGkuX2xpc3RlbmVkID0gITA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgZVtoXS5fbGFiZWxzID0gdy5wcmVwYXJlKGVbaF0uX2RhdGFzZXRzKTtcbiAgfSxcbiAgLy8gRHJhdyBsYWJlbHMgb24gdG9wIG9mIGFsbCBkYXRhc2V0IGVsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzI5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzMyXG4gIGFmdGVyRGF0YXNldHNEcmF3OiBmdW5jdGlvbihlKSB7XG4gICAgdy5kcmF3KGUsIGVbaF0uX2xhYmVscyk7XG4gIH0sXG4gIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgaWYgKGVbaF0uX2xpc3RlbmVkKSB7XG4gICAgICB2YXIgciA9IHQuZXZlbnQ7XG4gICAgICBzd2l0Y2ggKHIudHlwZSkge1xuICAgICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICAgIHdlKGUsIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgICAgICBnZShlLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IGVbaF0sIHIgPSB0Ll9hY3RpdmVzLCBhID0gdC5fYWN0aXZlcyA9IGUuZ2V0QWN0aXZlRWxlbWVudHMoKSwgaSA9IG0uYXJyYXlEaWZmKHIsIGEpLCBuLCBvLCBzLCBsLCB1LCB2LCBkO1xuICAgIGZvciAobiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICAgIGlmICh1ID0gaVtuXSwgdVsxXSlcbiAgICAgICAgZm9yIChkID0gdVswXS5lbGVtZW50W2hdIHx8IFtdLCBzID0gMCwgbCA9IGQubGVuZ3RoOyBzIDwgbDsgKytzKVxuICAgICAgICAgIHYgPSBkW3NdLCB2LiRjb250ZXh0LmFjdGl2ZSA9IHVbMV0gPT09IDEsIHYudXBkYXRlKHYuJGNvbnRleHQpO1xuICAgICh0Ll9kaXJ0eSB8fCBpLmxlbmd0aCkgJiYgKHcudXBkYXRlKHQuX2xhYmVscyksIGUucmVuZGVyKCkpLCBkZWxldGUgdC5fZGlydHk7XG4gIH1cbn07XG5leHBvcnQge1xuICBNZSBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==