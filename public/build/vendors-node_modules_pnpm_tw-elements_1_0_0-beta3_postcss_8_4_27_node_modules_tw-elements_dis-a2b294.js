"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_pnpm_tw-elements_1_0_0-beta3_postcss_8_4_27_node_modules_tw-elements_dis-a2b294"],{

/***/ "./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: () => (/* binding */ Hl),
/* harmony export */   Animate: () => (/* binding */ Jl),
/* harmony export */   Button: () => (/* binding */ dl),
/* harmony export */   Carousel: () => (/* binding */ Ut),
/* harmony export */   Chart: () => (/* binding */ vc),
/* harmony export */   Chip: () => (/* binding */ hi),
/* harmony export */   ChipsInput: () => (/* binding */ K0),
/* harmony export */   Collapse: () => (/* binding */ qt),
/* harmony export */   Datatable: () => (/* binding */ wc),
/* harmony export */   Datepicker: () => (/* binding */ F0),
/* harmony export */   Dropdown: () => (/* binding */ It),
/* harmony export */   Input: () => (/* binding */ W),
/* harmony export */   Lightbox: () => (/* binding */ Ls),
/* harmony export */   Modal: () => (/* binding */ Fl),
/* harmony export */   Offcanvas: () => (/* binding */ no),
/* harmony export */   PerfectScrollbar: () => (/* binding */ yc),
/* harmony export */   Popconfirm: () => (/* binding */ kc),
/* harmony export */   Popover: () => (/* binding */ Yl),
/* harmony export */   Rating: () => (/* binding */ z0),
/* harmony export */   Ripple: () => (/* binding */ Ue),
/* harmony export */   ScrollSpy: () => (/* binding */ zl),
/* harmony export */   Select: () => (/* binding */ $o),
/* harmony export */   Sidenav: () => (/* binding */ pi),
/* harmony export */   Stepper: () => (/* binding */ j0),
/* harmony export */   Tab: () => (/* binding */ Ul),
/* harmony export */   Timepicker: () => (/* binding */ Y0),
/* harmony export */   Toast: () => (/* binding */ Xl),
/* harmony export */   Tooltip: () => (/* binding */ Qe),
/* harmony export */   initTE: () => (/* binding */ U0)
/* harmony export */ });
/*!
* Tailwind Elements 1.0.0-beta3
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright Â© 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
var Nc = Object.defineProperty;
var Rc = (s, t, e) => t in s ? Nc(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var At = (s, t, e) => (Rc(s, typeof t != "symbol" ? t + "" : t, e), e);
const Zs = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), I = {
  setData(s, t, e) {
    Zs.set(s, t, e);
  },
  getData(s, t) {
    return Zs.get(s, t);
  },
  removeData(s, t) {
    Zs.delete(s, t);
  }
}, Pc = 1e6, Bc = 1e3, Qn = "transitionend", Hc = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), bt = (s) => {
  do
    s += Math.floor(Math.random() * Pc);
  while (document.getElementById(s));
  return s;
}, Qa = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, fo = (s) => {
  const t = Qa(s);
  return t && document.querySelector(t) ? t : null;
}, Qt = (s) => {
  const t = Qa(s);
  return t ? document.querySelector(t) : null;
}, Wc = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Bc);
}, Ja = (s) => {
  s.dispatchEvent(new Event(Qn));
}, Ve = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), Jt = (s) => Ve(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, L = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Ve(o) ? "element" : Hc(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Lt = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, me = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", tl = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? tl(s.parentNode) : null;
}, Ms = () => function() {
}, Ge = (s) => {
  s.offsetHeight;
}, el = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Qs = [], il = (s) => {
  document.readyState === "loading" ? (Qs.length || document.addEventListener("DOMContentLoaded", () => {
    Qs.forEach((t) => t());
  }), Qs.push(s)) : s();
}, F = () => document.documentElement.dir === "rtl", Vc = (s) => Array.from(s), D = (s) => document.createElement(s), fe = (s) => {
  typeof s == "function" && s();
}, sl = (s, t, e = !0) => {
  if (!e) {
    fe(s);
    return;
  }
  const i = 5, n = Wc(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Qn, r), fe(s));
  };
  t.addEventListener(Qn, r), setTimeout(() => {
    o || Ja(t);
  }, n);
}, nl = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, Fc = /[^.]*(?=\..*)\.|.*/, Yc = /\..*/, jc = /::\d+$/, Js = {};
let Yo = 1;
const Kc = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, zc = /^(mouseenter|mouseleave)/i, ol = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function rl(s, t) {
  return t && `${t}::${Yo++}` || s.uidEvent || Yo++;
}
function al(s) {
  const t = rl(s);
  return s.uidEvent = t, Js[t] = Js[t] || {}, Js[t];
}
function Uc(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && h.off(s, i.type, t), t.apply(s, [i]);
  };
}
function Xc(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && h.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function ll(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function cl(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = hl(s);
  return ol.has(o) || (o = s), [i, n, o];
}
function jo(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), zc.test(t)) {
    const m = (g) => function(v) {
      if (!v.relatedTarget || v.relatedTarget !== v.delegateTarget && !v.delegateTarget.contains(v.relatedTarget))
        return g.call(this, v);
    };
    i ? i = m(i) : e = m(e);
  }
  const [o, r, a] = cl(
    t,
    e,
    i
  ), l = al(s), p = l[a] || (l[a] = {}), u = ll(
    p,
    r,
    o ? e : null
  );
  if (u) {
    u.oneOff = u.oneOff && n;
    return;
  }
  const f = rl(
    r,
    t.replace(Fc, "")
  ), _ = o ? Xc(s, e, i) : Uc(s, e);
  _.delegationSelector = o ? e : null, _.originalHandler = r, _.oneOff = n, _.uidEvent = f, p[f] = _, s.addEventListener(a, _, o);
}
function Jn(s, t, e, i, n) {
  const o = ll(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Gc(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      Jn(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function hl(s) {
  return s = s.replace(Yc, ""), Kc[s] || s;
}
const h = {
  on(s, t, e, i) {
    jo(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    jo(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = cl(
      t,
      e,
      i
    ), a = r !== t, l = al(s), p = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Jn(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    p && Object.keys(l).forEach((f) => {
      Gc(
        s,
        l,
        f,
        t.slice(1)
      );
    });
    const u = l[r] || {};
    Object.keys(u).forEach((f) => {
      const _ = f.replace(jc, "");
      if (!a || t.includes(_)) {
        const m = u[f];
        Jn(
          s,
          l,
          r,
          m.originalHandler,
          m.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = el(), n = hl(t), o = t !== n, r = ol.has(n);
    let a, l = !0, p = !0, u = !1, f = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (f = document.createEvent("HTMLEvents"), f.initEvent(n, l, !0)) : f = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((_) => {
      Object.defineProperty(f, _, {
        get() {
          return e[_];
        }
      });
    }), u && f.preventDefault(), p && s.dispatchEvent(f), f.defaultPrevented && typeof a < "u" && a.preventDefault(), f;
  }
}, oe = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.off(s, n[o], e, i);
  }
}, qc = "5.1.3";
class Et {
  constructor(t) {
    t = Jt(t), t && (this._element = t, I.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    I.removeData(this._element, this.constructor.DATA_KEY), h.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    sl(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return I.getData(Jt(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return qc;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const Zc = "button", Qc = "active";
class dl extends Et {
  // Getters
  static get NAME() {
    return Zc;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(Qc)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = dl.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var Q = "top", ht = "bottom", dt = "right", J = "left", Ii = "auto", qe = [Q, ht, dt, J], ve = "start", Fe = "end", ul = "clippingParents", mo = "viewport", Ie = "popper", pl = "reference", to = /* @__PURE__ */ qe.reduce(function(s, t) {
  return s.concat([t + "-" + ve, t + "-" + Fe]);
}, []), go = /* @__PURE__ */ [].concat(qe, [Ii]).reduce(function(s, t) {
  return s.concat([t, t + "-" + ve, t + "-" + Fe]);
}, []), _l = "beforeRead", fl = "read", ml = "afterRead", gl = "beforeMain", bl = "main", vl = "afterMain", Tl = "beforeWrite", El = "write", Cl = "afterWrite", Ns = [_l, fl, ml, gl, bl, vl, Tl, El, Cl];
function Nt(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function ut(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function Te(s) {
  var t = ut(s).Element;
  return s instanceof t || s instanceof Element;
}
function ct(s) {
  var t = ut(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function bo(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ut(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function Jc(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !ct(o) || !Nt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function th(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {
        return l[p] = "", l;
      }, {});
      !ct(n) || !Nt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const vo = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Jc,
  effect: th,
  requires: ["computeStyles"]
};
function vt(s) {
  return s.split("-")[0];
}
var ge = Math.max, Rs = Math.min, Ye = Math.round;
function eo() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Al() {
  return !/^((?!chrome|android).)*safari/i.test(eo());
}
function je(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && ct(s) && (n = s.offsetWidth > 0 && Ye(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && Ye(i.height) / s.offsetHeight || 1);
  var r = Te(s) ? ut(s) : window, a = r.visualViewport, l = !Al() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, f = i.width / n, _ = i.height / o;
  return {
    width: f,
    height: _,
    top: u,
    right: p + f,
    bottom: u + _,
    left: p,
    x: p,
    y: u
  };
}
function To(s) {
  var t = je(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function yl(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && bo(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Tt(s) {
  return ut(s).getComputedStyle(s);
}
function eh(s) {
  return ["table", "td", "th"].indexOf(Nt(s)) >= 0;
}
function te(s) {
  return ((Te(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function Hs(s) {
  return Nt(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (bo(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    te(s)
  );
}
function Ko(s) {
  return !ct(s) || // https://github.com/popperjs/popper-core/issues/837
  Tt(s).position === "fixed" ? null : s.offsetParent;
}
function ih(s) {
  var t = /firefox/i.test(eo()), e = /Trident/i.test(eo());
  if (e && ct(s)) {
    var i = Tt(s);
    if (i.position === "fixed")
      return null;
  }
  var n = Hs(s);
  for (bo(n) && (n = n.host); ct(n) && ["html", "body"].indexOf(Nt(n)) < 0; ) {
    var o = Tt(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Di(s) {
  for (var t = ut(s), e = Ko(s); e && eh(e) && Tt(e).position === "static"; )
    e = Ko(e);
  return e && (Nt(e) === "html" || Nt(e) === "body" && Tt(e).position === "static") ? t : e || ih(s) || t;
}
function Eo(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function Ei(s, t, e) {
  return ge(s, Rs(t, e));
}
function sh(s, t, e) {
  var i = Ei(s, t, e);
  return i > e ? e : i;
}
function wl() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function xl(s) {
  return Object.assign({}, wl(), s);
}
function kl(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var nh = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, xl(typeof t != "number" ? t : kl(t, qe));
};
function oh(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = vt(e.placement), l = Eo(a), p = [J, dt].indexOf(a) >= 0, u = p ? "height" : "width";
  if (!(!o || !r)) {
    var f = nh(n.padding, e), _ = To(o), m = l === "y" ? Q : J, g = l === "y" ? ht : dt, v = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], b = r[l] - e.rects.reference[l], C = Di(o), y = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = v / 2 - b / 2, T = f[m], A = y - _[u] - f[g], w = y / 2 - _[u] / 2 + E, S = Ei(T, w, A), k = l;
    e.modifiersData[i] = (t = {}, t[k] = S, t.centerOffset = S - w, t);
  }
}
function rh(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (ct(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !yl(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Ol = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: oh,
  effect: rh,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ke(s) {
  return s.split("-")[1];
}
var ah = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function lh(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: Ye(e * n) / n || 0,
    y: Ye(i * n) / n || 0
  };
}
function zo(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, f = s.isFixed, _ = r.x, m = _ === void 0 ? 0 : _, g = r.y, v = g === void 0 ? 0 : g, b = typeof u == "function" ? u({
    x: m,
    y: v
  }) : {
    x: m,
    y: v
  };
  m = b.x, v = b.y;
  var C = r.hasOwnProperty("x"), y = r.hasOwnProperty("y"), E = J, T = Q, A = window;
  if (p) {
    var w = Di(e), S = "clientHeight", k = "clientWidth";
    if (w === ut(e) && (w = te(e), Tt(w).position !== "static" && a === "absolute" && (S = "scrollHeight", k = "scrollWidth")), w = w, n === Q || (n === J || n === dt) && o === Fe) {
      T = ht;
      var x = f && w === A && A.visualViewport ? A.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      v -= x - i.height, v *= l ? 1 : -1;
    }
    if (n === J || (n === Q || n === ht) && o === Fe) {
      E = dt;
      var $ = f && w === A && A.visualViewport ? A.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[k]
      );
      m -= $ - i.width, m *= l ? 1 : -1;
    }
  }
  var O = Object.assign({
    position: a
  }, p && ah), M = u === !0 ? lh({
    x: m,
    y: v
  }, ut(e)) : {
    x: m,
    y: v
  };
  if (m = M.x, v = M.y, l) {
    var P;
    return Object.assign({}, O, (P = {}, P[T] = y ? "0" : "", P[E] = C ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + v + "px)" : "translate3d(" + m + "px, " + v + "px, 0)", P));
  }
  return Object.assign({}, O, (t = {}, t[T] = y ? v + "px" : "", t[E] = C ? m + "px" : "", t.transform = "", t));
}
function ch(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var p = Tt(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(f) {
      return p.indexOf(f) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var u = {
    placement: vt(t.placement),
    variation: Ke(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, zo(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, zo(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Co = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: ch,
  data: {}
};
var ji = {
  passive: !0
};
function hh(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = ut(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && p.forEach(function(u) {
    u.addEventListener("scroll", e.update, ji);
  }), a && l.addEventListener("resize", e.update, ji), function() {
    o && p.forEach(function(u) {
      u.removeEventListener("scroll", e.update, ji);
    }), a && l.removeEventListener("resize", e.update, ji);
  };
}
const Ao = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: hh,
  data: {}
};
var dh = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function bs(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return dh[t];
  });
}
var uh = {
  start: "end",
  end: "start"
};
function Uo(s) {
  return s.replace(/start|end/g, function(t) {
    return uh[t];
  });
}
function yo(s) {
  var t = ut(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function wo(s) {
  return je(te(s)).left + yo(s).scrollLeft;
}
function ph(s, t) {
  var e = ut(s), i = te(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var p = Al();
    (p || !p && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + wo(s),
    y: l
  };
}
function _h(s) {
  var t, e = te(s), i = yo(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = ge(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = ge(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + wo(s), l = -i.scrollTop;
  return Tt(n || e).direction === "rtl" && (a += ge(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function xo(s) {
  var t = Tt(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function Sl(s) {
  return ["html", "body", "#document"].indexOf(Nt(s)) >= 0 ? s.ownerDocument.body : ct(s) && xo(s) ? s : Sl(Hs(s));
}
function Ci(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = Sl(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = ut(i), r = n ? [o].concat(o.visualViewport || [], xo(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ci(Hs(r)))
  );
}
function io(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function fh(s, t) {
  var e = je(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Xo(s, t, e) {
  return t === mo ? io(ph(s, e)) : Te(t) ? fh(t, e) : io(_h(te(s)));
}
function mh(s) {
  var t = Ci(Hs(s)), e = ["absolute", "fixed"].indexOf(Tt(s).position) >= 0, i = e && ct(s) ? Di(s) : s;
  return Te(i) ? t.filter(function(n) {
    return Te(n) && yl(n, i) && Nt(n) !== "body";
  }) : [];
}
function gh(s, t, e, i) {
  var n = t === "clippingParents" ? mh(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
    var u = Xo(s, p, i);
    return l.top = ge(u.top, l.top), l.right = Rs(u.right, l.right), l.bottom = Rs(u.bottom, l.bottom), l.left = ge(u.left, l.left), l;
  }, Xo(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Il(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? vt(i) : null, o = i ? Ke(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case Q:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case ht:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case dt:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case J:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var p = n ? Eo(n) : null;
  if (p != null) {
    var u = p === "y" ? "height" : "width";
    switch (o) {
      case ve:
        l[p] = l[p] - (t[u] / 2 - e[u] / 2);
        break;
      case Fe:
        l[p] = l[p] + (t[u] / 2 - e[u] / 2);
        break;
    }
  }
  return l;
}
function ze(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ul : a, p = e.rootBoundary, u = p === void 0 ? mo : p, f = e.elementContext, _ = f === void 0 ? Ie : f, m = e.altBoundary, g = m === void 0 ? !1 : m, v = e.padding, b = v === void 0 ? 0 : v, C = xl(typeof b != "number" ? b : kl(b, qe)), y = _ === Ie ? pl : Ie, E = s.rects.popper, T = s.elements[g ? y : _], A = gh(Te(T) ? T : T.contextElement || te(s.elements.popper), l, u, r), w = je(s.elements.reference), S = Il({
    reference: w,
    element: E,
    strategy: "absolute",
    placement: n
  }), k = io(Object.assign({}, E, S)), x = _ === Ie ? k : w, $ = {
    top: A.top - x.top + C.top,
    bottom: x.bottom - A.bottom + C.bottom,
    left: A.left - x.left + C.left,
    right: x.right - A.right + C.right
  }, O = s.modifiersData.offset;
  if (_ === Ie && O) {
    var M = O[n];
    Object.keys($).forEach(function(P) {
      var tt = [dt, ht].indexOf(P) >= 0 ? 1 : -1, et = [Q, ht].indexOf(P) >= 0 ? "y" : "x";
      $[P] += M[et] * tt;
    });
  }
  return $;
}
function bh(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? go : l, u = Ke(i), f = u ? a ? to : to.filter(function(g) {
    return Ke(g) === u;
  }) : qe, _ = f.filter(function(g) {
    return p.indexOf(g) >= 0;
  });
  _.length === 0 && (_ = f, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var m = _.reduce(function(g, v) {
    return g[v] = ze(s, {
      placement: v,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[vt(v)], g;
  }, {});
  return Object.keys(m).sort(function(g, v) {
    return m[g] - m[v];
  });
}
function vh(s) {
  if (vt(s) === Ii)
    return [];
  var t = bs(s);
  return [Uo(s), t, Uo(t)];
}
function Th(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, f = e.rootBoundary, _ = e.altBoundary, m = e.flipVariations, g = m === void 0 ? !0 : m, v = e.allowedAutoPlacements, b = t.options.placement, C = vt(b), y = C === b, E = l || (y || !g ? [bs(b)] : vh(b)), T = [b].concat(E).reduce(function(Ae, Ht) {
      return Ae.concat(vt(Ht) === Ii ? bh(t, {
        placement: Ht,
        boundary: u,
        rootBoundary: f,
        padding: p,
        flipVariations: g,
        allowedAutoPlacements: v
      }) : Ht);
    }, []), A = t.rects.reference, w = t.rects.popper, S = /* @__PURE__ */ new Map(), k = !0, x = T[0], $ = 0; $ < T.length; $++) {
      var O = T[$], M = vt(O), P = Ke(O) === ve, tt = [Q, ht].indexOf(M) >= 0, et = tt ? "width" : "height", U = ze(t, {
        placement: O,
        boundary: u,
        rootBoundary: f,
        altBoundary: _,
        padding: p
      }), mt = tt ? P ? dt : J : P ? ht : Q;
      A[et] > w[et] && (mt = bs(mt));
      var Hi = bs(mt), ie = [];
      if (o && ie.push(U[M] <= 0), a && ie.push(U[mt] <= 0, U[Hi] <= 0), ie.every(function(Ae) {
        return Ae;
      })) {
        x = O, k = !1;
        break;
      }
      S.set(O, ie);
    }
    if (k)
      for (var Wi = g ? 3 : 1, Us = function(Ht) {
        var ii = T.find(function(Fi) {
          var se = S.get(Fi);
          if (se)
            return se.slice(0, Ht).every(function(Xs) {
              return Xs;
            });
        });
        if (ii)
          return x = ii, "break";
      }, ei = Wi; ei > 0; ei--) {
        var Vi = Us(ei);
        if (Vi === "break")
          break;
      }
    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);
  }
}
const Dl = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Th,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Go(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function qo(s) {
  return [Q, dt, ht, J].some(function(t) {
    return s[t] >= 0;
  });
}
function Eh(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = ze(t, {
    elementContext: "reference"
  }), a = ze(t, {
    altBoundary: !0
  }), l = Go(r, i), p = Go(a, n, o), u = qo(l), f = qo(p);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: p,
    isReferenceHidden: u,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": f
  });
}
const $l = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Eh
};
function Ch(s, t, e) {
  var i = vt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [J, dt].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Ah(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = go.reduce(function(u, f) {
    return u[f] = Ch(f, t.rects, o), u;
  }, {}), a = r[t.placement], l = a.x, p = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;
}
const Ll = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Ah
};
function yh(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Il({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const ko = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: yh,
  data: {}
};
function wh(s) {
  return s === "x" ? "y" : "x";
}
function xh(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, f = e.padding, _ = e.tether, m = _ === void 0 ? !0 : _, g = e.tetherOffset, v = g === void 0 ? 0 : g, b = ze(t, {
    boundary: l,
    rootBoundary: p,
    padding: f,
    altBoundary: u
  }), C = vt(t.placement), y = Ke(t.placement), E = !y, T = Eo(C), A = wh(T), w = t.modifiersData.popperOffsets, S = t.rects.reference, k = t.rects.popper, x = typeof v == "function" ? v(Object.assign({}, t.rects, {
    placement: t.placement
  })) : v, $ = typeof x == "number" ? {
    mainAxis: x,
    altAxis: x
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, x), O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, M = {
    x: 0,
    y: 0
  };
  if (w) {
    if (o) {
      var P, tt = T === "y" ? Q : J, et = T === "y" ? ht : dt, U = T === "y" ? "height" : "width", mt = w[T], Hi = mt + b[tt], ie = mt - b[et], Wi = m ? -k[U] / 2 : 0, Us = y === ve ? S[U] : k[U], ei = y === ve ? -k[U] : -S[U], Vi = t.elements.arrow, Ae = m && Vi ? To(Vi) : {
        width: 0,
        height: 0
      }, Ht = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : wl(), ii = Ht[tt], Fi = Ht[et], se = Ei(0, S[U], Ae[U]), Xs = E ? S[U] / 2 - Wi - se - ii - $.mainAxis : Us - se - ii - $.mainAxis, Sc = E ? -S[U] / 2 + Wi + se + Fi + $.mainAxis : ei + se + Fi + $.mainAxis, Gs = t.elements.arrow && Di(t.elements.arrow), Ic = Gs ? T === "y" ? Gs.clientTop || 0 : Gs.clientLeft || 0 : 0, Mo = (P = O == null ? void 0 : O[T]) != null ? P : 0, Dc = mt + Xs - Mo - Ic, $c = mt + Sc - Mo, No = Ei(m ? Rs(Hi, Dc) : Hi, mt, m ? ge(ie, $c) : ie);
      w[T] = No, M[T] = No - mt;
    }
    if (a) {
      var Ro, Lc = T === "x" ? Q : J, Mc = T === "x" ? ht : dt, ne = w[A], Yi = A === "y" ? "height" : "width", Po = ne + b[Lc], Bo = ne - b[Mc], qs = [Q, J].indexOf(C) !== -1, Ho = (Ro = O == null ? void 0 : O[A]) != null ? Ro : 0, Wo = qs ? Po : ne - S[Yi] - k[Yi] - Ho + $.altAxis, Vo = qs ? ne + S[Yi] + k[Yi] - Ho - $.altAxis : Bo, Fo = m && qs ? sh(Wo, ne, Vo) : Ei(m ? Wo : Po, ne, m ? Vo : Bo);
      w[A] = Fo, M[A] = Fo - ne;
    }
    t.modifiersData[i] = M;
  }
}
const Ml = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: xh,
  requiresIfExists: ["offset"]
};
function kh(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function Oh(s) {
  return s === ut(s) || !ct(s) ? yo(s) : kh(s);
}
function Sh(s) {
  var t = s.getBoundingClientRect(), e = Ye(t.width) / s.offsetWidth || 1, i = Ye(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function Ih(s, t, e) {
  e === void 0 && (e = !1);
  var i = ct(t), n = ct(t) && Sh(t), o = te(t), r = je(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Nt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  xo(o)) && (a = Oh(t)), ct(t) ? (l = je(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = wo(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function Dh(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function $h(s) {
  var t = Dh(s);
  return Ns.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function Lh(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Wt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var re = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', Mh = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', Zo = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function Nh(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), Zo).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Wt(re, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Wt(re, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          Ns.indexOf(t.phase) < 0 && console.error(Wt(re, t.name, '"phase"', "either " + Ns.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Wt(re, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Wt(re, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Wt(re, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Wt(re, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Zo.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Wt(Mh, String(t.name), i, i));
      });
    });
  });
}
function Rh(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function Ph(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var Qo = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Bh = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Jo = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function tr() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function Ws(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Jo : n;
  return function(a, l, p) {
    p === void 0 && (p = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Jo, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], _ = !1, m = {
      state: u,
      setOptions: function(C) {
        var y = typeof C == "function" ? C(u.options) : C;
        v(), u.options = Object.assign({}, o, u.options, y), u.scrollParents = {
          reference: Te(a) ? Ci(a) : a.contextElement ? Ci(a.contextElement) : [],
          popper: Ci(l)
        };
        var E = $h(Ph([].concat(i, u.options.modifiers)));
        if (u.orderedModifiers = E.filter(function(O) {
          return O.enabled;
        }), {}.NODE_ENV !== "production") {
          var T = Rh([].concat(E, u.options.modifiers), function(O) {
            var M = O.name;
            return M;
          });
          if (Nh(T), vt(u.options.placement) === Ii) {
            var A = u.orderedModifiers.find(function(O) {
              var M = O.name;
              return M === "flip";
            });
            A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var w = Tt(l), S = w.marginTop, k = w.marginRight, x = w.marginBottom, $ = w.marginLeft;
          [S, k, x, $].some(function(O) {
            return parseFloat(O);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return g(), m.update();
      },
      // Sync update â it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!_) {
          var C = u.elements, y = C.reference, E = C.popper;
          if (!tr(y, E)) {
            ({}).NODE_ENV !== "production" && console.error(Qo);
            return;
          }
          u.rects = {
            reference: Ih(y, Di(E), u.options.strategy === "fixed"),
            popper: To(E)
          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(O) {
            return u.modifiersData[O.name] = Object.assign({}, O.data);
          });
          for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {
            if ({}.NODE_ENV !== "production" && (T += 1, T > 100)) {
              console.error(Bh);
              break;
            }
            if (u.reset === !0) {
              u.reset = !1, A = -1;
              continue;
            }
            var w = u.orderedModifiers[A], S = w.fn, k = w.options, x = k === void 0 ? {} : k, $ = w.name;
            typeof S == "function" && (u = S({
              state: u,
              options: x,
              name: $,
              instance: m
            }) || u);
          }
        }
      },
      // Async and optimistically optimized update â it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Lh(function() {
        return new Promise(function(b) {
          m.forceUpdate(), b(u);
        });
      }),
      destroy: function() {
        v(), _ = !0;
      }
    };
    if (!tr(a, l))
      return {}.NODE_ENV !== "production" && console.error(Qo), m;
    m.setOptions(p).then(function(b) {
      !_ && p.onFirstUpdate && p.onFirstUpdate(b);
    });
    function g() {
      u.orderedModifiers.forEach(function(b) {
        var C = b.name, y = b.options, E = y === void 0 ? {} : y, T = b.effect;
        if (typeof T == "function") {
          var A = T({
            state: u,
            name: C,
            instance: m,
            options: E
          }), w = function() {
          };
          f.push(A || w);
        }
      });
    }
    function v() {
      f.forEach(function(b) {
        return b();
      }), f = [];
    }
    return m;
  };
}
var Hh = /* @__PURE__ */ Ws(), Wh = [Ao, ko, Co, vo], Vh = /* @__PURE__ */ Ws({
  defaultModifiers: Wh
}), Fh = [Ao, ko, Co, vo, Ll, Dl, Ml, Ol, $l], Ee = /* @__PURE__ */ Ws({
  defaultModifiers: Fh
});
const Nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: vl,
  afterRead: ml,
  afterWrite: Cl,
  applyStyles: vo,
  arrow: Ol,
  auto: Ii,
  basePlacements: qe,
  beforeMain: gl,
  beforeRead: _l,
  beforeWrite: Tl,
  bottom: ht,
  clippingParents: ul,
  computeStyles: Co,
  createPopper: Ee,
  createPopperBase: Hh,
  createPopperLite: Vh,
  detectOverflow: ze,
  end: Fe,
  eventListeners: Ao,
  flip: Dl,
  hide: $l,
  left: J,
  main: bl,
  modifierPhases: Ns,
  offset: Ll,
  placements: go,
  popper: Ie,
  popperGenerator: Ws,
  popperOffsets: ko,
  preventOverflow: Ml,
  read: fl,
  reference: pl,
  right: dt,
  start: ve,
  top: Q,
  variationPlacements: to,
  viewport: mo,
  write: El
}, Symbol.toStringTag, { value: "Module" }));
function tn(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function en(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const c = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${en(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${en(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = tn(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = tn(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return tn(
      s.getAttribute(`data-te-${en(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && sn(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    sn(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    sn(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  },
  maxOffset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + Math.max(
        document.body.scrollTop,
        document.documentElement.scrollTop,
        window.scrollY
      ),
      left: t.left + Math.max(
        document.body.scrollLeft,
        document.documentElement.scrollLeft,
        window.scrollX
      )
    };
  }
};
function sn(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const Yh = 3, d = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Yh; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !me(e) && Lt(e)
    );
  }
}, nn = "dropdown", jh = "te.dropdown", Ce = `.${jh}`, Oo = ".data-api", vs = "Escape", er = "Space", ir = "Tab", so = "ArrowUp", Ts = "ArrowDown", Kh = 2, zh = new RegExp(
  `${so}|${Ts}|${vs}`
), Uh = `hide${Ce}`, Xh = `hidden${Ce}`, Gh = `show${Ce}`, qh = `shown${Ce}`, Zh = `click${Ce}${Oo}`, sr = `keydown${Ce}${Oo}`, Qh = `keyup${Ce}${Oo}`, Vt = "show", Jh = "dropup", td = "dropend", ed = "dropstart", id = "[data-te-navbar-ref]", Ki = "[data-te-dropdown-toggle-ref]", on = "[data-te-dropdown-menu-ref]", sd = "[data-te-navbar-nav-ref]", nd = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", od = F() ? "top-end" : "top-start", rd = F() ? "top-start" : "top-end", ad = F() ? "bottom-end" : "bottom-start", ld = F() ? "bottom-start" : "bottom-end", cd = F() ? "left-start" : "right-start", hd = F() ? "right-start" : "left-start", dd = [{ opacity: "0" }, { opacity: "1" }], ud = [{ opacity: "1" }, { opacity: "0" }], zi = {
  duration: 550,
  iterations: 1,
  easing: "ease",
  fill: "both"
}, pd = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on"
}, _d = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string"
};
class It extends Et {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return pd;
  }
  static get DefaultType() {
    return _d;
  }
  static get NAME() {
    return nn;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (me(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (h.trigger(
      this._element,
      Gh,
      t
    ).defaultPrevented)
      return;
    const i = It.getParentFromElement(this._element);
    this._inNavbar ? c.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(sd) && [].concat(...document.body.children).forEach((n) => h.on(n, "mouseover", Ms)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Vt}`, ""), this._animationCanPlay && this._menu.animate(dd, zi), this._element.setAttribute(`data-te-dropdown-${Vt}`, ""), setTimeout(
      () => {
        h.trigger(this._element, qh, t);
      },
      this._animationCanPlay ? zi.duration : 0
    );
  }
  hide() {
    if (me(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      sr,
      Ki,
      It.dataApiKeydownHandler
    ), h.on(
      document,
      sr,
      on,
      It.dataApiKeydownHandler
    ), h.on(document, Zh, It.clearMenus), h.on(document, Qh, It.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || h.trigger(
      this._element,
      Uh,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => h.off(i, "mouseover", Ms)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(
      ud,
      zi
    )), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Vt}`), this._element.removeAttribute(`data-te-dropdown-${Vt}`), this._element.setAttribute("aria-expanded", "false"), c.removeDataAttribute(this._menu, "popper"), h.trigger(this._element, Xh, t);
      },
      this._animationCanPlay ? zi.duration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...c.getDataAttributes(this._element),
      ...t
    }, L(nn, t, this.constructor.DefaultType), typeof t.reference == "object" && !Ve(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${nn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof Nl > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Ve(this._config.reference) ? e = Jt(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = Ee(
      e,
      this._menu,
      i
    ), n && c.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Vt.charAt(0).toUpperCase() + Vt.slice(1)}`] === "";
  }
  _getMenuElement() {
    return d.next(this._element, on)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === td)
      return cd;
    if (t.dataset.teDropdownPosition === ed)
      return hd;
    const e = getComputedStyle(this._menu).getPropertyValue("--te-position").trim() === "end";
    return t.dataset.teDropdownPosition === Jh ? e ? rd : od : e ? ld : ad;
  }
  _detectNavbar() {
    return this._element.closest(id) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = d.find(
      nd,
      this._menu
    ).filter(Lt);
    i.length && nl(
      i,
      e,
      t === Ts,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = It.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === Kh || t.type === "keyup" && t.key !== ir))
      return;
    const e = d.find(Ki);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = It.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === ir || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return Qt(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === er || t.key !== vs && (t.key !== Ts && t.key !== so || t.target.closest(on)) : !zh.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Vt.charAt(0).toUpperCase() + Vt.slice(1)}`] === "";
    if (!e && t.key === vs || (t.preventDefault(), t.stopPropagation(), me(this)))
      return;
    const i = this.matches(Ki) ? this : d.prev(this, Ki)[0], n = It.getOrCreateInstance(i);
    if (t.key === vs) {
      n.hide();
      return;
    }
    if (t.key === so || t.key === Ts) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === er) && It.clearMenus();
  }
}
const rn = "collapse", Rl = "te.collapse", Vs = `.${Rl}`, nr = {
  toggle: !0,
  parent: null
}, fd = {
  toggle: "boolean",
  parent: "(null|element)"
}, md = `show${Vs}`, gd = `shown${Vs}`, bd = `hide${Vs}`, vd = `hidden${Vs}`, an = "data-te-collapse-show", or = "data-te-collapse-collapsed", Ui = "data-te-collapse-collapsing", Td = "data-te-collapse-horizontal", Le = "data-te-collapse-item", rr = `:scope [${Le}] [${Le}]`, Ed = "width", Cd = "height", Ad = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", ar = "[data-te-collapse-init]", yd = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, wd = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class qt extends Et {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = d.find(ar);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = fo(a), p = d.find(l).filter(
        (u) => u === this._element
      );
      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return nr;
  }
  static get NAME() {
    return rn;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const u = d.find(
        rr,
        this._config.parent
      );
      t = d.find(
        Ad,
        this._config.parent
      ).filter((f) => !u.includes(f));
    }
    const i = d.findOne(this._selector);
    if (t.length) {
      const u = t.find((f) => i !== f);
      if (e = u ? qt.getInstance(u) : null, e && e._isTransitioning)
        return;
    }
    if (h.trigger(this._element, md).defaultPrevented)
      return;
    t.forEach((u) => {
      i !== u && qt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || I.setData(u, Rl, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    c.removeClass(this._element, this._classes.visible), c.removeClass(this._element, this._classes.hidden), c.addClass(this._element, r), this._element.removeAttribute(Le), this._element.setAttribute(Ui, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, c.removeClass(this._element, this._classes.hidden), c.removeClass(this._element, r), c.addClass(this._element, this._classes.visible), this._element.removeAttribute(Ui), this._element.setAttribute(Le, ""), this._element.setAttribute(an, ""), this._element.style[o] = "", h.trigger(this._element, gd);
    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || h.trigger(this._element, bd).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Ge(this._element), c.addClass(this._element, i), c.removeClass(this._element, this._classes.visible), c.removeClass(this._element, this._classes.hidden), this._element.setAttribute(Ui, ""), this._element.removeAttribute(Le), this._element.removeAttribute(an);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = Qt(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, c.removeClass(this._element, i), c.addClass(this._element, this._classes.visible), c.addClass(this._element, this._classes.hidden), this._element.removeAttribute(Ui), this._element.setAttribute(Le, ""), h.trigger(this._element, vd);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(an);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...nr,
      ...c.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = Jt(t.parent), L(rn, t, fd), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...yd,
      ...e,
      ...t
    }, L(rn, t, wd), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Td) ? Ed : Cd;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = d.find(
      rr,
      this._config.parent
    );
    d.find(ar, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = Qt(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(or) : i.setAttribute(`${or}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = qt.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const lr = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", cr = ".sticky-top";
class ki {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      lr,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      cr,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(lr, "paddingRight"), this._resetElementAttributes(cr, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && c.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = c.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (c.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Ve(t) ? e(t) : d.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const xd = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, kd = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|null)"
}, Pl = "backdrop", hr = `mousedown.te.${Pl}`;
class So {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      fe(t);
      return;
    }
    this._append(), this._config.isAnimated && Ge(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    c.removeClass(this._getElement(), "opacity-0"), c.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      fe(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      fe(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), fe(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...xd,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = Jt(t.rootElement), L(Pl, t, kd), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), h.on(this._getElement(), hr, () => {
      fe(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (h.off(this._element, hr), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    sl(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class $i {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Lt(e))
        return !1;
      const i = d.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const dr = "offcanvas", Od = "te.offcanvas", Ze = `.${Od}`, Sd = ".data-api", Id = `load${Ze}${Sd}`, Dd = "Escape", ur = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, $d = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, pr = "show", Ld = "[data-te-offcanvas-init][data-te-offcanvas-show]", Md = `show${Ze}`, Nd = `shown${Ze}`, Rd = `hide${Ze}`, Pd = `hidden${Ze}`, Bd = `keydown.dismiss${Ze}`;
class no extends Et {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return dr;
  }
  static get Default() {
    return ur;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || h.trigger(this._element, Md, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new ki().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${pr}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), h.trigger(this._element, Nd, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || h.trigger(this._element, Rd).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${pr}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new ki().reset(), h.trigger(this._element, Pd);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (h.on(
      window,
      Id,
      () => d.find(Ld).forEach(
        (t) => no.getOrCreateInstance(t).show()
      )
    ), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ur,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(dr, t, $d), t;
  }
  _initializeBackDrop() {
    return new So({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new $i(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    h.on(this._element, Bd, (t) => {
      this._config.keyboard && t.key === Dd && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = no.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ln = "alert", Hd = "te.alert", Bl = `.${Hd}`, Wd = `close${Bl}`, Vd = `closed${Bl}`, si = "data-te-alert-show", Fd = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, _r = {
  animation: !0,
  autohide: !0,
  delay: 1e3
}, Yd = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, jd = {
  fadeIn: "string",
  fadeOut: "string"
};
class Hl extends Et {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get DefaultType() {
    return Fd;
  }
  static get Default() {
    return _r;
  }
  static get NAME() {
    return ln;
  }
  // Public
  close() {
    if (h.trigger(this._element, Wd).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, c.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(si), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(si) && (c.removeClass(this._element, "hidden"), c.addClass(this._element, "block"), Lt(this._element))) {
        const t = (e) => {
          c.removeClass(this._element, "hidden"), c.addClass(this._element, "block"), h.off(e.target, "animationend", t);
        };
        this._element.setAttribute(si, ""), h.on(this._element, "animationend", t);
      }
      this._config.animation && (c.removeClass(this._element, this._classes.fadeOut), c.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(si)) {
      this._element.removeAttribute(si);
      const t = (e) => {
        c.addClass(this._element, "hidden"), c.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), h.off(e.target, "animationend", t);
      };
      h.on(this._element, "animationend", t), c.removeClass(this._element, this._classes.fadeIn), c.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _getConfig(t) {
    return t = {
      ..._r,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, L(ln, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Yd,
      ...e,
      ...t
    }, L(ln, t, jd), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), h.trigger(this._element, Vd), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Hl.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const cn = "carousel", Kd = "te.carousel", pt = `.${Kd}`, Wl = ".data-api", zd = "ArrowLeft", Ud = "ArrowRight", Xd = 500, Gd = 40, fr = {
  interval: 5e3,
  keyboard: !0,
  ride: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, qd = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  ride: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, Zd = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, Qd = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, ae = "next", le = "prev", pe = "left", ui = "right", Jd = {
  [zd]: ui,
  [Ud]: pe
}, tu = `slide${pt}`, hn = `slid${pt}`, eu = `keydown${pt}`, iu = `mouseenter${pt}`, su = `mouseleave${pt}`, nu = `touchstart${pt}`, ou = `touchmove${pt}`, ru = `touchend${pt}`, au = `pointerdown${pt}`, lu = `pointerup${pt}`, cu = `dragstart${pt}`, hu = `load${pt}${Wl}`, du = `click${pt}${Wl}`, mr = "data-te-carousel-init", ce = "data-te-carousel-active", uu = "data-te-carousel-item-end", dn = "data-te-carousel-item-start", pu = "data-te-carousel-item-next", _u = "data-te-carousel-item-prev", fu = "data-te-carousel-pointer-event", mu = "[data-te-carousel-init]", Vl = "[data-te-carousel-active]", Io = "[data-te-carousel-item]", ye = `${Vl}${Io}`, gu = `${Io} img`, bu = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", vu = "[data-te-carousel-indicators]", Tu = "[data-te-target]", Eu = "[data-te-slide], [data-te-slide-to]", Cu = "touch", Au = "pen";
class Ut extends Et {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(
      vu,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === "carousel" && this.cycle();
  }
  // Getters
  static get Default() {
    return fr;
  }
  static get NAME() {
    return cn;
  }
  // Public
  next() {
    this._slide(ae);
  }
  nextWhenVisible() {
    !document.hidden && Lt(this._element) && this.next();
  }
  prev() {
    this._slide(le);
  }
  pause(t) {
    t || (this._isPaused = !0), d.findOne(bu, this._element) && (Ja(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = d.findOne(
      ye,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      h.one(this._element, hn, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? ae : le;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      du,
      Eu,
      Ut.dataApiClickHandler
    ), h.on(window, hu, () => {
      const t = d.find(mu);
      for (let e = 0, i = t.length; e < i; e++)
        Ut.carouselInterface(
          t[e],
          Ut.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...fr,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(cn, t, qd), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Zd,
      ...e,
      ...t
    }, L(cn, t, Qd), t;
  }
  _enableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        h.one(this._element, hn, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  _applyInitialClasses() {
    const t = d.findOne(
      ye,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= Gd)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? ui : pe);
  }
  _setActiveElementClass() {
    this._activeElement = d.findOne(
      ye,
      this._element
    ), c.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && h.on(
      this._element,
      eu,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (h.on(
      this._element,
      iu,
      (t) => this.pause(t)
    ), h.on(
      this._element,
      su,
      (t) => this._enableCycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Au || o.pointerType === Cu), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this._enableCycle(r),
        Xd + this._config.interval
      ));
    };
    d.find(gu, this._element).forEach(
      (o) => {
        h.on(
          o,
          cu,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (h.on(
      this._element,
      au,
      (o) => e(o)
    ), h.on(this._element, lu, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${fu}`, "")) : (h.on(this._element, nu, (o) => e(o)), h.on(this._element, ou, (o) => i(o)), h.on(this._element, ru, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = Jd[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? d.find(Io, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === ae;
    return nl(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      d.findOne(ye, this._element)
    );
    return h.trigger(this._element, tu, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = d.findOne(
        Vl,
        this._indicatorsElement
      );
      e.removeAttribute(ce), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = d.find(
        Tu,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${ce}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || d.findOne(ye, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = d.findOne(
      ye,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === ae, u = p ? dn : uu, f = p ? pu : _u, _ = this._orderToDirection(i), m = u === dn ? this._classes.slideLeft : this._classes.slideRight, g = u !== dn ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(ce)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, _).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const b = () => {
      h.trigger(this._element, hn, {
        relatedTarget: r,
        direction: _,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(mr)) {
      r.setAttribute(`${f}`, ""), r.classList.add(this._classes.block, g), Ge(r), n.setAttribute(`${u}`, ""), n.classList.add(
        m,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${u}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const C = () => {
        r.removeAttribute(u), r.removeAttribute(f), r.setAttribute(`${ce}`, ""), n.removeAttribute(ce), n.classList.remove(
          m,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(f), n.removeAttribute(u), this._isSliding = !1, setTimeout(b, 0);
      };
      this._queueCallback(C, n, !0);
    } else
      n.removeAttribute(ce), n.classList.remove(this._classes.block), r.setAttribute(`${ce}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, b();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [ui, pe].includes(t) ? F() ? t === pe ? le : ae : t === pe ? ae : le : t;
  }
  _orderToDirection(t) {
    return [ae, le].includes(t) ? F() ? t === le ? pe : ui : t === le ? ui : pe : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Ut.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : e.slide;
    if (typeof e == "number") {
      i.to(e);
      return;
    }
    if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.ride === !0 && i.pause();
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Ut.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = Qt(this);
    if (!e || !e.hasAttribute(mr))
      return;
    const i = {
      ...c.getDataAttributes(e),
      ...c.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Ut.carouselInterface(e, i), n && Ut.getInstance(e).to(n), t.preventDefault();
  }
}
const un = "modal", yu = "te.modal", Ct = `.${yu}`, gr = "Escape", br = {
  backdrop: !0,
  keyboard: !0,
  focus: !0
}, wu = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean"
}, xu = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out"
}, ku = {
  show: "string",
  static: "string",
  staticProperties: "string"
}, Ou = `hide${Ct}`, Su = `hidePrevented${Ct}`, Iu = `hidden${Ct}`, Du = `show${Ct}`, $u = `shown${Ct}`, vr = `resize${Ct}`, Tr = `click.dismiss${Ct}`, Er = `keydown.dismiss${Ct}`, Lu = `mouseup.dismiss${Ct}`, Cr = `mousedown.dismiss${Ct}`, Ar = "data-te-modal-open", yr = "data-te-open", ni = "[data-te-modal-dialog-ref]", Mu = "[data-te-modal-body-ref]";
class Fl extends Et {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(ni, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ki();
  }
  // Getters
  static get Default() {
    return br;
  }
  static get NAME() {
    return un;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || h.trigger(this._element, Du, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(Ar, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), h.on(this._dialog, Cr, () => {
      h.one(this._element, Lu, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || h.trigger(this._element, Ou).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(ni, this._element).classList.remove(this._classes.show), h.off(this._element, Tr), h.off(this._dialog, Cr), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(yr);
  }
  dispose() {
    [window, this._dialog].forEach(
      (t) => h.off(t, Ct)
    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new So({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new $i(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...br,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, L(un, t, wu), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...xu,
      ...e,
      ...t
    }, L(un, t, ku), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = d.findOne(Mu, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${yr}`, "true"), this._element.scrollTop = 0;
    const n = d.findOne(ni, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && Ge(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, h.trigger(this._element, $u, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? h.on(document, Er, (t) => {
      this._config.keyboard && t.key === gr ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === gr && this._triggerBackdropTransition();
    }) : h.off(this._element, Er);
  }
  _setResizeEvent() {
    this._isShown ? h.on(window, vr, () => this._adjustDialog()) : h.off(window, vr);
  }
  _hideModal() {
    const t = d.findOne(ni, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0"), setTimeout(() => {
      this._element.style.display = "none";
    }, 300), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.removeAttribute(Ar), this._resetAdjustments(), this._scrollBar.reset(), h.trigger(this._element, Iu);
    });
  }
  _showBackdrop(t) {
    h.on(this._element, Tr, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop.show(t);
  }
  _isAnimated() {
    return !!d.findOne(ni, this._element);
  }
  _triggerBackdropTransition() {
    if (h.trigger(this._element, Su).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    !o && n.overflowY === "hidden" || e.contains(this._classes.static) || (o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" ")), this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, 300), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = Fl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const Nu = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Ru = /^aria-[\w-]*$/i, Pu = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Bu = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Hu = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return Nu.has(e) ? !!(Pu.test(s.nodeValue) || Bu.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, Wu = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Ru],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function wr(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], p = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(p)) {
      l.remove();
      continue;
    }
    const u = [].concat(...l.attributes), f = [].concat(
      t["*"] || [],
      t[p] || []
    );
    u.forEach((_) => {
      Hu(_, f) || l.removeAttribute(_.nodeName);
    });
  }
  return n.body.innerHTML;
}
const xr = "tooltip", Vu = "te.tooltip", yt = `.${Vu}`, Fu = "te-tooltip", Yu = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ju = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, Ku = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: F() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: F() ? "right" : "left"
}, zu = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: Wu,
  popperConfig: { hide: !0 }
}, Uu = {
  HIDE: `hide${yt}`,
  HIDDEN: `hidden${yt}`,
  SHOW: `show${yt}`,
  SHOWN: `shown${yt}`,
  INSERTED: `inserted${yt}`,
  CLICK: `click${yt}`,
  FOCUSIN: `focusin${yt}`,
  FOCUSOUT: `focusout${yt}`,
  MOUSEENTER: `mouseenter${yt}`,
  MOUSELEAVE: `mouseleave${yt}`
}, Xu = "fade", Gu = "modal", pn = "show", oi = "show", _n = "out", kr = ".tooltip-inner", Or = `.${Gu}`, Sr = "hide.te.modal", ri = "hover", fn = "focus", qu = "click", Zu = "manual";
class Qe extends Et {
  constructor(t, e) {
    if (typeof Nl > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return zu;
  }
  static get NAME() {
    return xr;
  }
  static get Event() {
    return Uu;
  }
  static get DefaultType() {
    return ju;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(pn)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), h.off(
      this._element.closest(Or),
      Sr,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = h.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = tl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(kr).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = bt(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (I.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), h.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ee(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const u = this._resolvePossibleFunction(this._config.customClass);
    u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((m) => {
      h.on(m, "mouseover", Ms);
    });
    const f = () => {
      const m = this._hoverState;
      this._hoverState = null, h.trigger(this._element, this.constructor.Event.SHOWN), m === _n && this._leave(null, this);
    }, _ = this.tip.classList.contains("transition-opacity");
    this._queueCallback(f, this.tip, _);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== oi && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), h.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (h.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => h.off(o, "mouseover", Ms)), this._activeTrigger[qu] = !1, this._activeTrigger[fn] = !1, this._activeTrigger[ri] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(Xu, pn), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), kr);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = d.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Ve(e)) {
        e = Jt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = wr(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return Ku[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        h.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== Zu) {
        const i = e === ri ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === ri ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        h.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), h.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, h.on(
      this._element.closest(Or),
      Sr,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? fn : ri] = !0), e.getTipElement().classList.contains(pn) || e._hoverState === oi) {
      e._hoverState = oi;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = oi, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === oi && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? fn : ri] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = _n, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === _n && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      Yu.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : Jt(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), L(xr, t, this.constructor.DefaultType), t.sanitize && (t.template = wr(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return Fu;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Qe.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Qu = "popover", Ju = "te.popover", wt = `.${Ju}`, tp = "te-popover", ep = {
  ...Qe.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, ip = {
  ...Qe.DefaultType,
  content: "(string|element|function)"
}, sp = {
  HIDE: `hide${wt}`,
  HIDDEN: `hidden${wt}`,
  SHOW: `show${wt}`,
  SHOWN: `shown${wt}`,
  INSERTED: `inserted${wt}`,
  CLICK: `click${wt}`,
  FOCUSIN: `focusin${wt}`,
  FOCUSOUT: `focusout${wt}`,
  MOUSEENTER: `mouseenter${wt}`,
  MOUSELEAVE: `mouseleave${wt}`
}, np = ".popover-header", op = ".popover-body";
class Yl extends Qe {
  // Getters
  static get Default() {
    return ep;
  }
  static get NAME() {
    return Qu;
  }
  static get Event() {
    return sp;
  }
  static get DefaultType() {
    return ip;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), np), this._sanitizeAndSetContent(t, this._getContent(), op);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return tp;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Yl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const mn = "scrollspy", rp = "te.scrollspy", Do = `.${rp}`, Ir = {
  offset: 10,
  method: "auto",
  target: ""
}, ap = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, lp = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, cp = {
  active: "string"
}, hp = `activate${Do}`, dp = `scroll${Do}`, gn = "data-te-nav-link-active", jl = "[data-te-dropdown-item-ref]", up = "[data-te-nav-list-ref]", oo = "[data-te-nav-link-ref]", pp = "[data-te-nav-item-ref]", Kl = "[data-te-list-group-item-ref]", bn = `${oo}, ${Kl}, ${jl}`, _p = "[data-te-dropdown-ref]", fp = "[data-te-dropdown-toggle-ref]", mp = "maxOffset", Dr = "position";
class zl extends Et {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, h.on(this._scrollElement, dp, () => this._process()), this.refresh(), this._process();
  }
  // Getters
  static get Default() {
    return Ir;
  }
  static get NAME() {
    return mn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? mp : Dr, e = this._config.method === "auto" ? t : this._config.method, i = e === Dr ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(
      bn,
      this._config.target
    ).map((o) => {
      const r = fo(o), a = r ? d.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            c[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    h.off(this._scrollElement, Do), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...Ir,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = Jt(t.target) || document.documentElement, L(mn, t, ap), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...lp,
      ...e,
      ...t
    }, L(mn, t, cp), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = bn.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = d.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(gn, ""), i.getAttribute(jl) ? d.findOne(
      fp,
      i.closest(_p)
    ).classList.add(...this._classes.active.split(" ")) : d.parents(i, up).forEach(
      (n) => {
        d.prev(
          n,
          `${oo}, ${Kl}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(gn, "");
        }), d.prev(n, pp).forEach(
          (o) => {
            d.children(o, oo).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), h.trigger(this._scrollElement, hp, {
      relatedTarget: t
    });
  }
  _clear() {
    d.find(bn, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(gn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = zl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const $r = "tab", gp = "te.tab", Fs = `.${gp}`, bp = `hide${Fs}`, vp = `hidden${Fs}`, Tp = `show${Fs}`, Ep = `shown${Fs}`, Cp = "data-te-dropdown-menu-ref", De = "data-te-tab-active", Es = "data-te-nav-active", Ap = "[data-te-dropdown-ref]", yp = "[data-te-nav-ref]", Lr = `[${De}]`, wp = `[${Es}]`, Mr = ":scope > li > .active", xp = "[data-te-dropdown-toggle-ref]", kp = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", Op = {
  show: "opacity-100",
  hide: "opacity-0"
}, Sp = {
  show: "string",
  hide: "string"
};
class Ul extends Et {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return $r;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Es) === "")
      return;
    let t;
    const e = Qt(this._element), i = this._element.closest(yp), n = d.findOne(
      wp,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? Mr : Lr;
      t = d.find(l, i), t = t[t.length - 1];
    }
    const o = t ? h.trigger(t, bp, {
      relatedTarget: this._element
    }) : null;
    if (h.trigger(this._element, Tp, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      h.trigger(t, vp, {
        relatedTarget: this._element
      }), h.trigger(this._element, Ep, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Op,
      ...e,
      ...t
    }, L($r, t, Sp), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? d.find(Mr, e) : d.children(e, Lr))[0], l = i && a && a.hasAttribute(De), p = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (c.removeClass(a, this._classes.show), c.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(De), n.removeAttribute(Es);
      const a = d.findOne(
        kp,
        e.parentNode
      );
      a && a.removeAttribute(De), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(De, ""), o.setAttribute(Es, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), Ge(t), t.classList.contains(this._classes.hide) && (c.removeClass(t, this._classes.hide), c.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(Cp)) {
      const a = t.closest(Ap);
      a && d.find(xp, a).forEach(
        (l) => l.setAttribute(De, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ul.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const vn = "toast", Ip = "te.toast", ee = `.${Ip}`, Dp = `mouseover${ee}`, $p = `mouseout${ee}`, Lp = `focusin${ee}`, Mp = `focusout${ee}`, Np = `hide${ee}`, Rp = `hidden${ee}`, Pp = `show${ee}`, Bp = `shown${ee}`, Nr = "data-te-toast-hide", Tn = "data-te-toast-show", Xi = "data-te-toast-showing", Hp = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, Rr = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, Wp = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, Vp = {
  fadeIn: "string",
  fadeOut: "string"
};
class Xl extends Et {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
  }
  // Getters
  static get DefaultType() {
    return Hp;
  }
  static get Default() {
    return Rr;
  }
  static get NAME() {
    return vn;
  }
  // Public
  show() {
    if (h.trigger(this._element, Pp).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (c.removeClass(this._element, this._classes.fadeOut), c.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(Xi), h.trigger(this._element, Bp), this._maybeScheduleHide();
    };
    this._element.removeAttribute(Nr), Ge(this._element), this._element.setAttribute(Tn, ""), this._element.setAttribute(Xi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || h.trigger(this._element, Np).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, c.removeClass(this._element, this._classes.fadeIn), c.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute(Nr, ""), this._element.removeAttribute(Xi), this._element.removeAttribute(Tn), h.trigger(this._element, Rp);
      }, i);
    };
    this._element.setAttribute(Xi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Tn), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...Rr,
      ...c.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, L(vn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Wp,
      ...e,
      ...t
    }, L(vn, t, Vp), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    h.on(
      this._element,
      Dp,
      (t) => this._onInteraction(t, !0)
    ), h.on(
      this._element,
      $p,
      (t) => this._onInteraction(t, !1)
    ), h.on(
      this._element,
      Lp,
      (t) => this._onInteraction(t, !0)
    ), h.on(
      this._element,
      Mp,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Xl.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(p) {
      return p[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var p = {};
        if (l)
          for (var u = 0; u < this.length; u++) {
            var f = this[u][0];
            f != null && (p[f] = !0);
          }
        for (var _ = 0; _ < r.length; _++) {
          var m = [].concat(r[_]);
          l && p[m[0]] || (a && (m[2] ? m[2] = "".concat(a, " and ").concat(m[2]) : m[2] = a), o.push(m));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, p;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
              p.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var E = {};
      return function(T) {
        if (E[T] === void 0) {
          var A = document.querySelector(T);
          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
            try {
              A = A.contentDocument.head;
            } catch {
              A = null;
            }
          E[T] = A;
        }
        return E[T];
      };
    }(), l = [];
    function p(E) {
      for (var T = -1, A = 0; A < l.length; A++)
        if (l[A].identifier === E) {
          T = A;
          break;
        }
      return T;
    }
    function u(E, T) {
      for (var A = {}, w = [], S = 0; S < E.length; S++) {
        var k = E[S], x = T.base ? k[0] + T.base : k[0], $ = A[x] || 0, O = "".concat(x, " ").concat($);
        A[x] = $ + 1;
        var M = p(O), P = { css: k[1], media: k[2], sourceMap: k[3] };
        M !== -1 ? (l[M].references++, l[M].updater(P)) : l.push({ identifier: O, updater: y(P, T), references: 1 }), w.push(O);
      }
      return w;
    }
    function f(E) {
      var T = document.createElement("style"), A = E.attributes || {};
      if (A.nonce === void 0) {
        var w = o.nc;
        w && (A.nonce = w);
      }
      if (Object.keys(A).forEach(function(k) {
        T.setAttribute(k, A[k]);
      }), typeof E.insert == "function")
        E.insert(T);
      else {
        var S = a(E.insert || "head");
        if (!S)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        S.appendChild(T);
      }
      return T;
    }
    var _, m = (_ = [], function(E, T) {
      return _[E] = T, _.filter(Boolean).join(`
`);
    });
    function g(E, T, A, w) {
      var S = A ? "" : w.media ? "@media ".concat(w.media, " {").concat(w.css, "}") : w.css;
      if (E.styleSheet)
        E.styleSheet.cssText = m(T, S);
      else {
        var k = document.createTextNode(S), x = E.childNodes;
        x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(k, x[T]) : E.appendChild(k);
      }
    }
    function v(E, T, A) {
      var w = A.css, S = A.media, k = A.sourceMap;
      if (S ? E.setAttribute("media", S) : E.removeAttribute("media"), k && typeof btoa < "u" && (w += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(k)))), " */")), E.styleSheet)
        E.styleSheet.cssText = w;
      else {
        for (; E.firstChild; )
          E.removeChild(E.firstChild);
        E.appendChild(document.createTextNode(w));
      }
    }
    var b = null, C = 0;
    function y(E, T) {
      var A, w, S;
      if (T.singleton) {
        var k = C++;
        A = b || (b = f(T)), w = g.bind(null, A, k, !1), S = g.bind(null, A, k, !0);
      } else
        A = f(T), w = v.bind(null, A, T), S = function() {
          (function(x) {
            if (x.parentNode === null)
              return !1;
            x.parentNode.removeChild(x);
          })(A);
        };
      return w(E), function(x) {
        if (x) {
          if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)
            return;
          w(E = x);
        } else
          S();
      };
    }
    i.exports = function(E, T) {
      (T = T || {}).singleton || typeof T.singleton == "boolean" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var A = u(E = E || [], T);
      return function(w) {
        if (w = w || [], Object.prototype.toString.call(w) === "[object Array]") {
          for (var S = 0; S < A.length; S++) {
            var k = p(A[S]);
            l[k].references--;
          }
          for (var x = u(w, T), $ = 0; $ < A.length; $++) {
            var O = p(A[$]);
            l[O].references === 0 && (l[O].updater(), l.splice(O, 1));
          }
          A = x;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var p = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(p) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const En = "input", Gi = "te.input", Gl = "data-te-input-wrapper-init", ql = "data-te-input-notch-ref", Zl = "data-te-input-notch-leading-ref", Ql = "data-te-input-notch-middle-ref", Fp = "data-te-input-notch-trailing-ref", Yp = "data-te-input-helper-ref", jp = "data-te-input-placeholder-active", Ft = "data-te-input-state-active", Pr = "data-te-input-focused", Br = "data-te-input-form-counter", he = `[${Gl}] input`, de = `[${Gl}] textarea`, we = `[${ql}]`, Hr = `[${Zl}]`, Wr = `[${Ql}]`, Kp = `[${Yp}]`, zp = {
  inputFormWhite: !1
}, Up = {
  inputFormWhite: "(boolean)"
}, Xp = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, Gp = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class W {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (I.setData(t, Gi, this), this.init());
  }
  // Getters
  static get NAME() {
    return En;
  }
  get input() {
    return d.findOne("input", this._element) || d.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Ft, ""), d.findOne(we, this.input.parentNode).setAttribute(
      Ft,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Ft), d.findOne(
      we,
      this.input.parentNode
    ).removeAttribute(Ft);
  }
  dispose() {
    this._removeBorder(), I.removeData(this._element, Gi), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...zp,
      ...c.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, L(En, t, Up), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Xp,
      ...e,
      ...t
    }, L(En, t, Gp), t;
  }
  _getLabelData() {
    this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = d.findOne(Kp, this._element);
  }
  _getCounter() {
    this._counter = c.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    h.on(
      document,
      "focus",
      he,
      W.activate(new W())
    ), h.on(
      document,
      "input",
      he,
      W.activate(new W())
    ), h.on(
      document,
      "blur",
      he,
      W.deactivate(new W())
    ), h.on(
      document,
      "focus",
      de,
      W.activate(new W())
    ), h.on(
      document,
      "input",
      de,
      W.activate(new W())
    ), h.on(
      document,
      "blur",
      de,
      W.deactivate(new W())
    ), h.on(window, "shown.te.modal", (t) => {
      d.find(he, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.update();
        }
      ), d.find(de, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), h.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (d.find(he, e).forEach(
        (i) => {
          const n = W.getInstance(i.parentNode);
          n && n.update();
        }
      ), d.find(de, e).forEach(
        (i) => {
          const n = W.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), h.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = c.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = d.findOne(`#${e}`);
      d.find(he, i).forEach((n) => {
        const o = W.getInstance(n.parentNode);
        o && o.update();
      }), d.find(de, i).forEach(
        (n) => {
          const o = W.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), h.on(window, "reset", (t) => {
      d.find(he, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), d.find(de, t.target).forEach(
        (e) => {
          const i = W.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), h.on(window, "onautocomplete", (t) => {
      const e = W.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (d.find(
      `[${Br}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), c.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Br, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    h.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(jp, "");
  }
  _getNotchData() {
    this._notchMiddle = d.findOne(
      Wr,
      this._element
    ), this._notchLeading = d.findOne(
      Hr,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = d.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(we, this._element), o = D("div");
    c.addClass(o, this._classes.notch), o.setAttribute(ql, ""), this._notchLeading = D("div"), c.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(Zl, ""), this._notchMiddle = D("div"), c.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(Ql, ""), this._notchTrailing = D("div"), c.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(Fp, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = d.findOne(we, this._element);
    t && t.remove();
  }
  _activate(t) {
    il(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = d.findOne(
        we,
        this._element
      );
      t && t.type === "focus" && i.setAttribute(Pr, ""), e.value !== "" && (e.setAttribute(Ft, ""), i.setAttribute(Ft, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = d.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(
        Wr,
        t.target.parentNode
      ), this._notchLeading = d.findOne(
        Hr,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = d.findOne(
      we,
      e.parentNode
    );
    i.removeAttribute(Pr), e.value === "" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Gi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new W(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Gi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Vr = "animation", Cn = "te.animation", qp = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, Zp = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class Jl {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (I.setData(t, Cn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Vr;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    h.off(this._element, "mousedown"), h.off(this._animateElement, "animationend"), h.off(window, "scroll"), h.off(this._element, "mouseover"), I.removeData(this._element, Cn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = c.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? d.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._animateElement);
    return t = {
      ...Zp,
      ...e,
      ...t
    }, L(Vr, t, qp), t;
  }
  _animateOnScroll() {
    const t = c.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    c.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    c.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    c.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    c.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    c.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    h.on(this._animateElement, "click", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    c.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    c.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    h.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    h.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), h.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    h.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    h.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), h.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new Jl(this[0], t).init();
  }
  static getInstance(t) {
    return I.getData(t, Cn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const An = "ripple", qi = "te.ripple", Qp = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Jp = ["[data-te-ripple-init]"], Zi = [0, 0, 0], t_ = [
  { name: "primary", gradientColor: "#3B71CA" },
  { name: "secondary", gradientColor: "#9FA6B2" },
  { name: "success", gradientColor: "#14A44D" },
  { name: "danger", gradientColor: "#DC4C64" },
  { name: "warning", gradientColor: "#E4A11B" },
  { name: "info", gradientColor: "#54B4D3" },
  { name: "light", gradientColor: "#fbfbfb" },
  { name: "dark", gradientColor: "#262626" }
], Fr = 0.5, e_ = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, i_ = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, s_ = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, n_ = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class Ue {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (I.setData(t, qi, this), c.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return An;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    I.removeData(this._element, qi), h.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    Jp.forEach((e) => {
      d.closest(t.target, e) && (this._element = d.closest(t.target, e));
    }), this._element.style.minWidth || (c.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], c.addClass(this._element, this._classes.ripple), this._createRipple(t);
  }
  _addClickEvent(t) {
    h.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && c.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, u = this._getDiameter(p), f = this._options.rippleRadius || u / 2, _ = {
      delay: l * Fr,
      duration: l - l * Fr
    }, m = {
      left: this._options.rippleCentered ? `${a / 2 - f}px` : `${n - f}px`,
      top: this._options.rippleCentered ? `${r / 2 - f}px` : `${o - f}px`,
      height: `${this._options.rippleRadius * 2 || u}px`,
      width: `${this._options.rippleRadius * 2 || u}px`,
      transitionDelay: `0s, ${_.delay}ms`,
      transitionDuration: `${l}ms, ${_.duration}ms`
    }, g = D("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: g,
      styles: m
    }), this._removeHTMLRipple({ ripple: g, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), c.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        d.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (c.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        c.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...e_,
      ...e,
      ...t
    }, L(An, t, i_), t;
  }
  _getClasses(t = {}) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...s_,
      ...e,
      ...t
    }, L(An, t, n_), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (_, m) => Math.sqrt(_ ** 2 + m ** 2), l = e === i / 2 && t === n / 2, p = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, u = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let f = 0;
    return l || p.fourth ? f = u.topLeft : p.third ? f = u.topRight : p.second ? f = u.bottomRight : p.first && (f = u.bottomLeft), f * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      c.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? c.addClass(t, this._classes.unbound) : c.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = t_.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = Qp.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? Zi : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Zi : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : Zi);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return I.getData(this, qi) ? null : new Ue(this, t);
    });
  }
  static getInstance(t) {
    return I.getData(t, qi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function Z(s) {
  return s.getDate();
}
function Cs(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function B(s) {
  return s.getFullYear();
}
function o_(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function ro(s) {
  return r_(s).getDate();
}
function r_(s) {
  return Mt(s.getFullYear(), s.getMonth() + 1, 0);
}
function Re() {
  return /* @__PURE__ */ new Date();
}
function it(s, t) {
  return nt(s, t * 12);
}
function nt(s, t) {
  const e = Mt(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = Z(s), n = Z(e);
  return i !== n && e.setDate(0), e;
}
function xe(s, t) {
  return Mt(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Mt(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Yr(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Mt(e, i, n);
}
function a_(s) {
  return !Number.isNaN(s.getTime());
}
function Me(s, t) {
  return B(s) - B(t) || Y(s) - Y(t) || Z(s) - Z(t);
}
function _e(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function As(s, t) {
  const i = B(s) - c_();
  return l_(i, t);
}
function l_(s, t) {
  return (s % t + t) % t;
}
function c_(s, t, e) {
  let i = 0;
  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;
}
function Ps(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && Me(s, t) <= -1, l = e && Me(s, e) >= 1, p = n && Me(s, r) <= -1, u = o && Me(s, r) >= 1, f = i && i(s) === !1;
  return a || l || f || p || u;
}
function tc(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), f = B(r), _ = Y(r), m = l && a && (t > a || t === a && s > l), g = u && p && (t < p || t === p && s < u), v = n && (t < f || t === f && s < _), b = o && (t > f || t === f && s > _);
  return m || g || v || b;
}
function ao(s, t, e, i, n) {
  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, f = n && s > a;
  return l || p || u || f;
}
function h_(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && Me(o, l) < 0 || s) && (o = l), o && Ai(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function d_(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && Me(n, l) < 0 || s) && (n = l), n && Ai(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Ai(s, t, e, i, n, o, r, a) {
  return e === "days" ? B(s) === B(t) && Y(s) === Y(t) : e === "months" ? B(s) === B(t) : e === "years" ? B(t) >= a && B(t) <= r : !1;
}
const u_ = "data-te-datepicker-modal-container-ref", p_ = "data-te-datepicker-dropdown-container-ref", __ = "data-te-dropdown-backdrop-ref", f_ = "data-te-datepicker-date-text-ref", jr = "data-te-datepicker-view-ref", m_ = "data-te-datepicker-previous-button-ref", g_ = "data-te-datepicker-next-button-ref", b_ = "data-te-datepicker-ok-button-ref", v_ = "data-te-datepicker-cancel-button-ref", T_ = "data-te-datepicker-clear-button-ref", E_ = "data-te-datepicker-view-change-button-ref";
function C_(s, t, e, i, n, o, r, a, l, p) {
  const u = Y(s), f = B(s), _ = Z(s), m = Cs(s), g = D("div"), v = `
        ${Kr(
    s,
    u,
    f,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `, b = `
      ${y_(_, m, u, n, p)}
      ${Kr(
    s,
    u,
    f,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `;
  return n.inline ? (c.addClass(g, p.datepickerDropdownContainer), g.setAttribute(p_, l), g.innerHTML = v) : (c.addClass(g, p.modalContainer), g.setAttribute(u_, l), g.innerHTML = b), g;
}
function A_(s) {
  const t = D("div");
  return c.addClass(t, s), t.setAttribute(__, ""), t;
}
function y_(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}">
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${f_} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Kr(s, t, e, i, n, o, r, a, l, p, u) {
  let f;
  return r.inline ? f = `
    <div class="${u.datepickerMain}">
      ${Ur(t, e, r, u)}
      <div class="${u.datepickerView}" ${jr} tabindex="0">
        ${zr(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
    </div>
  ` : f = `
    <div class="${u.datepickerMain}">
      ${Ur(t, e, r, u)}
      <div class="${u.datepickerView}" ${jr} tabindex="0">
        ${zr(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
      ${w_(r, u)}
    </div>
  `, f;
}
function zr(s, t, e, i, n, o, r, a, l, p) {
  let u;
  return o.view === "days" ? u = ys(s, e, o, p) : o.view === "months" ? u = ws(
    t,
    i,
    n,
    o,
    r,
    p
  ) : u = xs(
    s,
    i,
    o,
    a,
    l,
    p
  ), u;
}
function Ur(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${E_}>
        ${e.monthsFull[s]} ${t} ${Dt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${m_}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${g_}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function Dt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function w_(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${b_}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${v_}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${T_}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function ys(s, t, e, i) {
  const n = x_(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, p) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[p]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((p) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${B(p.date)}-${Y(
    p.date
  )}-${Z(p.date)}"
              aria-label="${p.date}"
              aria-selected="${p.isSelected}"
              ${p.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!p.currentMonth || p.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${p.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${p.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${p.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function x_(s, t, e) {
  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = B(s), l = o_(a, n, e), p = ro(s), u = ro(nt(s, -1)), f = 7;
  let _ = 1, m = !1;
  for (let g = 1; g < f; g++) {
    const v = [];
    if (g === 1) {
      const b = u - l + 1;
      for (let y = b; y <= u; y++) {
        const E = Mt(a, o, y);
        v.push({
          date: E,
          currentMonth: m,
          isSelected: t && _e(E, t),
          isToday: _e(E, Re()),
          dayNumber: Z(E)
        });
      }
      m = !0;
      const C = f - v.length;
      for (let y = 0; y < C; y++) {
        const E = Mt(a, n, _);
        v.push({
          date: E,
          currentMonth: m,
          isSelected: t && _e(E, t),
          isToday: _e(E, Re()),
          dayNumber: Z(E),
          disabled: Ps(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), _++;
      }
    } else
      for (let b = 1; b < 8; b++) {
        _ > p && (_ = 1, m = !1);
        const C = Mt(
          a,
          m ? n : r,
          _
        );
        v.push({
          date: C,
          currentMonth: m,
          isSelected: t && _e(C, t),
          isToday: _e(C, Re()),
          dayNumber: Z(C),
          disabled: Ps(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), _++;
      }
    i.push(v);
  }
  return i;
}
function ws(s, t, e, i, n, o) {
  const r = k_(i, n), a = Y(Re()), l = B(Re()), p = `
      ${r.map((u) => `
          <tr>
            ${u.map((f) => {
    const _ = i.monthsShort.indexOf(f);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${tc(
      _,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${_}" data-te-year="${s}" aria-label="${f}, ${s}"
                ${_ === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${_ === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${_}" data-te-year="${s}" aria-label="${f}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${f}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${p}
        </tbody>
      </table>
    `;
}
function k_(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function xs(s, t, e, i, n, o) {
  const r = O_(s, i, n), a = B(Re()), l = `
    ${r.map((p) => `
        <tr>
          ${p.map((u) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${u}" data-te-year="${u}"
              ${ao(
    u,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${u === t ? "data-te-datepicker-cell-selected" : ""}
              ${u === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${u}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function O_(s, t, e) {
  const i = [], n = B(s), o = As(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const p = a;
      i.push(p), a = [];
    }
  return i;
}
function S_(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Pe = 37, rt = 38, Be = 39, z = 40, He = 36, We = 35, yn = 33, wn = 34, lt = 13, ks = 32, Li = 27, Oi = 9, I_ = 8, D_ = 46, gt = 24, Qi = 4, Ji = 4, xn = "datepicker", Os = "te.datepicker", Ys = `.${Os}`, $_ = ".data-api", L_ = `close${Ys}`, M_ = `open${Ys}`, N_ = `dateChange${Ys}`, ts = `click${Ys}${$_}`, ec = "data-te-datepicker-modal-container-ref", ic = "data-te-datepicker-dropdown-container-ref", es = "[data-te-datepicker-toggle-ref]", R_ = `[${ec}]`, P_ = `[${ic}]`, B_ = "[data-te-datepicker-view-change-button-ref]", H_ = "[data-te-datepicker-previous-button-ref]", W_ = "[data-te-datepicker-next-button-ref]", V_ = "[data-te-datepicker-ok-button-ref]", F_ = "[data-te-datepicker-cancel-button-ref]", Y_ = "[data-te-datepicker-clear-button-ref]", j_ = "[data-te-datepicker-view-ref]", K_ = "[data-te-datepicker-toggle-button-ref]", z_ = "[data-te-datepicker-date-text-ref]", U_ = "[data-te-dropdown-backdrop-ref]", X_ = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", G_ = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", q_ = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", Z_ = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", Q_ = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", J_ = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", tf = "relative h-full", ef = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", sf = "h-8 flex flex-col justify-end", nf = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", of = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", rf = "text-[34px] font-normal text-white", af = "outline-none px-3", lf = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", cf = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", hf = "mt-2.5", df = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", uf = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", pf = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", _f = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", ff = "mr-auto", mf = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", gf = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", bf = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", vf = "w-[76px] h-[42px]", Tf = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Ef = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", Cf = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Af = "mx-auto w-[304px]", yf = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", wf = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", xf = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", kf = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, Of = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, Sf = {
  fadeIn: X_,
  fadeOut: G_,
  fadeInShort: q_,
  fadeOutShort: Z_,
  modalContainer: Q_,
  datepickerBackdrop: J_,
  datepickerMain: tf,
  datepickerHeader: ef,
  datepickerTitle: sf,
  datepickerTitleText: nf,
  datepickerDate: of,
  datepickerDateText: rf,
  datepickerView: af,
  datepickerDateControls: lf,
  datepickerViewChangeButton: cf,
  datepickerViewChangeIcon: wf,
  datepickerArrowControls: hf,
  datepickerPreviousButton: df,
  datepickerNextButton: uf,
  datepickerFooter: pf,
  datepickerFooterBtn: _f,
  datepickerClearBtn: ff,
  datepickerDayHeading: mf,
  datepickerCell: gf,
  datepickerCellSmall: bf,
  datepickerCellLarge: vf,
  datepickerCellContent: Tf,
  datepickerCellContentSmall: Ef,
  datepickerCellContentLarge: Cf,
  datepickerTable: Af,
  datepickerToggleButton: yf,
  datepickerDropdownContainer: xf
}, If = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class F0 {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = bt("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new ki(), this._element && I.setData(t, Os, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return xn;
  }
  get container() {
    return d.findOne(
      `[${ec}='${this._toggleButtonId}']`
    ) || d.findOne(
      `[${ic}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return Z(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return B(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - As(this._activeDate, gt);
  }
  get lastYearInView() {
    return this.firstYearInView + gt - 1;
  }
  get viewChangeButton() {
    return d.findOne(B_, this.container);
  }
  get previousButton() {
    return d.findOne(H_, this.container);
  }
  get nextButton() {
    return d.findOne(W_, this.container);
  }
  get okButton() {
    return d.findOne(V_, this.container);
  }
  get cancelButton() {
    return d.findOne(F_, this.container);
  }
  get clearButton() {
    return d.findOne(Y_, this.container);
  }
  get datesContainer() {
    return d.findOne(j_, this.container);
  }
  get toggleButton() {
    return d.findOne(K_, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    if (t = {
      ...kf,
      ...e,
      ...t
    }, L(xn, t, Of), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Sf,
      ...e,
      ...t
    }, L(xn, t, If), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = S_(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = h.trigger(this._element, M_);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = A_(this._classes.datepickerBackdrop), i = C_(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      gt,
      Qi,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (c.addClass(this.container, this._classes.fadeIn), c.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = Ee(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new $i(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    h.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    h.on(
      this._element,
      ts,
      es,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    h.on(
      this._element,
      "keydown",
      es,
      (t) => {
        t.keyCode === lt && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    h.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = d.findOne(
      z_,
      this.container
    ), o = Y(t), r = Z(t), a = Cs(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    h.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), h.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), h.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    h.on(this.okButton, "click", () => this.handleOk()), h.on(this.cancelButton, "click", () => this.handleCancel()), h.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    h.on(document, ts, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    h.on(document, "keydown", (t) => {
      t.keyCode === Li && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    h.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    h.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    h.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = xe(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = xe(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = xe(this._activeDate, -7);
        break;
      case z:
        this._activeDate = xe(this._activeDate, 7);
        break;
      case He:
        this._activeDate = xe(
          this._activeDate,
          1 - Z(this._activeDate)
        );
        break;
      case We:
        this._activeDate = xe(
          this._activeDate,
          ro(this._activeDate) - Z(this._activeDate)
        );
        break;
      case yn:
        this._activeDate = nt(this._activeDate, -1);
        break;
      case wn:
        this._activeDate = nt(this._activeDate, 1);
        break;
      case lt:
      case ks:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Yr(i.dataset.teDate);
      return _e(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = nt(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = nt(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = nt(this._activeDate, -4);
        break;
      case z:
        this._activeDate = nt(this._activeDate, 4);
        break;
      case He:
        this._activeDate = nt(this._activeDate, -this.activeMonth);
        break;
      case We:
        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);
        break;
      case yn:
        this._activeDate = it(this._activeDate, -1);
        break;
      case wn:
        this._activeDate = it(this._activeDate, 1);
        break;
      case lt:
      case ks:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Pe:
        this._activeDate = it(this._activeDate, F() ? 1 : -1);
        break;
      case Be:
        this._activeDate = it(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = it(this._activeDate, -n);
        break;
      case z:
        this._activeDate = it(this._activeDate, n);
        break;
      case He:
        this._activeDate = it(
          this._activeDate,
          -As(this._activeDate, o)
        );
        break;
      case We:
        this._activeDate = it(
          this._activeDate,
          o - As(this._activeDate, o) - 1
        );
        break;
      case yn:
        this._activeDate = it(this._activeDate, -o);
        break;
      case wn:
        this._activeDate = it(this._activeDate, o);
        break;
      case lt:
      case ks:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = h.trigger(this._element, L_);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && c.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = d.findOne(P_), e = this._getContainer();
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = d.findOne(U_), e = d.findOne(R_);
    !e || !t || (this._animations ? (c.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    h.off(this.nextButton, "click"), h.off(this.previousButton, "click"), h.off(this.viewChangeButton, "click"), h.off(this.okButton, "click"), h.off(this.cancelButton, "click"), h.off(this.clearButton, "click"), h.off(this.datesContainer, "click"), h.off(this.datesContainer, "keydown"), h.off(this.datesContainer, "focus"), h.off(this.datesContainer, "blur"), h.off(document, ts);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = d.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), I.removeData(this._element, Os), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    h.off(this._input, "input"), h.off(
      this._element,
      ts,
      es
    ), h.off(this._element, "keydown", es);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    Ps(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, h.trigger(this._element, N_, { date: t }), h.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = Z(t), i = this._addLeadingZero(Z(t)), n = this._options.weekdaysShort[Cs(t)], o = this._options.weekdaysFull[Cs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), f = B(t), _ = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let m = "";
    return _.forEach((g) => {
      switch (g) {
        case "dddd":
          g = g.replace(g, o);
          break;
        case "ddd":
          g = g.replace(g, n);
          break;
        case "dd":
          g = g.replace(g, i);
          break;
        case "d":
          g = g.replace(g, e);
          break;
        case "mmmm":
          g = g.replace(g, p);
          break;
        case "mmm":
          g = g.replace(g, l);
          break;
        case "mm":
          g = g.replace(g, a);
          break;
        case "m":
          g = g.replace(g, r);
          break;
        case "yyyy":
          g = g.replace(g, f);
          break;
        case "yy":
          g = g.replace(g, u);
          break;
      }
      m += g;
    }), m;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Yr(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    Ps(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (ao(t, e, i, n, o))
      return;
    const r = Mt(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (tc(t, e, i, n, o, r) || ao(e, i, n, o, r))
      return;
    const a = Mt(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = nt(this._activeDate, 1), e = ys(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = nt(this._activeDate, -1);
    this._activeDate = t;
    const e = ys(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = it(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    );
    const e = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = it(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    );
    const e = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = it(this._activeDate, 24);
    this._activeDate = t;
    const e = xs(
      t,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = it(this._activeDate, -24);
    this._activeDate = t;
    const e = xs(
      t,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = ys(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = ws(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Ji,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = xs(
      this._activeDate,
      this._selectedYear,
      this._options,
      gt,
      Qi,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Dt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    h_(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, d_(
      this._options.disablePast,
      this._activeDate,
      this._view,
      gt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    a_(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, p = [];
    for (let v = 0; v < a.length; v++)
      a[v].indexOf("yy") !== -1 && (p[0] = { value: r[v], format: a[v] }), a[v].indexOf("m") !== -1 && (p[1] = { value: r[v], format: a[v] }), a[v].indexOf("d") !== -1 && a[v].length <= 2 && (p[2] = { value: r[v], format: a[v] });
    let u;
    e.indexOf("mmmm") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;
    const f = Number(p[0].value), _ = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, m = Number(p[2].value);
    return Mt(f, _, m);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return I.getData(t, Os);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Df = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: p,
  amLabel: u,
  pmLabel: f
}, _) => {
  const m = `<div id='${r}' class='${_.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${_.timepickerContainer}">
        <div class="${_.timepickerElements}">
        <div id='${i}' class='${_.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${_.timepickerHeadContent}'>
            <div class="${_.timepickerCurrentWrapper}">
              <span class="${_.timepickerCurrentButtonWrapper}">
                <button type='button' class='${_.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${_.timepickerDot}' disabled>:</button>
            <span class="${_.timepickerCurrentButtonWrapper}">
              <button type='button' class='${_.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${_.timepickerModeWrapper}">
                  <button type='button' class="${_.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>
                  <button class="${_.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${f}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${_.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${_.timepickerClock}' data-te-timepicker-clock>
              <span class='${_.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${_.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${_.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + _.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${_.timepickerFooterWrapper}'>
      <div class="${_.timepickerFooter}">
        ${p ? `<button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${_.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, g = `<div id='${r}' class='${_.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${_.timepickerInlineContainer}">
          <div class="${_.timepickerInlineElements}">
          <div id='${i}' class='${_.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${_.timepickerInlineHeadContent}'>
              <div class="${_.timepickerCurrentWrapper}">
                <span class="${_.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${_.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${_.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${_.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${_.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${_.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${_.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${_.timepickerCurrentMinuteWrapper}">
                <span class="${_.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${_.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${_.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${_.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${_.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${_.timepickerInlineModeWrapper}">
                      <button type='button' class="${_.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${u}</button>
                      <button class="${_.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${f}</button>
                      <button type='button' class='${_.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${_.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? g : m;
}, $f = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, js = "data-te-timepicker-disabled", is = "data-te-timepicker-active", be = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return sc(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, sc = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), Xr = (s) => {
  if (s === "")
    return;
  let t, e;
  return sc(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, Lf = (s, t, e) => h.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(is))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(is) && (c.removeClass(o, e.opacity), o.removeAttribute(is));
  }), c.addClass(i, e.opacity), i.setAttribute(is, "");
}), Gr = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, ss = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), nc = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, oc = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, Xt = (s, t, e) => {
  if (!t)
    return s;
  let i = oc();
  return e && (i = `${be(i).hours}:${be(i).minutes} ${be(i).amOrPm}`), (s !== "" && nc(i, s) || s === "") && (s = i), s;
}, Gt = (s, t, e) => {
  if (!t)
    return s;
  let i = oc();
  return e && (i = `${be(i).hours}:${be(i).minutes} ${be(i).amOrPm}`), (s !== "" && !nc(i, s) || s === "") && (s = i), s;
}, Mf = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = Xt(e, i, s), t = Gt(t, n, s);
  const [l, p, u] = R(t, !1), [f, _, m] = R(e, !1);
  if (u !== void 0 || m !== void 0)
    return [r, a];
  if (!(l !== "" && f === "" && Number(r) > Number(l)) && !(l === "" && f !== "" && p === void 0 && _ !== "" && Number(r) < Number(f)))
    return [r, a];
}, qr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (c.addClass(n, e.tipsDisabled), n.setAttribute(js, ""));
  });
}, Zr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (c.addClass(n, e.tipsDisabled), n.setAttribute(js, ""));
  });
}, rc = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, Nf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (rc(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (c.addClass(r, n.tipsDisabled), r.setAttribute(js, ""));
  });
}, Rf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (rc(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (c.addClass(r, n.tipsDisabled), r.setAttribute(js, ""));
  });
}, Pf = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), yi = "timepicker", N = `data-te-${yi}`, Qr = "[data-te-toggle]", Ss = `te.${yi}`, Rt = `.${Ss}`, Pt = ".data-api", Jr = `click${Rt}${Pt}`, ns = `keydown${Rt}${Pt}`, ta = `mousedown${Rt}${Pt}`, ea = `mouseup${Rt}${Pt}`, ia = `mousemove${Rt}${Pt}`, sa = `mouseleave${Rt}${Pt}`, na = `mouseover${Rt}${Pt}`, oa = `touchmove${Rt}${Pt}`, ra = `touchend${Rt}${Pt}`, aa = `touchstart${Rt}${Pt}`, Bf = `[${N}-am]`, Hf = `[${N}-pm]`, Wf = `[${N}-format24]`, os = `[${N}-current]`, rs = `[${N}-hour-mode]`, Vf = `[${N}-toggle-button]`, kn = `${N}-cancel`, la = `${N}-clear`, On = `${N}-submit`, Ff = `${N}-icon`, Sn = `${N}-icon-up`, In = `${N}-icon-down`, Yf = `${N}-icon-inline-hour`, jf = `${N}-icon-inline-minute`, ca = `${N}-inline-hour-icons`, Kf = `${N}-current-inline`, zf = "readonly", ha = `${N}-invalid-feedback`, Dn = `${N}-is-invalid`, Yt = `${N}-disabled`, H = `${N}-active`, Uf = `${N}-input`, ue = `${N}-clock`, ai = `${N}-clock-inner`, $n = `${N}-wrapper`, da = `${N}-clock-wrapper`, as = `${N}-hour`, Ln = `${N}-minute`, ls = `${N}-tips-element`, K = `${N}-tips-hours`, X = `${N}-tips-minutes`, at = `${N}-tips-inner`, cs = `${N}-tips-inner-element`, ua = `${N}-middle-dot`, Mn = `${N}-hand-pointer`, Nn = `${N}-circle`, pa = `${N}-modal`, Xf = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, Gf = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: Xf,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, qf = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, Zf = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white",
  invalidFeedback: "block absolute text-sm text-red-500 dark:text-red-300"
}, Qf = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string",
  invalidFeedback: "string"
};
class Y0 {
  constructor(t, e = {}, i) {
    At(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    At(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${H}]`) !== null) {
        c.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      c.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    At(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(Yt)) {
          if (o.textContent === n) {
            c.addClass(o, this._classes.tipsActive), o.setAttribute(H, "");
            return;
          }
          c.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);
        }
      });
    });
    At(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    At(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    At(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    At(this, "_getAppendClock", (t = [], e = `[${ue}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;
      n = Xt(n, l, a), o = Gt(o, p, a);
      const [u, f, _] = R(
        o,
        !1
      ), [m, g, v] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
      const b = d.findOne(e), C = 360 / t.length;
      function y(w) {
        return w * (Math.PI / 180);
      }
      if (b === null)
        return;
      const E = (b.offsetWidth - 32) / 2, T = (b.offsetHeight - 32) / 2, A = E - 4;
      setTimeout(() => {
        let w;
        a && (w = d.findOne(
          `${rs}[${H}]`
        ).textContent), this._handleDisablingTipsMinTime(
          w,
          v,
          g,
          m
        ), this._handleDisablingTipsMaxTime(
          w,
          _,
          f,
          u
        );
      }, 0), [...t].forEach((w, S) => {
        const k = y(S * C), x = D("span"), $ = D("span");
        $.innerHTML = w, c.addClass(x, this._classes.tips), x.setAttribute(i, "");
        const O = x.offsetWidth, M = x.offsetHeight;
        return c.addStyle(x, {
          left: `${E + Math.sin(k) * A - O}px`,
          bottom: `${T + Math.cos(k) * A - M}px`
        }), t.includes("05") && x.setAttribute(X, ""), t.includes("13") ? $.setAttribute(cs, "") : $.setAttribute(ls, ""), x.appendChild($), b.appendChild(x);
      });
    });
    this._element = t, this._element && I.setData(t, Ss, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = bt("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = d.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(
      Vf,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(
      Wf,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(
      Qr,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Qr).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = Xr(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = be(this._inputValue)), this._options.readOnly && this.input.setAttribute(zf, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = Xr(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new ki();
  }
  // Getters
  static get NAME() {
    return yi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(Uf, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(H, ""), h.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && I.removeData(this._element, Ss), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), h.off(
      this._document,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), h.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = $f(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = d.findOne(`[${as}]`), this._minutes = d.findOne(`[${Ln}]`), this._AM = d.findOne(Bf), this._PM = d.findOne(Hf), this._wrapper = d.findOne(`[${$n}]`), this._modal = d.findOne(`[${pa}]`), this._hand = d.findOne(`[${Mn}]`), this._circle = d.findOne(`[${Nn}]`), this._clock = d.findOne(`[${ue}]`), this._clockInner = d.findOne(
      `[${ai}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: f, _isPmEnabled: _ } = this, m = r.keyCode, g = r.target.hasAttribute(ai) || r.target.hasAttribute(at) || r.target.hasAttribute(cs);
    i = Xt(i, p, l), e = Gt(e, u, l), typeof e != "number" && (e = R(e, !1)[0]);
    const v = e !== "" ? e * 30 : "", b = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const C = () => {
      const S = document.querySelectorAll(
        `[${ls}]`
      ), k = document.querySelectorAll(
        `[${cs}]`
      ), x = Pf(this._hour.innerText);
      let $, O, M;
      return m === rt ? O = 1 : m === z && (O = -1), x === 12 && m === rt ? M = 1 : x === 0 && m === rt ? M = 13 : x === 0 && m === z ? M = 23 : x === 13 && m === z ? M = 0 : x === 1 && m === z ? M = 12 : M = x + O, S.forEach((P) => {
        Number(P.textContent) === M && ($ = P);
      }), k.forEach((P) => {
        Number(P.textContent) === M && ($ = P);
      }), !$.parentElement.hasAttribute(Yt);
    }, y = () => {
      const S = i !== "" && i > 12 ? (i - 12) * 30 : "", k = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(S && t < S || k && t > k || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && g)
      return y();
    if (r.type === "keydown")
      return C();
    const E = !o || o === "PM" && _ || i !== "" && o === "AM" && f, T = !n || n === "PM" && _ || e !== "" && n === "AM" && f, A = () => {
      const S = b === 360 && l ? 0 : b;
      if (i) {
        if (o === "PM" && f || E && t < S)
          return;
      } else
        return !0;
      return !0;
    }, w = () => {
      const S = v === 360 && l ? 0 : v;
      if (e) {
        if (n === "AM" && _ || T && t > S)
          return;
      } else
        return !0;
      return !0;
    };
    return A() && w();
  }
  _handleKeyboard() {
    h.on(this._document, ns, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: p,
        disableFuture: u
      } = this._options;
      let f = R(a, !1)[0], _ = R(r, !1)[0];
      const m = R(a, !1)[2], g = R(r, !1)[2];
      f = Xt(f, p, l), _ = Gt(_, u, l), typeof _ != "number" && (_ = R(_, !1)[0]);
      const v = d.findOne(`[${X}]`) === null, b = d.findOne(`[${at}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), y = d.find(
        `[${X}]`,
        this._modal
      ), E = d.find(
        `[${K}]`,
        this._modal
      ), T = d.find(
        `[${at}]`,
        this._modal
      );
      let A = this._makeHourDegrees(t.target, C, e).hour;
      const { degrees: w, addDegrees: S } = this._makeHourDegrees(
        t.target,
        C,
        e
      );
      let { minute: k, degrees: x } = this._makeMinutesDegrees(C, i);
      const $ = this._makeMinutesDegrees(
        C,
        i
      ).addDegrees;
      let { hour: O } = this._makeInnerHoursDegrees(
        C,
        n
      );
      if (t.keyCode === Li) {
        const M = d.findOne(
          `[${kn}]`,
          this._modal
        );
        h.trigger(M, "click");
      } else if (v) {
        if (b && (t.keyCode === Be && (this._isInner = !1, c.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          A > 12 ? 1 : A
        ), this._toggleClassActive(this.hoursArray, this._hour, E), this._toggleClassActive(this.innerHours, this._hour, T)), t.keyCode === Pe && (this._isInner = !0, c.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          O >= 24 || O === "00" ? 0 : O
        ), this._toggleClassActive(this.innerHours, this._hour, T), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          E
        ))), t.keyCode === rt) {
          if (!this._handlerMaxMinHoursOptions(
            w + 30,
            _,
            f,
            g,
            m,
            t
          ))
            return;
          c.addStyle(this._hand, {
            transform: `rotateZ(${w + S}deg)`
          }), this._isInner ? (O += 1, O === 24 ? O = 0 : (O === 25 || O === "001") && (O = 13), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, T)) : (A += 1, this._hour.textContent = this._setHourOrMinute(
            A > 12 ? 1 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, E));
        }
        if (t.keyCode === z) {
          if (!this._handlerMaxMinHoursOptions(
            w - 30,
            _,
            f,
            g,
            m,
            t
          ))
            return;
          c.addStyle(this._hand, {
            transform: `rotateZ(${w - S}deg)`
          }), this._isInner ? (O -= 1, O === 12 ? O = 0 : O === -1 && (O = 23), this._hour.textContent = this._setHourOrMinute(O), this._toggleClassActive(this.innerHours, this._hour, T)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(
            A === 0 ? 12 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, E));
        }
      } else
        t.keyCode === rt && (x += $, c.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), k += 1, o && (k += 4, k === "0014" && (k = 5)), this._minutes.textContent = this._setHourOrMinute(
          k > 59 ? 0 : k
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        )), t.keyCode === z && (x -= $, c.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), o ? k -= 5 : k -= 1, k === -1 ? k = 59 : k === -5 && (k = 55), this._minutes.textContent = this._setHourOrMinute(k), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = d.find(
          `[${K}]`,
          this._modal
        ), n = d.find(
          `[${at}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n === "PM" ? (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")) : n === "AM" ? (c.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, "")) : (c.removeClass(this._AM, this._classes.opacity), c.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));
        const i = d.find(
          `[${K}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || c.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (c.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), c.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && c.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    h.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === lt && (t.preventDefault(), h.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    oe.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = c.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          c.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, f = D("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), f.innerHTML = Df(this._options, this._classes), c.addClass(f, this._classes.modal), f.setAttribute(pa, ""), f.setAttribute("role", "dialog"), f.setAttribute("tabIndex", "-1"), f.setAttribute("id", o), r ? (this._popper = Ee(this.input, f, {
            placement: "bottom-start"
          }), t.appendChild(f)) : (t.appendChild(f), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : c.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === "") {
            const _ = d.find(
              `[${K}]`,
              this._modal
            );
            a && (c.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              _,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const _ = document.querySelector(
              `${os}[${H}]`
            );
            c.addClass(_, this._classes.opacity), c.addStyle(this._hour, {
              pointerEvents: "none"
            }), c.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new $i(this._wrapper, {
            event: "keydown",
            condition: ({ key: _ }) => _ === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (_) => {
      let m = _;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (_) => {
      let m = _;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (_) => {
      const m = n(_);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (_) => {
      const m = i(_);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t += 1, o(t);
    }, l = () => {
      e += 1, r(e);
    }, p = () => {
      t -= 1, o(t);
    }, u = () => {
      e -= 1, r(e);
    }, f = (_) => {
      clearInterval(this._interval), this._interval = setInterval(_, 100);
    };
    oe.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${Sn}], [${In}]`,
      (_) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: g } = _, v = g === "mousedown" || g === "touchstart";
        m.closest(`[${Sn}]`) ? m.closest(`[${Sn}]`).parentNode.hasAttribute(ca) ? v ? f(a) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : a() : v ? f(l) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : l() : m.closest(`[${In}]`) && (m.closest(`[${In}]`).parentNode.hasAttribute(ca) ? v ? f(p) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : p() : v ? f(u) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : u());
      }
    ), h.on(window, ns, (_) => {
      const m = _.code, g = document.activeElement.hasAttribute(as), v = document.activeElement.hasAttribute(
        Ln
      ), b = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          _.preventDefault(), b || g ? (this._hour.focus(), a()) : v && l();
          break;
        case "ArrowDown":
          _.preventDefault(), b || g ? (this._hour.focus(), p()) : v && u();
          break;
      }
    });
  }
  _handleClose() {
    h.on(
      this._modal,
      "click",
      `[${$n}], [${kn}], [${la}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          c.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(la)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(H);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(kn) || t.hasAttribute(On) || t.hasAttribute($n) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    oe.on(
      this._modal,
      "click",
      `[${On}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, p = this._document.querySelector(
          `${rs}[${H}]`
        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, f = Number(this._hour.textContent), _ = f === 12 && i ? 0 : f, m = Number(this._minutes.textContent);
        e = Xt(e, a, i), t = Gt(t, l, i);
        let [g, v, b] = R(
          t,
          !1
        ), [C, y, E] = R(
          e,
          !1
        );
        C = C === "12" && i ? "00" : C, g = g === "12" && i ? "00" : g;
        const T = _ < Number(C), A = _ > Number(g);
        let w = !0;
        p && (w = b === p.textContent);
        let S = !0;
        p && (S = E === p.textContent);
        const k = m > v && _ === Number(g), x = m < y && _ === Number(C);
        if (this.input.setAttribute(H, ""), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (w && (A || k))
            return;
          if (b === "AM" && p.textContent === "PM")
            return;
        }
        e !== "" && (S && (T || x) || E === "PM" && p.textContent === "AM") || Mf(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(Dn), !o && r && this.input.focus(), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), h.trigger(this.input, "input.te.timepicker"), h.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    oe.on(
      this._modal,
      "mouseover mouseleave",
      `[${Kf}]`,
      ({ type: t, target: e }) => {
        const i = d.find(
          `[${Yf}]`,
          this._modal
        ), n = d.find(
          `[${jf}]`,
          this._modal
        ), o = (l, p) => l.forEach((u) => {
          if (p) {
            c.addClass(u, this._classes.opacity), u.setAttribute(H, "");
            return;
          }
          c.removeClass(u, this._classes.opacity), u.removeAttribute(H);
        }), a = e.hasAttribute(as) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    h.on(document, Jr, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(Ff)) {
        if (clearInterval(this._interval), c.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    Lf(
      "click",
      os,
      this._classes
    ), h.on(
      this._modal,
      "click",
      os,
      () => {
        const { format24: t } = this._options, e = d.find(
          os,
          this._modal
        ), i = d.find(
          `[${X}]`,
          this._modal
        ), n = d.find(
          `[${K}]`,
          this._modal
        ), o = d.find(
          `[${at}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {
          n.forEach((_) => _.remove()), i.forEach((_) => _.remove()), c.addClass(this._hand, this._classes.transform), setTimeout(() => {
            c.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(p, `[${ue}]`, u);
          const f = () => {
            const _ = d.find(
              `[${K}]`,
              this._modal
            ), m = d.find(
              `[${X}]`,
              this._modal
            );
            this._addActiveClassToTip(_, r), this._addActiveClassToTip(m, a);
          };
          if (!t)
            setTimeout(() => {
              f();
            }, 401);
          else {
            const _ = d.find(
              `[${at}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(_, r), f();
            }, 401);
          }
        };
        e.forEach((p) => {
          p.hasAttribute(H) && (p.hasAttribute(Ln) ? (c.addClass(this._hand, this._classes.transform), c.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(
            this.minutesArray,
            X
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : p.hasAttribute(as) && (c.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (c.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && c.addStyle(this._hand, {
            height: "21.5%"
          })) : c.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${ai}]`,
            at
          ), o.length > 0 && o.forEach((u) => u.remove()), l(
            this.hoursArray,
            K
          ), c.addStyle(this._hour, {
            pointerEvents: "none"
          }), c.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = d.find(
      `[${K}]`
    ), r = d.find(
      `[${at}]`
    ), a = d.find(
      `[${X}]`
    );
    if (!e || e === t) {
      qr(
        r,
        n,
        this._classes,
        this._options.format12
      ), qr(
        o,
        n,
        this._classes,
        this._options.format12
      ), Nf(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }), a.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = d.find(
      `[${K}]`
    ), r = d.find(
      `[${at}]`
    ), a = d.find(
      `[${X}]`
    );
    !e || e === t ? (Zr(
      o,
      n,
      this._classes,
      this._options.format12
    ), Zr(
      r,
      n,
      this._classes,
      this._options.format12
    ), Rf(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }), a.forEach((l) => {
      c.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, "");
    }));
  }
  _handleSwitchTimeMode() {
    h.on(
      document,
      "click",
      rs,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = Xt(i, n, r), e = Gt(e, o, r);
        const [a, l, p] = R(
          e,
          !1
        ), [u, f, _] = R(
          i,
          !1
        ), m = d.find(
          `[${K}]`
        ), g = d.find(
          `[${X}]`
        );
        (() => {
          m.forEach((b) => {
            c.removeClass(b, this._classes.tipsDisabled), b.removeAttribute(Yt);
          }), g.forEach((b) => {
            c.removeClass(b, this._classes.tipsDisabled), b.removeAttribute(Yt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          _,
          f,
          u
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          p,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(
          rs
        ).forEach((C) => {
          C.hasAttribute(H) && (c.removeClass(C, this._classes.opacity), C.removeAttribute(H));
        }), c.addClass(t, this._classes.opacity), t.setAttribute(H, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = Xt(e, i, o), t = Gt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(
      `[${da}]`
    );
    oe.on(
      document,
      `${ta} ${ea} ${ia} ${sa} ${na} ${aa} ${oa} ${ra}`,
      "",
      (f) => {
        ss() || f.preventDefault();
        const { type: _, target: m } = f, { closeModalOnMinutesClick: g, switchHoursToMinutesOnClick: v } = this._options, b = d.findOne(
          `[${X}]`,
          this._modal
        ) !== null, C = d.findOne(
          `[${K}]`,
          this._modal
        ) !== null, y = d.findOne(
          `[${at}]`,
          this._modal
        ) !== null, E = d.find(
          `[${X}]`,
          this._modal
        ), T = Gr(f, u), A = u.offsetWidth / 2;
        let w = Math.atan2(T.y - A, T.x - A);
        if (ss()) {
          const $ = Gr(f, u, !0);
          w = Math.atan2($.y - A, $.x - A);
        }
        let S = null, k = null, x = null;
        if (_ === "mousedown" || _ === "mousemove" || _ === "touchmove" || _ === "touchstart")
          (_ === "mousedown" || _ === "touchstart" || _ === "touchmove") && (this._hasTargetInnerClass(m) || m.hasAttribute(da) || m.hasAttribute(ue) || m.hasAttribute(X) || m.hasAttribute(K) || m.hasAttribute(Nn) || m.hasAttribute(Mn) || m.hasAttribute(ua) || m.hasAttribute(ls)) && (this._isMouseMove = !0, ss() && f.touches && (S = f.touches[0].clientX, k = f.touches[0].clientY, x = document.elementFromPoint(S, k)));
        else if (_ === "mouseup" || _ === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(m) || m.hasAttribute(ue) || m.hasAttribute(K) || m.hasAttribute(Nn) || m.hasAttribute(Mn) || m.hasAttribute(ua) || m.hasAttribute(ls)) {
            if ((C || y) && v) {
              const $ = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;
              if (this._options.format24 && l !== "" && p !== "" && $)
                return;
              if (this._options.format24 && p !== "" && Number(this._hour.textContent) < p)
                return;
            }
            h.trigger(this._minutes, "click");
          }
          if (b && g) {
            const $ = d.findOne(
              `[${On}]`,
              this._modal
            );
            h.trigger($, "click");
          }
        }
        if (b) {
          let $;
          const O = Math.trunc(w * 180 / Math.PI) + 90, { degrees: M, minute: P } = this._makeMinutesDegrees(O, $);
          if (this._handlerMaxMinMinutesOptions(M, P) === void 0)
            return;
          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions(M, P);
          if (this._isMouseMove) {
            if (c.addStyle(this._hand, {
              transform: `rotateZ(${tt}deg)`
            }), et === void 0)
              return;
            const U = () => et >= 10 || et === "00" ? et : `0${et}`;
            this._minutes.textContent = U(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              E
            ), this._toggleBackgroundColorCircle(
              `[${X}]`
            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;
          }
        }
        if (C || y) {
          let $, O = Math.trunc(w * 180 / Math.PI) + 90;
          if (O = Math.round(O / 30) * 30, c.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(m, O, $) === void 0)
            return;
          const M = () => {
            if (ss() && O && x) {
              const { degrees: P, hour: tt } = this._makeHourDegrees(x, O, $);
              return this._handleMoveHand(
                x,
                tt,
                P
              );
            } else {
              const { degrees: P, hour: tt } = this._makeHourDegrees(m, O, $);
              return this._handleMoveHand(m, tt, P);
            }
          };
          this._objWithDataOnChange.degreesHours = O, this._handlerMaxMinHoursOptions(
            O,
            l,
            p,
            r,
            a,
            f
          ) && M();
        }
        f.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(ai) || t.hasAttribute(at) || t.hasAttribute(cs);
  }
  _handleMoveHand(t, e, i) {
    const n = d.find(
      `[${K}]`,
      this._modal
    ), o = d.find(
      `[${at}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? c.addStyle(this._hand, {
      height: "21.5%"
    }) : c.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), c.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = Xt(n, a, o), i = Gt(i, l, o);
    const p = R(i, !1)[1], u = R(n, !1)[1], f = R(i, !1)[0], _ = R(n, !1)[0], m = _ === "12" && o ? "0" : _, g = f === "12" && o ? "0" : f, v = R(i, !1)[2], b = R(n, !1)[2], C = p !== "" ? p * 6 : "", y = u !== "" ? u * 6 : "", E = Number(this._hour.textContent), T = E === 12 && o ? 0 : E;
    if (!v && !b) {
      if (i !== "" && n !== "") {
        if (Number(g) === T && t > C || Number(m) === T && t < y)
          return t;
      } else if (n !== "" && T <= Number(m)) {
        if (t <= y - 6)
          return t;
      } else if (i !== "" && T >= Number(g) && t >= C + 6)
        return t;
    } else {
      if (n !== "") {
        if (b === "PM" && this._isAmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (T < Number(m))
            return;
          if (T <= Number(m) && t <= y - 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled) {
          if (T < Number(m))
            return;
          if (T <= Number(m) && t <= y - 6)
            return t;
        }
      }
      if (i !== "") {
        if (v === "AM" && this._isPmEnabled)
          return;
        if (v === "PM" && this._isPmEnabled) {
          if (T >= Number(g) && t >= C + 6)
            return t;
        } else if (v === "AM" && this._isAmEnabled && T >= Number(g) && t >= C + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), oe.off(
      this._document,
      `${Jr} ${ns} ${ta} ${ea} ${ia} ${sa} ${na} ${aa} ${oa} ${ra}`
    ), h.off(window, ns);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || c.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (c.addClass(i, this._classes.tipsActive), i.setAttribute(H, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${ue}]`,
        K
      ), this._getAppendClock(
        this.innerHours,
        `[${ai}]`,
        at
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${ue}]`,
      K
    );
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...Gf,
      ...e,
      ...t
    }, L(yi, t, qf), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...Zf,
      ...e,
      ...t
    }, L(yi, t, Qf), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getValidate(t) {
    const { invalidLabel: e, format24: i, format12: n, appendValidationInfo: o } = this._options;
    let r;
    o && (r = D("div"), r.setAttribute(ha, ""), c.addClass(r, this._classes.invalidFeedback), r.innerHTML = e), oe.on(this.input, t, ({ target: a }) => {
      if (this._options === null || this.input.value === "")
        return;
      const l = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, p = /^([01]\d|2[0-3])(:[0-5]\d)$/, u = l.test(a.value);
      if (p.test(a.value) !== !0 && i || u !== !0 && n) {
        o && (this.input.setAttribute(Dn, ""), this.input.parentNode.insertBefore(
          r,
          this.input.nextSibling
        )), c.addStyle(a, { marginBottom: 0 }), c.addStyle(r, { bottom: "-23px" }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(Dn), this._isInvalidTimeFormat = !1;
      const _ = d.findOne(
        `[${ha}]`
      );
      _ !== null && _.remove();
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, Ss);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Jf = {
  threshold: 10,
  direction: "all"
};
class tm {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...Jf,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      h.trigger(this._element, `swipe${r}`), h.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (h.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}
class em {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new tm(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
}
const _a = "sidenav", hs = "te.sidenav", im = "data-te-sidenav-rotate-icon-ref", Rn = "[data-te-sidenav-toggle-ref]", sm = "[data-te-collapse-init]", nm = '[data-te-sidenav-slim="true"]', om = '[data-te-sidenav-slim="false"]', rm = "[data-te-sidenav-menu-ref]", ke = "[data-te-sidenav-collapse-ref]", li = "[data-te-sidenav-link-ref]", am = F() ? 100 : -100, lm = F() ? -100 : 100, cm = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, hm = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class pi {
  constructor(t, e = {}) {
    At(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), h.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = bt(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === Li && this.toggler && Lt(this.toggler) && (this._update(!1), h.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (I.setData(t, hs, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && h.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return _a;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return d.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;
  }
  get links() {
    return d.find(li, this._element);
  }
  get navigation() {
    return d.find(rm, this._element);
  }
  get options() {
    const t = {
      ...hm,
      ...c.getDataAttributes(this._element),
      ...this._options
    };
    return L(_a, t, cm), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return d.find(Rn).find(
      (e) => {
        const i = c.getDataAttribute(e, "target");
        return d.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? lm : am;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    h.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), h.off(window, "hashchange", this.hashHandler), this._touch.dispose(), I.removeData(this._element, hs), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (h.on(
      document,
      "click",
      Rn,
      pi.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      d.find(ke, t).forEach((i) => {
        qt.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Lt(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return d.find(
      sm,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return d.find(ke, this._element).filter(
      (t) => Lt(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new So({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      h.on(t, "click", () => this._setActiveElements(t)), h.on(t, "keydown", (e) => {
        e.keyCode === lt && this._setActiveElements(t);
      });
    }), h.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      d.find(ke, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = d.prev(t, li);
    c.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = qt.getInstance(t) || new qt(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), h.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), h.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), h.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new $i(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === Oi,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), c.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = d.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = Vc(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      c.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new yc(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = Ue.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new Ue(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new em(this._element, "swipe", { threshold: 20 }), this._touch.init(), h.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), h.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = d.parents(
      this._activeNode,
      ke
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = d.prev(i, li);
    this._setActiveCategory(n), !e && !this._slimCollapsed && qt.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      d.find(ke, e).forEach((n) => {
        const [o] = d.prev(n, li);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      d.find(li, e).filter((n) => d.next(n, ke).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), c.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, c.style(n, l), !!t) {
        if (i) {
          c.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        h.on(n, "transitionend", () => {
          c.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), c.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = d.children(t, `[${im}]`);
    i && (e ? c.removeClass(i, "rotate-180") : c.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = d.find(
      nm,
      this._element
    ), i = d.find(
      om,
      this._element
    ), n = () => {
      e.forEach((o) => {
        c.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        c.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _isiPhone() {
    return /iPhone|iPod/i.test(navigator.userAgent);
  }
  _update(t) {
    t && this._isiPhone() && c.addClass(this._element, "ps--scrolling-y"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && h.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    c.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    h.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = d.closest(t.target, Rn), i = c.getDataAttributes(e).target;
      d.find(i).forEach((n) => {
        (pi.getInstance(n) || new pi(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, hs);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new pi(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, hs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const lo = "stepper", Is = "te.stepper", Ks = `.${Is}`, Mi = `data-te-${lo}`, _i = "horizontal", xt = "vertical", dm = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number"
}, um = {
  stepperType: _i,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4
}, fa = `mousedown${Ks}`, ma = `keydown${Ks}`, pm = `keyup${Ks}`, ga = `resize${Ks}`, jt = `[${Mi}-step-ref]`, G = `[${Mi}-head-ref]`, ba = `[${Mi}-head-text-ref]`, ds = `[${Mi}-head-icon-ref]`, st = `[${Mi}-content-ref]`;
class j0 {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${jt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (I.setData(t, Is, this), this._init());
  }
  // Getters
  static get NAME() {
    return lo;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      h.off(t, fa), h.off(t, ma);
    }), h.off(window, ga), I.removeData(this._element, Is), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = d.find(`${jt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = d.find(
      `${ba}`,
      this._element
    ), i = d.find(
      `${ds}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case xt:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...um,
      ...e,
      ...t
    }, L(lo, t, dm), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${G}`, t);
      h.on(e, fa, (i) => {
        const n = d.parents(i.target, `${jt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    h.on(window, ga, () => {
      this._currentView === xt && this._setSingleStepHeight(this.activeStep), this._currentView === _i && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== _i && this._toggleHorizontal(), e && !i && this._currentView !== xt && (this._steps.forEach((n) => {
      const o = d.findOne(`${st}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(
      d.findOne(`${st}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === _i ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      d.findOne(`${G}`, this.activeStep),
      d.findOne(`${G}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((e, i) => {
      e[this._activeStepIndex] !== i && e.removeAttribute("data-te");
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${st}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = d.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = xt, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = _i, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    d.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      d.findOne(`${st}`, e).classList.remove("!my-0"), d.findOne(`${st}`, e).classList.remove("!py-0"), d.findOne(`${st}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      d.findOne(`${G}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = d.findOne(`${G}`, t);
      h.on(e, ma, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${jt}`
        )[0], o = d.next(n, `${jt}`)[0], r = d.prev(n, `${jt}`)[0], a = d.findOne(
          `${G}`,
          n
        ), l = d.findOne(
          `${G}`,
          this.activeStep
        );
        let p = null, u = null;
        if (o && (p = d.findOne(`${G}`, o)), r && (u = d.findOne(`${G}`, r)), i.keyCode === Pe && this._currentView !== xt && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === Be && this._currentView !== xt && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === xt && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === rt && this._currentView === xt && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === He) {
          const f = d.findOne(
            `${G}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        if (i.keyCode === We) {
          const f = this._steps[this._steps.length - 1], _ = d.findOne(`${G}`, f);
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        (i.keyCode === lt || i.keyCode === ks) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === Oi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), h.on(e, pm, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${jt}`
        )[0], o = d.findOne(
          `${G}`,
          n
        ), r = d.findOne(
          `${G}`,
          this.activeStep
        );
        i.keyCode === Oi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = d.find(`${G}`, this._element), e = d.find(
      `${ds}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = d.find(
      `${ba}`,
      this._element
    ), i = d.find(
      `${ds}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = d.find(
      `${ds}`,
      this._element
    );
    e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700"), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      t.getAttribute("data-te") || this._hideElement(d.findOne(`${st}`, t));
    });
  }
  _setHeight(t) {
    const e = d.findOne(`${st}`, t), i = getComputedStyle(e), n = d.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !d.parents(
      t,
      `${jt}`
    )[0].getAttribute("data-te") && this._currentView !== xt || (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === xt ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    const e = t > this._activeStepIndex, i = d.findOne(
      `${st}`,
      this._steps[t]
    ), n = d.findOne(
      `${st}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((u, f) => {
      const _ = d.findOne(`${st}`, u);
      f !== t && f !== this._activeStepIndex && this._hideElement(_);
    });
    const a = "translate-x-[150%]", l = "-translate-x-[150%]", p = "translate-0";
    e ? (r = l, o = p, i.classList.remove("translate-x-[150%]"), i.classList.remove("-translate-x-[150%]")) : (r = a, o = p, i.classList.remove("-translate-x-[150%]"), i.classList.remove("translate-x-[150%]")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);
  }
  _animateVerticalStep(t) {
    const e = d.findOne(
      `${st}`,
      this._steps[t]
    ), i = d.findOne(
      `${st}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return I.getData(t, Is);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const va = "data-te-input-state-active", us = "data-te-input-selected", Ta = "data-te-input-multiple-active", Ea = "[data-te-form-check-input]";
class Ca {
  constructor(t, e, i, n, o, r, a, l, p, u, f) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = f, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(us, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = d.findOne(
        Ea,
        this.node
      );
      t.checked = !0, this.node.setAttribute(us, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(us), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = d.findOne(
        Ea,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(us), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(Ta, "");
        return;
      }
      this.active = !0, this.node.setAttribute(va, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(va)), this.multiple && this.node.removeAttribute(Ta);
  }
}
class _m {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function co(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const fm = "data-te-select-form-outline-ref", mm = "data-te-select-wrapper-ref", gm = "data-te-select-input-ref", bm = "data-te-select-clear-btn-ref", vm = "data-te-select-dropdown-container-ref", Tm = "data-te-select-dropdown-ref", Em = "data-te-select-options-wrapper-ref", Cm = "data-te-select-options-list-ref", Am = "data-te-select-input-filter-ref", ac = "data-te-select-option-ref", ym = "data-te-select-option-all-ref", wm = "data-te-select-option-text-ref", xm = "data-te-form-check-input", km = "data-te-select-option-group-ref", Om = "data-te-select-option-group-label-ref", lc = "data-te-select-selected", Sm = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, Im = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function ps(s, t, e, i, n) {
  t.selectSize === "default" && c.addClass(s, e), t.selectSize === "sm" && c.addClass(s, i), t.selectSize === "lg" && c.addClass(s, n);
}
function Dm(s, t, e, i) {
  const n = document.createElement("div");
  n.setAttribute("id", s), n.setAttribute(mm, "");
  const o = D("div");
  o.setAttribute(fm, ""), c.addClass(o, i.formOutline);
  const r = D("input"), a = t.selectFilter ? "combobox" : "listbox", l = t.multiple ? "true" : "false", p = t.disabled ? "true" : "false";
  r.setAttribute(gm, ""), c.addClass(r, i.selectInput), ps(
    r,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && c.addClass(r, i.selectInputWhite), r.setAttribute("type", "text"), r.setAttribute("role", a), r.setAttribute("aria-multiselectable", l), r.setAttribute("aria-disabled", p), r.setAttribute("aria-haspopup", "true"), r.setAttribute("aria-expanded", !1), t.tabIndex && r.setAttribute("tabIndex", t.tabIndex), t.disabled && r.setAttribute("disabled", ""), t.selectPlaceholder !== "" && r.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (c.addStyle(r, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), c.addStyle(o, { cursor: "pointer" })) : r.setAttribute("readonly", "true"), t.selectValidation && (r.setAttribute("required", "true"), r.setAttribute("aria-required", "true"), r.addEventListener("keydown", Im));
  const u = D("div");
  c.addClass(u, i.selectValidationValid);
  const f = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  u.appendChild(f);
  const _ = D("div");
  c.addClass(_, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  _.appendChild(m);
  const g = D("span");
  g.setAttribute(bm, ""), c.addClass(g, i.selectClearBtn), ps(
    g,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && c.addClass(g, i.selectClearBtnWhite);
  const v = document.createTextNode("â");
  g.appendChild(v), g.setAttribute("tabindex", "0");
  const b = D("span");
  return c.addClass(b, i.selectArrow), ps(
    b,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && c.addClass(b, i.selectArrowWhite), b.innerHTML = Sm, o.appendChild(r), e && (c.addClass(e, i.selectLabel), ps(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && c.addClass(e, i.selectLabelWhite), o.appendChild(e)), t.selectValidation && (o.appendChild(u), o.appendChild(_)), t.selectClearButton && o.appendChild(g), o.appendChild(b), n.appendChild(o), n;
}
function Aa(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(vm, ""), c.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const p = document.createElement("div");
  p.setAttribute("tabindex", 0), p.setAttribute(Tm, ""), c.addClass(p, a.dropdown);
  const u = D("div");
  u.setAttribute(Em, ""), c.addClass(u, a.optionsWrapper), c.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
  const f = cc(
    o,
    n,
    t,
    a
  );
  return u.appendChild(f), t.selectFilter && p.appendChild(
    $m(t.selectSearchPlaceholder, a)
  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
}
function cc(s, t, e, i) {
  const n = D("div");
  n.setAttribute(Cm, ""), c.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = Mm(
    s,
    t,
    e,
    i
  ) : o = Lm(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function $m(s, t) {
  const e = D("div");
  c.addClass(e, t.inputGroup);
  const i = D("input");
  return i.setAttribute(Am, ""), c.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function Lm(s, t, e) {
  return hc(s, t, e);
}
function Mm(s, t, e, i) {
  let n = null;
  e.selectAll && (n = Nm(
    t,
    s,
    e,
    i
  ));
  const o = hc(s, e, i);
  return n ? [n, ...o] : o;
}
function hc(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = Hm(n, t, e);
      i.push(r);
    } else
      i.push(dc(n, t, e));
  }), i;
}
function Nm(s, t, e, i) {
  const n = co(t), o = D("div");
  return o.setAttribute(ac, ""), c.addClass(o, i.selectOption), o.setAttribute(ym, ""), c.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(lc, ""), o.appendChild(uc(s, e, i)), s.setNode(o), o;
}
function dc(s, t, e) {
  if (s.node)
    return s.node;
  const i = D("div");
  return i.setAttribute(ac, ""), c.addClass(i, e.selectOption), c.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), c.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(lc, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && c.addClass(i, "hidden"), i.appendChild(uc(s, t, e)), s.icon && i.appendChild(Bm(s, e)), s.setNode(i), i;
}
function uc(s, t, e) {
  const i = D("span");
  i.setAttribute(wm, ""), c.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(Pm(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    Rm(s.secondaryText, e)
  ), i;
}
function Rm(s, t) {
  const e = D("span");
  c.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function Pm(s, t) {
  const e = D("input");
  e.setAttribute("type", "checkbox"), c.addClass(e, t.formCheckInput), e.setAttribute(xm, "");
  const i = D("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function Bm(s, t) {
  const e = D("span"), i = D("img");
  return c.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function Hm(s, t, e) {
  const i = D("div");
  i.setAttribute(km, ""), c.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && c.addClass(i, "hidden");
  const n = D("label");
  return n.setAttribute(Om, ""), c.addClass(n, e.selectOptionGroupLabel), c.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild(dc(o, t, e));
  }), i;
}
function Wm(s, t) {
  const e = D("div");
  return e.innerHTML = s, c.addClass(e, t.selectLabel), c.addClass(e, t.selectFakeValue), e;
}
const Pn = "select", fi = "te.select", Ni = `.${fi}`, Vm = `close${Ni}`, Fm = `open${Ni}`, ya = `optionSelect${Ni}`, wa = `optionDeselect${Ni}`, Ym = `valueChange${Ni}`, jm = "change", xa = "data-te-select-init", pc = "data-te-select-no-results-ref", ka = "data-te-select-open", q = "data-te-input-state-active", Kt = "data-te-input-focused", Bn = "data-te-input-disabled", Km = "data-te-select-option-group-label-ref", zm = "data-te-select-option-all-ref", ci = "data-te-select-selected", Um = "[data-te-select-label-ref]", Oa = "[data-te-select-input-ref]", Xm = "[data-te-select-input-filter-ref]", Gm = "[data-te-select-dropdown-ref]", qm = "[data-te-select-options-wrapper-ref]", Sa = "[data-te-select-options-list-ref]", Zm = "[data-te-select-option-ref]", Qm = "[data-te-select-clear-btn-ref]", Jm = "[data-te-select-custom-content-ref]", tg = `[${pc}]`, Ia = "[data-te-select-form-outline-ref]", eg = "[data-te-select-toggle]", Hn = "[data-te-input-notch-ref]", ig = 200, sg = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, ng = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, og = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, rg = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class $o {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new _m(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = bt("select-wrapper-"), this._dropdownContainerId = bt("select-dropdown-container-"), this._selectAllId = bt("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Um)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(
      t,
      Jm
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && I.setData(t, fi, this);
  }
  static get NAME() {
    return Pn;
  }
  get filterInput() {
    return d.findOne(
      Xm,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return d.findOne(Gm, this._dropdownContainer);
  }
  get optionsList() {
    return d.findOne(
      Sa,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return d.findOne(
      qm,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return d.findOne(Qm, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...sg,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), L(Pn, t, ng), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...og,
      ...e,
      ...t
    }, L(Pn, t, rg), t;
  }
  _addPlaceholderOption() {
    const t = new Option("", "", !0, !0);
    t.hidden = !0, t.selected = !0, this._element.prepend(t);
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: bt("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!d.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = bt("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(ci), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t.value, f = t.label, _ = c.getDataAttribute(
      t,
      "selectSecondaryText"
    ), m = c.getDataAttribute(t, "select-icon");
    return new Ca(
      i,
      t,
      p,
      u,
      f,
      r,
      a,
      l,
      _,
      n,
      m
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(Oa, this._wrapper), this._config.disabled && this._input.setAttribute(Bn, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = Aa(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = Dm(
      this._wrapperId,
      this._config,
      this._label,
      this._classes
    );
    this._element.parentNode.insertBefore(t, this._element), c.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = d.findOne(
      Ia,
      this._wrapper
    );
    new W(
      t,
      {
        inputFormWhite: this._config.selectFormWhite
      },
      this._classes
    ).init(), this._notch = d.findOne(Hn, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    h.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === Li || e === rt && t.altKey || e === Oi;
    if (e === Oi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case rt:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case He:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case We:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case lt:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === lt && t.preventDefault(), (e === lt || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case z:
          this.open();
          break;
        case rt:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case z:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case rt:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case He:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case We:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((u) => !u.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
    if (e > -1) {
      const u = o * l, f = u + l > p + a;
      u < p ? r.scrollTop = u : f ? r.scrollTop = u - a + l : r.scrollTop = p;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    h.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    h.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    h.on(this.clearButton, "keydown", (t) => {
      t.keyCode === lt && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._fakeValue.innerHTML = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    h.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        Km
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : d.closest(t.target, Zm);
      if (i.hasAttribute(zm)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(ci, !1), h.trigger(this._element, wa, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(ci, !0), h.trigger(this._element, ya, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(ci, !1), h.trigger(this._element, wa, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(ci, !0), h.trigger(this._element, ya, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    h.trigger(this._element, Ym, { value: t });
  }
  _emitNativeChangeEvent() {
    h.trigger(this._element, jm);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = Wm(t, this._classes), d.findOne(
      Ia,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(xa), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? c.addStyle(this.clearButton, { display: "block" }) : c.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = co(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = h.trigger(this._element, Fm);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = Ee(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(ka, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    c.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(Kt, ""), d.findOne(Hn, this._wrapper).setAttribute(
      Kt,
      ""
    );
  }
  _listenToWindowResize() {
    h.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = d.findOne(Sa, this._dropdownContainer) || d.findOne(tg, this._dropdownContainer), i = cc(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${pc} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    h.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), h.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      h.off(
        this._input,
        "focus",
        () => this._notch.setAttribute(Kt, "")
      ), h.off(
        this._input,
        "blur",
        () => this._notch.removeAttribute(Kt)
      );
      return;
    }
    h.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(Kt, "")
    ), h.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(Kt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = d.find(eg)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = c.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = h.trigger(this._element, Vm);
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(ka), setTimeout(() => {
      this._input.removeAttribute(Kt), this._input.blur(), d.findOne(Hn, this._wrapper).removeAttribute(
        Kt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, h.off(this.dropdown, "transitionend");
    }, ig));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    h.off(document, "click", this._outsideClick), this._config.selectFilter && h.off(this.dropdown, "keydown"), h.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = Aa(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = d.findOne(Oa, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(Bn, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(Bn));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = co(this.options), a = !1, l = !1, p = null, u = null, f = null;
    return new Ca(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      f
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), I.removeData(this._element, fi);
  }
  _removeComponentEvents() {
    h.off(this.input, "click"), h.off(this.wrapper, this._handleKeydown.bind(this)), h.off(this.clearButton, "click"), h.off(this.clearButton, "keydown"), h.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = d.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(q);
    }), c.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(xa), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, fi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new $o(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, fi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ag = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>
      </div>
    </div>`, lg = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, Ds = "chip", cg = `te.${Ds}`, _c = "data-te-chip-close", Wn = `[${_c}]`, hg = "delete.te.chips", dg = "select.te.chip", ug = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', pg = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, _g = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: ug
}, fg = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, mg = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class hi {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return Ds;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, h.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return lg({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(d.find(Wn, this._element).length > 0) && this._options.closeIcon) {
      const e = D("span");
      e.classList = this._classes.icon, e.setAttribute(_c), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    h.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), h.trigger(dg, { event: t, obj: i });
    });
  }
  _handleDelete() {
    d.find(
      Wn,
      this._element
    ).length !== 0 && h.on(this._element, "click", Wn, () => {
      h.trigger(this._element, hg), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ..._g,
      ...c.getDataAttributes(this._element),
      ...t
    };
    return L(Ds, e, pg), e;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...fg,
      ...e,
      ...t
    }, L(Ds, t, mg), t;
  }
  static getInstance(t) {
    return I.getData(t, cg);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const wi = "chips", Ri = `data-te-${wi}`, Da = `te.${wi}`, gg = `${Ri}-input-init`, ft = `${Ri}-active`, $a = `${Ri}-initial`, fc = `${Ri}-placeholder`, bg = `${Ri}-input-wrapper`, ho = "data-te-chip-init", mc = "data-te-chip-close", gc = "data-te-chip-text", vg = `[${ft}]`, uo = `[${ho}]`, Tg = `${uo}${vg}`, Vn = `[${mc}]`, Eg = `[${bg}]`, Cg = `[${gc}]`, Ag = `[${fc}]`, yg = "data-te-input-notch-leading-ref", wg = "data-te-input-notch-middle-ref", xg = `[${yg}]`, kg = `[${wg}]`, Oe = "data-te-input-state-active", Fn = "[data-te-input-notch-ref]", Og = "add.te.chips", Sg = "arrowDown.te.chips", Ig = "arrowLeft.te.chips", Dg = "arrowRight.te.chips", $g = "arrowUp.te.chips", La = "delete.te.chips", Ma = "select.te.chips", Lg = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string",
  inputClasses: "object",
  inputOptions: "object"
}, Mg = {
  inputID: bt("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label",
  inputClasses: {},
  inputOptions: {}
}, Ng = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200"
}, Rg = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string"
};
class K0 extends hi {
  constructor(e, i = {}, n) {
    super(e, i);
    At(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(ft, ""), this.input.setAttribute(Oe, ""), d.findOne(
        Fn,
        this.input.parentNode
      ).setAttribute(Oe, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(ft), this.input.removeAttribute(Oe), d.findOne(
        Fn,
        this.input.parentNode
      ).removeAttribute(Oe), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(ft));
    });
    this._element = e, this._inputInstance = null, this._element && I.setData(e, Da, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return wi;
  }
  get activeChip() {
    return d.findOne(Tg, this._element);
  }
  get input() {
    return d.findOne("input", this._element);
  }
  get allChips() {
    return d.find(uo, this._element);
  }
  get chipsInputWrapper() {
    return d.findOne(Eg, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(fc), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = d.findOne(
      kg,
      this._element
    ), this._notchLeading = d.findOne(
      xg,
      this._element
    );
  }
  _setChipsClass() {
    this._element.setAttribute(gg, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, La);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, La), this.numberClicks = n, o.setAttribute(ft, ""), this.allChips.forEach((a) => {
        a.hasAttribute(ft) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, Dg), this._handleEvents(e, $g);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, Ig), this._handleEvents(e, Sg);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === I_ || n === D_ ? this._handleDeleteEvents(e) : n === Be || n === rt ? this._handleUpEvents(e) : n === Pe || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    h.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      h.on(i, "dblclick", (n) => {
        const o = d.findOne(Vn, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          c.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, h.trigger(i, Ma, {
          event: n,
          allChips: this.allChips
        });
      }), h.on(document, "click", ({ target: n }) => {
        const o = d.findOne(Vn, i), r = d.findOne(Cg, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          c.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(ft));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(ft, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    h.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(ft));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(ft) && r
    );
    h.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    h.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e];
      i.includes(ho) || i.includes(mc) || i.includes(gc) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement($a), this._element.hasAttribute($a)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), d.findOne(
        Fn,
        this.input.parentNode
      ).setAttribute(Oe, ""), this.input.setAttribute(ft, ""), this.input.setAttribute(Oe, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(ho)) {
      const o = d.findOne(Vn, n);
      i === lt && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        c.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === lt) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Og);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = d.findOne(
      Ag,
      this._element
    );
    h.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), h.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = ag(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
    const n = d.findOne(
      "[data-te-chips-input-wrapper]",
      this._element
    );
    this._inputInstance = new W(
      n,
      this._options.inputOptions,
      this._options.inputClasses
    );
  }
  _handleCreateChip(e, i) {
    const n = D("div"), o = hi.getInstance(n), r = new hi(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", d.find(uo).forEach((a) => {
      let l = hi.getInstance(a);
      return l || (l = new hi(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      h.on(this._element, "click", (i) => {
        h.trigger(e, Ma, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(ft);
  }
  _getConfig(e) {
    const i = {
      ...Mg,
      ...c.getDataAttributes(this._element),
      ...e
    };
    return L(wi, i, Lg), i;
  }
  _getClasses(e) {
    const i = c.getDataClassAttributes(this._element);
    return e = {
      ...Ng,
      ...i,
      ...e
    }, L(wi, e, Rg), e;
  }
  static getInstance(e) {
    return I.getData(e, Da);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
const zt = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, mi = {
  line: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...zt,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...zt,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...zt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...zt,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
};
var Pg = function(t) {
  return Bg(t) && !Hg(t);
};
function Bg(s) {
  return !!s && typeof s == "object";
}
function Hg(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Fg(s);
}
var Wg = typeof Symbol == "function" && Symbol.for, Vg = Wg ? Symbol.for("react.element") : 60103;
function Fg(s) {
  return s.$$typeof === Vg;
}
function Yg(s) {
  return Array.isArray(s) ? [] : {};
}
function Si(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? Xe(Yg(s), s, t) : s;
}
function jg(s, t, e) {
  return s.concat(t).map(function(i) {
    return Si(i, e);
  });
}
function Kg(s, t) {
  if (!t.customMerge)
    return Xe;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : Xe;
}
function zg(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function Na(s) {
  return Object.keys(s).concat(zg(s));
}
function bc(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function Ug(s, t) {
  return bc(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function Xg(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && Na(s).forEach(function(n) {
    i[n] = Si(s[n], e);
  }), Na(t).forEach(function(n) {
    Ug(s, n) || (bc(s, n) && e.isMergeableObject(t[n]) ? i[n] = Kg(n, e)(s[n], t[n], e) : i[n] = Si(t[n], e));
  }), i;
}
function Xe(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || jg, e.isMergeableObject = e.isMergeableObject || Pg, e.cloneUnlessOtherwiseSpecified = Si;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : Xg(s, t, e) : Si(t, e);
}
Xe.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return Xe(i, n, e);
  }, {});
};
var Gg = Xe, po = Gg;
const Ra = "chart", _s = "te.chart", qg = "chart", Yn = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, p) => {
      typeof a[p] > "u" ? a[p] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[p] = po(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return po(e[t], s, {
    arrayMerge: i
  });
}, Zg = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkMode: null,
  darkBgColor: "#262626",
  darkBgColorLight: "#fff",
  options: null
}, Qg = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkMode: "(string|null)",
  darkBgColor: "string",
  darkBgColorLight: "string",
  options: "(object|null)"
};
class vc {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: p,
      PieController: u,
      PolarAreaController: f,
      RadarController: _,
      ScatterController: m,
      CategoryScale: g,
      LinearScale: v,
      LogarithmicScale: b,
      RadialLinearScale: C,
      TimeScale: y,
      TimeSeriesScale: E,
      Decimation: T,
      Filler: A,
      Legend: w,
      Title: S,
      Tooltip: k,
      SubTitle: x
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pnpm_tw-elements_1_0_0-beta3_postcss_8_4_27_node_modules_tw-elements_dis-1a3bf9").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/chart.es.js")).then(($) => $.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      f,
      _,
      m,
      g,
      v,
      b,
      C,
      y,
      E,
      T,
      A,
      w,
      S,
      k,
      x
    ), t;
  }
  async _getChartDataLabels() {
    return await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_pnpm_tw-elements_1_0_0-beta3_postcss_8_4_27_node_modules_tw-elements_dis-1a3bf9"), __webpack_require__.e("vendors-node_modules_pnpm_tw-elements_1_0_0-beta3_postcss_8_4_27_node_modules_tw-elements_dis-5bd434")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/.pnpm/tw-elements@1.0.0-beta3_postcss@8.4.27/node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (I.setData(t, _s, this), c.addClass(this._element, qg), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {
      const o = this._darkOptions.darkMode === "dark" ? "dark" : this._darkOptions.darkMode === "light" ? "light" : this.systemColorMode;
      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
        attributes: !0
      });
    }
  }
  // Getters
  static get NAME() {
    return Ra;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), I.removeData(this._element, _s), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);
    const i = Object.prototype.hasOwnProperty.call(
      e,
      "options"
    ) ? e : { options: { ...e } };
    this._options = po(this._options, i), this._chart.options = Yn(
      this._options,
      this._type,
      mi
    ).options, this._chart.update();
  }
  setTheme(t) {
    t !== "dark" && t !== "light" || !this._data || this._handleMode(t);
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = c.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (p) => p.startsWith("dark") && (e[p] = i[p])
    ), e = {
      ...Zg,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, L(Ra, t, Qg), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = Yn(this._options, this._type, mi), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = D("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, _s);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? Yn(e, i, mi) : mi[i];
          n = new vc(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, _s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function $t(s) {
  return getComputedStyle(s);
}
function ot(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function fs(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Pa = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Zt(s, t) {
  if (!Pa)
    throw new Error("No element matching method supported");
  return Pa.call(s, t);
}
function Ne(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Ba(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return Zt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, Tc = { x: null, y: null };
function Ec(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(Tc[t]) : e.add(i);
}
function Cc(s, t) {
  Tc[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function Jg(s, t) {
  Ec(s, t), Cc(s, t);
}
var Pi = function(t) {
  this.element = t, this.handlers = {};
}, Ac = { isEmpty: { configurable: !0 } };
Pi.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
Pi.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
Pi.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ac.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Pi.prototype, Ac);
var Je = function() {
  this.eventElements = [];
};
Je.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new Pi(t), this.eventElements.push(e)), e;
};
Je.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
Je.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
Je.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Je.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function ms(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function Bs(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  tb(s, e, o, i, n);
}
function tb(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var f = s.element;
  s.reach[l] = null, f[a] < 1 && (s.reach[l] = "start"), f[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (f.dispatchEvent(ms("ps-scroll-" + l)), t < 0 ? f.dispatchEvent(ms("ps-scroll-" + p)) : t > 0 && f.dispatchEvent(ms("ps-scroll-" + u)), i && Jg(s, l)), s.reach[l] && (t || n) && f.dispatchEvent(ms("ps-" + l + "-reach-" + s.reach[l]));
}
function V(s) {
  return parseInt(s, 10) || 0;
}
function eb(s) {
  return Zt(s, "input,[contenteditable]") || Zt(s, "select,[contenteditable]") || Zt(s, "textarea,[contenteditable]") || Zt(s, "button,[contenteditable]");
}
function ib(s) {
  var t = $t(s);
  return V(t.width) + V(t.paddingLeft) + V(t.paddingRight) + V(t.borderLeftWidth) + V(t.borderRightWidth);
}
var $e = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Bt(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Ba(t, j.element.rail("x")).forEach(
    function(n) {
      return Ne(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Ba(t, j.element.rail("y")).forEach(
    function(n) {
      return Ne(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Ha(
    s,
    V(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = V(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Ha(
    s,
    V(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = V(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), sb(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function Ha(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function sb(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ot(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function nb(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Bt(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Bt(s), t.stopPropagation();
  });
}
function ob(s) {
  Wa(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Wa(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Wa(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], f = s.element, _ = null, m = null, g = null;
  function v(y) {
    y.touches && y.touches[0] && (y[n] = y.touches[0].pageY), f[l] = _ + g * (y[n] - m), Ec(s, p), Bt(s), y.stopPropagation(), y.type.startsWith("touch") && y.changedTouches.length > 1 && y.preventDefault();
  }
  function b() {
    Cc(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", v);
  }
  function C(y, E) {
    _ = f[l], E && y.touches && (y[n] = y.touches[0].pageY), m = y[n], g = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, "touchmove", v) : (s.event.bind(s.ownerDocument, "mousemove", v), s.event.once(s.ownerDocument, "mouseup", b), y.preventDefault()), s[u].classList.add(j.state.clicking), y.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(y) {
    C(y);
  }), s.event.bind(s[r], "touchstart", function(y) {
    C(y, !0);
  });
}
function rb(s) {
  var t = s.element, e = function() {
    return Zt(t, ":hover");
  }, i = function() {
    return Zt(s.scrollbarX, ":focus") || Zt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (eb(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());
    }
  });
}
function ab(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, f = t.scrollLeft === 0, _ = t.scrollLeft + t.offsetWidth === t.scrollWidth, m;
    return Math.abs(a) > Math.abs(r) ? m = p || u : m = f || _, m ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!$e.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var p = r; p && p !== t; ) {
      if (p.classList.contains(j.element.consuming))
        return !0;
      var u = $t(p);
      if (l && u.overflowY.match(/(scroll|auto)/)) {
        var f = p.scrollHeight - p.clientHeight;
        if (f > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < f && l > 0))
          return !0;
      }
      if (a && u.overflowX.match(/(scroll|auto)/)) {
        var _ = p.scrollWidth - p.clientWidth;
        if (_ > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < _ && a > 0))
          return !0;
      }
      p = p.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], p = a[1];
    if (!n(r.target, l, p)) {
      var u = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function lb(s) {
  if (!$e.supportsTouch && !$e.supportsIePointer)
    return;
  var t = s.element;
  function e(g, v) {
    var b = Math.floor(t.scrollTop), C = t.scrollLeft, y = Math.abs(g), E = Math.abs(v);
    if (E > y) {
      if (v < 0 && b === s.contentHeight - s.containerHeight || v > 0 && b === 0)
        return window.scrollY === 0 && v > 0 && $e.isChrome;
    } else if (y > E && (g < 0 && C === s.contentWidth - s.containerWidth || g > 0 && C === 0))
      return !0;
    return !0;
  }
  function i(g, v) {
    t.scrollTop -= v, t.scrollLeft -= g, Bt(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function p(g) {
    return g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function u(g) {
    if (p(g)) {
      var v = l(g);
      n.pageX = v.pageX, n.pageY = v.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function f(g, v, b) {
    if (!t.contains(g))
      return !1;
    for (var C = g; C && C !== t; ) {
      if (C.classList.contains(j.element.consuming))
        return !0;
      var y = $t(C);
      if (b && y.overflowY.match(/(scroll|auto)/)) {
        var E = C.scrollHeight - C.clientHeight;
        if (E > 0 && (C.scrollTop > 0 && b < 0 || C.scrollTop < E && b > 0))
          return !0;
      }
      if (v && y.overflowX.match(/(scroll|auto)/)) {
        var T = C.scrollWidth - C.clientWidth;
        if (T > 0 && (C.scrollLeft > 0 && v < 0 || C.scrollLeft < T && v > 0))
          return !0;
      }
      C = C.parentNode;
    }
    return !1;
  }
  function _(g) {
    if (p(g)) {
      var v = l(g), b = { pageX: v.pageX, pageY: v.pageY }, C = b.pageX - n.pageX, y = b.pageY - n.pageY;
      if (f(g.target, C, y))
        return;
      i(C, y), n = b;
      var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;
      T > 0 && (r.x = C / T, r.y = y / T, o = E), e(C, y) && g.preventDefault();
    }
  }
  function m() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  $e.supportsTouch ? (s.event.bind(t, "touchstart", u), s.event.bind(t, "touchmove", _), s.event.bind(t, "touchend", m)) : $e.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", u), s.event.bind(t, "pointermove", _), s.event.bind(t, "pointerup", m)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", u), s.event.bind(t, "MSPointerMove", _), s.event.bind(t, "MSPointerUp", m)));
}
var cb = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, hb = {
  "click-rail": nb,
  "drag-thumb": ob,
  keyboard: rb,
  wheel: ab,
  touch: lb
}, Bi = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = cb();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = $t(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var p = t.scrollLeft, u = null;
    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Je(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = fs(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = fs(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = $t(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = V(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = V(a.borderLeftWidth) + V(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = V(a.marginLeft) + V(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = fs(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = fs(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = $t(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = V(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? ib(this.scrollbarY) : null, this.railBorderYWidth = V(l.borderTopWidth) + V(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = V(l.marginTop) + V(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {
    return hb[p](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
    return i.onScroll(p);
  }), Bt(this);
};
Bi.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = V($t(this.scrollbarXRail).marginLeft) + V($t(this.scrollbarXRail).marginRight), this.railYMarginHeight = V($t(this.scrollbarYRail).marginTop) + V($t(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Bt(this), Bs(this, "top", 0, !1, !0), Bs(this, "left", 0, !1, !0), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
};
Bi.prototype.onScroll = function(t) {
  this.isAlive && (Bt(this), Bs(this, "top", this.element.scrollTop - this.lastScrollTop), Bs(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Bi.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Ne(this.scrollbarX), Ne(this.scrollbarY), Ne(this.scrollbarXRail), Ne(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Bi.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const jn = "perfectScrollbar", db = "perfect-scrollbar", gs = "te.perfectScrollbar", kt = "te", Ot = "ps", Kn = [
  { te: `scrollX.${kt}.${Ot}`, ps: "ps-scroll-x" },
  { te: `scrollY.${kt}.${Ot}`, ps: "ps-scroll-y" },
  { te: `scrollUp.${kt}.${Ot}`, ps: "ps-scroll-up" },
  { te: `scrollDown.${kt}.${Ot}`, ps: "ps-scroll-down" },
  { te: `scrollLeft.${kt}.${Ot}`, ps: "ps-scroll-left" },
  { te: `scrollRight.${kt}.${Ot}`, ps: "ps-scroll-right" },
  { te: `scrollXEnd.${kt}.${Ot}`, ps: "ps-x-reach-end" },
  { te: `scrollYEnd.${kt}.${Ot}`, ps: "ps-y-reach-end" },
  { te: `scrollXStart.${kt}.${Ot}`, ps: "ps-x-reach-start" },
  { te: `scrollYStart.${kt}.${Ot}`, ps: "ps-y-reach-start" }
], ub = {
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  wheelSpeed: 1,
  wheelPropagation: !0,
  swipeEasing: !0,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  scrollingThreshold: 1e3,
  useBothWheelAxes: !1,
  suppressScrollX: !1,
  suppressScrollY: !1,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  positionRight: !0
}, pb = {
  handlers: "(string|array)",
  wheelSpeed: "number",
  wheelPropagation: "boolean",
  swipeEasing: "boolean",
  minScrollbarLength: "(number|null)",
  maxScrollbarLength: "(number|null)",
  scrollingThreshold: "number",
  useBothWheelAxes: "boolean",
  suppressScrollX: "boolean",
  suppressScrollY: "boolean",
  scrollXMarginOffset: "number",
  scrollYMarginOffset: "number",
  positionRight: "boolean"
}, _b = {
  ps: "group/ps overflow-hidden [overflow-anchor:none] touch-none",
  railX: "group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railXColors: "group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railXThumb: "absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none",
  railXThumbColors: "bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]",
  railY: "group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railYColors: "group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railYThumb: "absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none",
  railYThumbColors: "bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]"
}, fb = {
  ps: "string",
  railX: "string",
  railXColors: "string",
  railXThumb: "string",
  railXThumbColors: "string",
  railY: "string",
  railYColors: "string",
  railYThumb: "string",
  railYThumbColors: "string"
};
class Lo {
  constructor(t, e = {}, i = {}) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [
      {
        ps: "ps__rail-x",
        te: this._classes.railX,
        teColor: this._classes.railXColors
      },
      {
        ps: "ps__rail-y",
        te: this._classes.railY,
        teColor: this._classes.railYColors
      },
      {
        ps: "ps__thumb-x",
        te: this._classes.railXThumb,
        teColor: this._classes.railXThumbColors
      },
      {
        ps: "ps__thumb-y",
        te: this._classes.railYThumb,
        teColor: this._classes.railYThumbColors
      }
    ], this._element && (I.setData(t, gs, this), c.addClass(this._element, db)), this.init();
  }
  // Getters
  static get NAME() {
    return jn;
  }
  get railX() {
    return d.findOne(".ps__rail-x", this._element);
  }
  get railY() {
    return d.findOne(".ps__rail-y", this._element);
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return e.handlers !== void 0 && (e.handlers = e.handlers.split(" ")), t = {
      ...ub,
      ...e,
      ...t
    }, L(jn, t, pb), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ..._b,
      ...e,
      ...t
    }, L(jn, t, fb), t;
  }
  // Public
  dispose() {
    this._options.positionRight && this._observer.disconnect(), I.removeData(this._element, gs), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(Kn), this.perfectScrollbar = null;
  }
  init() {
    if (this.perfectScrollbar = new Bi(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(Kn), this._options.positionRight) {
      this._observer = new ResizeObserver(() => {
        setTimeout(() => {
          this._updateScrollPosition();
        }, 100);
      });
      const t = {
        attributes: !0,
        attributeFilter: ["class", "className"]
      };
      this._observer.observe(this._element, t);
    }
  }
  _updateScrollPosition() {
    const t = getComputedStyle(this._element).getPropertyValue("height"), e = getComputedStyle(this._element).getPropertyValue("width");
    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : "0px"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : "0px"}))`);
  }
  _canTransform(t) {
    return t && t.includes("px");
  }
  update() {
    return this.perfectScrollbar.update();
  }
  _initEvents(t = []) {
    t.forEach(
      ({ ps: e, te: i }) => h.on(
        this._element,
        e,
        (n) => h.trigger(this._element, i, { e: n })
      )
    );
  }
  _addPerfectScrollbarStyles() {
    this._psClasses.forEach((t) => {
      const e = d.findOne(`.${t.ps}`, this._element);
      c.addClass(e, t.te), c.addClass(e, t.teColor);
    }), c.addClass(this._element, this._classes.ps), c.removeClass(this._element, "ps");
  }
  removeEvent(t) {
    let e = [];
    typeof t == "string" && (e = Kn.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {
      h.off(this._element, i), h.off(this._element, n);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = I.getData(this, gs);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new Lo(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, gs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const yc = Lo, mb = "data-te-datatable-select-ref", gb = "data-te-datatable-pagination-nav-ref", bb = "data-te-datatable-pagination-right-ref", vb = "data-te-datatable-pagination-left-ref", Tb = "data-te-datatable-pagination-start-ref", Eb = "data-te-datatable-pagination-end-ref", Cb = ({
  text: s,
  entries: t,
  entriesOptions: e,
  fullPagination: i,
  rowsText: n,
  allText: o,
  paginationStartIconTemplate: r,
  paginationLeftIconTemplate: a,
  paginationRightIconTemplate: l,
  paginationEndIconTemplate: p,
  classes: u
}, f, _) => {
  const m = e.map((g) => g === "All" ? `<option value="${g}" ${g === t ? "selected" : ""}>${o}</option>` : `<option value="${g}" ${g === t ? "selected" : ""}>${g}</option>`).join(`
`);
  return `
<div class="${u.pagination} ${_ ? `${u.paginationBordered}` : ""} ${u.borderColor} ${u.color}">
  <div class="${u.selectItemsWrapper}">  
    <p class="${u.paginationRowsText} ${f ? `${u.loadingPaginationRowsText}` : ""}">${n}</p>
    <div class="${u.selectWrapper} ${f ? `${u.loadingPaginationSelectWrapper}` : ""}">
      <select name="entries"
        ${f ? "disabled" : ""} class="select" ${mb}>
        ${m}
      </select>
    </div>
  </div>
  <div class="${u.paginationNav} ${f ? `${u.loadingPaginationNav}` : ""}" ${gb}>
  ${s}
  </div>
  <div class="${u.paginationButtonsWrapper}">
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationStartButton}" ${Tb}>
           ${r}
          </button>` : ""}
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationLeftButton}" ${vb}>
      ${a}
  </button>
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationRightButton}" ${bb}>
      ${l}
  </button>
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationEndButton}" ${Eb}>
           ${p}
          </button>` : ""}
  </div>
</div>
`;
}, Ab = "data-te-datatable-sort-icon-ref", yb = "data-te-datatable-header-checkbox-ref", wb = (s, t, e, i, n, o, r, a) => {
  const l = e ? `
  <th scope="col">
    <div class="${a.checkboxHeaderWrapper}">
      <input
        class="${a.checkboxHeader}"
        type="checkbox"
        value=""
        ${yb}
        />
    </div>
  </th>
  ` : '<th scope="col"></th>', p = s.map((u, f) => {
    const _ = u.fixed ? s.filter((m, g) => m.fixed === u.fixed && g < f).reduce((m, g) => m + g.width, 0) : null;
    return `<th class="${a.column} ${i ? `${a.tableBordered}` : ""} ${a.borderColor} ${n ? `${a.sm}` : ""} ${u.fixed ? `${a.fixedHeader} ${a.color}` : ""} ${o ? `${a.loadingColumn}` : ""}" style="${u.fixed ? `${u.fixed === "right" ? "right" : "left"}: ${_}px;` : ""}" scope="col">${u.sort ? `<div class="${a.sortIconWrapper}"><span class="${a.sortIcon} ${o ? "invisible" : ""}" data-te-sort="${u.field}" ${Ab}>${r}</span>` : ""} <span class="${u.sort ? "" : "pl-[18px]"}">${u.label}</span></div></th>`;
  });
  return [t ? l : "", ...p].join(`
`);
}, xb = "data-te-datatable-row-ref", kb = "data-te-datatable-row-checkbox-ref", Ob = "data-te-datatable-cell-ref", Sb = ({
  rows: s,
  columns: t,
  noFoundMessage: e,
  edit: i,
  selectable: n,
  loading: o,
  bordered: r,
  borderless: a,
  striped: l,
  hover: p,
  sm: u,
  classes: f
}) => {
  const _ = s.map((m) => {
    const g = `
      <td data-te-field="checkbox" class="${r ? `${f.tableBordered} ${f.borderColor}` : ""}">
        <div class="${f.checkboxRowWrapper}">
          <input
            class="${f.checkboxRow}"
            type="checkbox"
            value=""
            data-te-row-index="${m.rowIndex}"  ${kb}/>
        </div>
      </td>`, v = t.map((b, C) => {
      const y = {};
      if (b.width && (y["min-width"] = `${b.width - 1}px`, y["max-width"] = `${b.width}px`, y.width = `${b.width}px`), b.fixed) {
        const T = t.filter((A, w) => A.fixed === b.fixed && w < C).reduce((A, w) => A + w.width, 0);
        y[b.fixed === "right" ? "right" : "left"] = `${T}px`;
      }
      return `<td style="${Object.keys(y).map((T) => `${T}: ${y[T]}`).join("; ")}" class="${f.rowItem} ${f.borderColor} ${i ? `${f.edit}` : ""} ${r ? `${f.tableBordered}` : ""} ${u ? `${f.sm}` : ""} ${b.fixed ? `${f.fixedHeader} ${f.color}` : ""}" ${Ob} data-te-field="${b.field}" ${i && 'contenteditable="true"'}>${m[b.field]}</td>`;
    }).join("");
    return `<tr scope="row" class="${f.row} ${f.borderColor} ${f.rowAnimation} ${l ? `${f.striped}` : ""} ${a ? `${f.borderless}` : ""} ${p ? `${f.hoverRow}` : ""}" data-te-index="${m.rowIndex}" ${xb}>${n ? g : ""}${v}</tr>`;
  });
  return s.length > 0 || o ? _.join(`
`) : `<tr class="${f.noFoundMessageWrapper} ${f.borderColor}"><td class="${f.noFoundMessage}">${e}</td></tr>`;
}, Ib = "data-te-datatable-inner-ref", Db = "data-te-datatable-header-ref", Va = ({
  columns: s,
  rows: t,
  noFoundMessage: e,
  edit: i,
  multi: n,
  selectable: o,
  loading: r,
  loadingMessage: a,
  pagination: l,
  bordered: p,
  borderless: u,
  striped: f,
  hover: _,
  fixedHeader: m,
  sm: g,
  sortIconTemplate: v,
  classes: b
}) => {
  const C = Sb({
    rows: t,
    columns: s,
    noFoundMessage: e,
    edit: i,
    loading: r,
    selectable: o,
    bordered: p,
    borderless: u,
    striped: f,
    hover: _,
    sm: g,
    classes: b
  }), y = wb(
    s,
    o,
    n,
    p,
    g,
    r,
    v,
    b
  );
  return { table: `
<div class="${b.color}" ${Ib}>
  <table class="${b.table}">
    <thead class="${b.tableHeader} ${p ? `${b.tableBordered}` : ""} ${u ? `${b.borderless}` : ""} ${b.borderColor}" ${Db}>
      <tr>
        ${y}
      </tr>
    </thead>
    <tbody class="${m ? `${b.fixedHeaderBody}` : ""}">
      ${r ? "" : C}
    </tbody>
  </table>
</div>
${r ? `
  <div class="${b.loadingItemsWrapper}">
    <div class="${b.loadingProgressBarWrapper}">
      <div class="${b.loadingProgressBar}"></div>
    </div>
  </div>
<p class="${b.loadingMessage}">${a}</p>
` : ""}
${l.enable ? Cb(l, r, p) : ""}
  `, rows: C, column: y };
}, $b = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {
  let r = n[t], a = o[t];
  return typeof r == "string" && (r = r.toLowerCase()), typeof a == "string" && (a = a.toLowerCase()), r < a ? e === "desc" ? 1 : -1 : r > a ? e === "desc" ? -1 : 1 : 0;
}), Lb = (s, t, e) => {
  if (!t)
    return s;
  const i = (n) => {
    const o = document.createElement("div");
    return o.innerHTML = n, n = o.textContent || o.innerText || "", n.toString().toLowerCase().match(t.toLowerCase());
  };
  return s.filter((n) => {
    if (e && typeof e == "string")
      return i(n[e]);
    let o = Object.values(n);
    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;
  });
}, Fa = ({ rows: s, entries: t, activePage: e }) => {
  const i = e * t;
  return s.slice(i, i + Number(t));
}, xi = "datatable", _t = `data-te-${xi}`, gi = `te.${xi}`, zs = `.${gi}`, Mb = `[${_t}-inner-ref]`, zn = `[${_t}-cell-ref]`, Nb = `[${_t}-header-ref]`, Rb = `[${_t}-header-checkbox-ref]`, Pb = `[${_t}-pagination-right-ref]`, Bb = `[${_t}-pagination-left-ref]`, Hb = `[${_t}-pagination-start-ref]`, Wb = `[${_t}-pagination-end-ref]`, Vb = `[${_t}-pagination-nav-ref]`, Fb = `[${_t}-select-ref]`, Un = `[${_t}-sort-icon-ref]`, di = `[${_t}-row-ref]`, Xn = `[${_t}-row-checkbox-ref]`, Yb = `selectRows${zs}`, Ya = `render${zs}`, jb = `rowClick${zs}`, Kb = `update${zs}`, zb = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18" />
</svg>`, Ub = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" />
</svg>`, Xb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
</svg>`, Gb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
</svg>`, qb = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5"/>
</svg>`, Zb = "border-neutral-200 dark:border-neutral-500", Qb = "border-none", Jb = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", tv = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", ev = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", iv = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", sv = "bg-white dark:bg-neutral-800", nv = "py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white", ov = "focus:outline-none", rv = "sticky top-0 z-30", av = "sticky z-10 bg-inherit", lv = "hover:bg-neutral-100 dark:hover:bg-neutral-700", cv = "pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300", hv = "h-[2px] relative w-full overflow-hidden", dv = "text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400", uv = "text-neutral-500 dark:text-neutral-300", pv = "text-neutral-500 dark:text-neutral-300", _v = "pointer-events-none cursor-none", fv = "h-full w-[45%] bg-primary-400 dark:bg-primary-600", mv = "h-full animate-[progress_3s_ease-in-out_infinite]", gv = "pl-2 py-3 font-light text-sm dark:text-neutral-300", bv = "border-b", vv = "flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]", Tv = "border border-t-0", Ev = "order-1 my-3 md:order-none md:my-0 md:pr-1", Cv = "inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", Av = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", yv = "font-normal order-2 mb-3 md:order-none md:mb-0", wv = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", xv = "font-light", kv = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", Ov = "border-b", Sv = "transition ease-in-out duration-300 motion-reduce:transition-none", Iv = "whitespace-nowrap text-clip overflow-hidden px-[1.4rem] py-4", Dv = "relative", $v = "!bg-neutral-100 dark:!bg-neutral-600", Lv = "flex items-center space-x-4 order-3 md:order-none", Mv = "w-[70px]", Nv = "!py-2", Rv = "w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400", Pv = "flex flex-row group", Bv = "[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700", Hv = "border", Wv = "border-b font-normal px-[1.4rem]", Vv = "text-left text-sm font-light w-full leading-[1.6]", Fv = {
  bordered: "boolean",
  borderless: "boolean",
  clickableRows: "boolean",
  defaultValue: "string",
  edit: "boolean",
  entries: "(number|string)",
  entriesOptions: "array",
  fullPagination: "boolean",
  hover: "boolean",
  loading: "boolean",
  loadingMessage: "string",
  maxWidth: "(null|number|string)",
  maxHeight: "(null|number|string)",
  multi: "boolean",
  noFoundMessage: "string",
  pagination: "boolean",
  selectable: "boolean",
  sm: "boolean",
  sortField: "(null|string)",
  sortOrder: "string",
  fixedHeader: "boolean",
  striped: "boolean",
  rowsText: "string",
  ofText: "string",
  allText: "string",
  forceSort: "boolean",
  sortIconTemplate: "string",
  paginationStartIconTemplate: "string",
  paginationEndIconTemplate: "string",
  paginationLeftIconTemplate: "string",
  paginationRightIconTemplate: "string"
}, Yv = {
  bordered: !1,
  borderless: !1,
  clickableRows: !1,
  defaultValue: "-",
  edit: !1,
  entries: 10,
  entriesOptions: [10, 25, 50, 200],
  fixedHeader: !1,
  fullPagination: !1,
  hover: !1,
  loading: !1,
  loadingMessage: "Loading results...",
  maxWidth: null,
  maxHeight: null,
  multi: !1,
  noFoundMessage: "No matching results found",
  pagination: !0,
  selectable: !1,
  sm: !1,
  sortField: null,
  sortOrder: "asc",
  striped: !1,
  rowsText: "Rows per page:",
  ofText: "of",
  allText: "All",
  forceSort: !1,
  sortIconTemplate: zb,
  paginationStartIconTemplate: Ub,
  paginationEndIconTemplate: qb,
  paginationLeftIconTemplate: Xb,
  paginationRightIconTemplate: Gb
}, jv = {
  label: "string",
  field: "string",
  fixed: "(boolean|string)",
  format: "(function|null)",
  width: "(number|null)",
  sort: "boolean",
  columnIndex: "number"
}, Kv = {
  label: "",
  field: "",
  fixed: !1,
  format: null,
  width: null,
  sort: !0,
  columnIndex: 0
}, zv = {
  table: Vv,
  tableHeader: Wv,
  column: nv,
  pagination: vv,
  selectWrapper: Mv,
  scroll: Dv,
  tableBordered: Hv,
  paginationBordered: Tv,
  borderless: Qb,
  checkboxRowWrapper: iv,
  checkboxRow: ev,
  checkboxHeaderWrapper: tv,
  checkboxHeader: Jb,
  row: Ov,
  rowItem: Iv,
  striped: Bv,
  sortIconWrapper: Pv,
  sortIcon: Rv,
  paginationRowsText: xv,
  paginationNav: yv,
  paginationButtonsWrapper: Ev,
  hoverRow: lv,
  borderColor: Zb,
  color: sv,
  fixedHeader: rv,
  fixedHeaderBody: av,
  selectableRow: $v,
  rowAnimation: Sv,
  sm: Nv,
  edit: ov,
  selectItemsWrapper: Lv,
  paginationStartButton: kv,
  paginationLeftButton: Av,
  paginationRightButton: wv,
  paginationEndButton: Cv,
  loadingItemsWrapper: hv,
  loadingProgressBarWrapper: mv,
  loadingProgressBar: fv,
  loadingMessage: dv,
  loadingPaginationRowsText: pv,
  loadingPaginationSelectWrapper: _v,
  loadingPaginationNav: uv,
  loadingColumn: cv,
  noFoundMessageWrapper: bv,
  noFoundMessage: gv
}, Uv = {
  table: "string",
  tableHeader: "string",
  column: "string",
  pagination: "string",
  selectWrapper: "string",
  scroll: "string",
  tableBordered: "string",
  paginationBordered: "string",
  borderless: "string",
  checkboxRowWrapper: "string",
  checkboxRow: "string",
  checkboxHeaderWrapper: "string",
  checkboxHeader: "string",
  row: "string",
  rowItem: "string",
  striped: "string",
  sortIconWrapper: "string",
  sortIcon: "string",
  paginationRowsText: "string",
  paginationNav: "string",
  paginationButtonsWrapper: "string",
  hoverRow: "string",
  borderColor: "string",
  color: "string",
  fixedHeader: "string",
  fixedHeaderBody: "string",
  selectableRow: "string",
  rowAnimation: "string",
  sm: "string",
  edit: "string",
  selectItemsWrapper: "string",
  paginationStartButton: "string",
  paginationLeftButton: "string",
  paginationRightButton: "string",
  paginationEndButton: "string",
  loadingItemsWrapper: "string",
  loadingProgressBarWrapper: "string",
  loadingProgressBar: "string",
  loadingMessage: "string",
  loadingPaginationRowsText: "string",
  loadingPaginationSelectWrapper: "string",
  loadingPaginationNav: "string",
  loadingColumn: "string",
  noFoundMessageWrapper: "string",
  noFoundMessage: "string"
};
class wc {
  constructor(t, e = {}, i = {}, n = {}) {
    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (I.setData(t, gi, this), this._perfectScrollbar = null, this._setup());
  }
  // Getters
  static get NAME() {
    return xi;
  }
  get columns() {
    return this._columns.map((t, e) => {
      let i = {
        ...Kv,
        field: `field_${e}`,
        columnIndex: e
      };
      return typeof t == "string" ? i.label = t : typeof t == "object" && (i = {
        ...i,
        ...t
      }), L("column", i, jv), i;
    });
  }
  get rows() {
    return this._rows.map((t, e) => {
      const i = {
        rowIndex: e
      };
      return Array.isArray(t) ? this.columns.forEach((n, o) => {
        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;
      }) : typeof t == "object" && this.columns.forEach((n) => {
        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;
      }), i;
    });
  }
  get searchResult() {
    return Lb(this.rows, this._search, this._searchColumn);
  }
  get computedRows() {
    let t = [...this.searchResult];
    return this._options.sortOrder && (t = $b({
      rows: t,
      field: this._options.sortField,
      order: this._options.sortOrder
    })), this._options.pagination && (this._options.entries === "All" ? t = Fa({
      rows: t,
      entries: t.length,
      activePage: this._activePage
    }) : t = Fa({
      rows: t,
      entries: this._options.entries,
      activePage: this._activePage
    })), t;
  }
  get pages() {
    return this._options.entries === "All" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);
  }
  get navigationText() {
    const t = this._activePage * this._options.entries;
    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === "All" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;
  }
  get tableOptions() {
    return {
      classes: this._classes,
      columns: this.columns,
      rows: this.computedRows,
      noFoundMessage: this._options.noFoundMessage,
      edit: this._options.edit,
      loading: this._options.loading,
      loaderClass: this._options.loaderClass,
      loadingMessage: this._options.loadingMessage,
      selectable: this._options.selectable,
      multi: this._options.multi,
      bordered: this._options.bordered,
      borderless: this._options.borderless,
      striped: this._options.striped,
      hover: this._options.hover,
      fixedHeader: this._options.fixedHeader,
      sm: this._options.sm,
      sortIconTemplate: this._options.sortIconTemplate,
      pagination: {
        enable: this._options.pagination,
        text: this.navigationText,
        entries: this._options.entries,
        entriesOptions: this._options.entriesOptions,
        fullPagination: this._options.fullPagination,
        rowsText: this._options.rowsText,
        ofText: this._options.ofText,
        allText: this._options.allText,
        paginationStartIconTemplate: this._options.paginationStartIconTemplate,
        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,
        paginationRightIconTemplate: this._options.paginationRightIconTemplate,
        paginationEndIconTemplate: this._options.paginationEndIconTemplate,
        classes: this._classes
      },
      forceSort: this._options.forceSort
    };
  }
  // Public
  update(t, e = {}) {
    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();
  }
  dispose() {
    this._selectInstance && this._selectInstance.dispose(), I.removeData(this._element, gi), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;
  }
  search(t, e) {
    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());
  }
  sort(t, e = "asc") {
    this._options.sortOrder = e, typeof t == "string" ? this._options.sortField = this.columns.find(
      (n) => n.label === t
    ).field : this._options.sortField = t.field;
    const i = d.findOne(
      `[data-te-sort="${this._options.sortField}"]`,
      this._element
    );
    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);
  }
  setActivePage(t) {
    t < this.pages && this._changeActivePage(t);
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...zv,
      ...e,
      ...t
    }, L(xi, t, Uv), t;
  }
  _changeActivePage(t) {
    this._activePage = t, this._toggleDisableState(), this._renderRows();
  }
  _clearClassList(t) {
    ["hover", "bordered", "borderless", "sm", "striped"].forEach((e) => {
      this._options[e] && !t[e] && c.removeDataAttribute(`data-te-${e}`);
    });
  }
  _emitSelectEvent() {
    h.trigger(this._element, Yb, {
      selectedRows: this.rows.filter(
        (t) => this._selected.indexOf(t.rowIndex) !== -1
      ),
      selectedIndexes: this._selected,
      allSelected: this._selected.length === this.rows.length
    });
  }
  _getRows(t = []) {
    const e = d.findOne("tbody", this._element);
    return e ? [...d.find("tr", e).map((n) => d.find("td", n).map((o) => o.innerHTML)), ...t] : t;
  }
  _getColumns(t = []) {
    const e = d.findOne("thead", this._element);
    if (!e)
      return t;
    const i = d.findOne("tr", e);
    return [...d.find("th", i).map((o) => ({
      label: o.innerHTML,
      ...c.getDataAttributes(o)
    })), ...t];
  }
  _getCSSValue(t) {
    return typeof t == "string" ? t : `${t}px`;
  }
  _getOptions(t) {
    const e = {
      ...Yv,
      ...c.getDataAttributes(this._element),
      ...t
    };
    return L(xi, e, Fv), e;
  }
  _setActiveRows() {
    d.find(di, this._element).forEach((t) => {
      this._selected.includes(c.getDataAttribute(t, "index")) ? c.addClass(t, `active ${this._classes.selectableRow}`) : c.removeClass(t, `active ${this._classes.selectableRow}`);
    });
  }
  _setEntries(t) {
    this._options = this._getOptions({
      ...this._options,
      entries: t.target.value
    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();
  }
  _setSelected() {
    d.find(Xn, this._element).forEach(
      (t) => {
        const e = c.getDataAttribute(t, "rowIndex");
        t.checked = this._selected.includes(e);
      }
    ), this._setActiveRows();
  }
  _setActiveSortIcon(t) {
    d.find(Un, this._element).forEach((e) => {
      const i = this._options.sortOrder === "desc" && e === t ? 180 : 0;
      c.style(e, {
        transform: `rotate(${i}deg)`
      }), e === t && this._options.sortOrder ? c.addClass(e, "opacity-100") : c.removeClass(e, "opacity-100");
    });
  }
  _setup() {
    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();
  }
  _setupClickableRows() {
    d.find(di, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "index");
      c.addClass(t, "cursor-pointer"), h.on(t, "click", (i) => {
        d.matches(i.target, Xn) || h.trigger(this._element, jb, {
          index: e,
          row: this.rows[e]
        });
      });
    });
  }
  _setupEditable() {
    d.find(di, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "index");
      d.find(zn, t).forEach((i) => {
        h.on(i, "input", (n) => this._updateRow(n, e));
      });
    });
  }
  _setupScroll() {
    const t = d.findOne(Mb, this._element), e = {};
    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {
      const i = this._getCSSValue(this._options.maxWidth);
      e.maxWidth = i, c.style(this._element, { maxWidth: i });
    }
    if (c.style(t, e), c.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {
      let i = d.find(Nb, this._element);
      this._options.selectable && (i = i.filter((n, o) => (c.addClass(
        n,
        `${this._classes.fixedHeader} ${this._classes.color}`
      ), o !== 0))), i.forEach((n, o) => {
        c.addClass(
          n,
          `${this._classes.fixedHeader} ${this._classes.color}`
        ), this.columns[o].fixed && c.addClass(n, "!z-40");
      });
    }
    this._perfectScrollbar = new yc(t);
  }
  _setupSort() {
    d.find(Un, this._element).forEach((t) => {
      const e = c.getDataAttribute(t, "sort"), [i] = d.parents(t, "th");
      if (this.columns.sort)
        c.addClass(i, "cursor-pointer");
      else
        return;
      e === this._options.sortField && this._setActiveSortIcon(t), h.on(i, "click", () => {
        this._options.sortField === e && this._options.sortOrder === "asc" ? this._options.sortOrder = "desc" : this._options.sortField === e && this._options.sortOrder === "desc" ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);
      });
    });
  }
  _performSort() {
    this._toggleDisableState(), this._renderRows();
  }
  _setupSelectable() {
    this._checkboxes = d.find(Xn, this._element), this._headerCheckbox = d.findOne(
      Rb,
      this._element
    ), h.on(
      this._headerCheckbox,
      "input",
      (t) => this._toggleSelectAll(t)
    ), this._checkboxes.forEach((t) => {
      const e = c.getDataAttribute(t, "rowIndex");
      h.on(
        t,
        "input",
        (i) => this._toggleSelectRow(i, e)
      );
    });
  }
  _setupPagination() {
    this._paginationRight = d.findOne(
      Pb,
      this._element
    ), this._paginationLeft = d.findOne(
      Bb,
      this._element
    ), h.on(
      this._paginationRight,
      "click",
      () => this._changeActivePage(this._activePage + 1)
    ), h.on(
      this._paginationLeft,
      "click",
      () => this._changeActivePage(this._activePage - 1)
    ), this._options.fullPagination && (this._paginationStart = d.findOne(
      Hb,
      this._element
    ), this._paginationEnd = d.findOne(
      Wb,
      this._element
    ), h.on(
      this._paginationStart,
      "click",
      () => this._changeActivePage(0)
    ), h.on(
      this._paginationEnd,
      "click",
      () => this._changeActivePage(this.pages - 1)
    )), this._toggleDisableState(), this._setupPaginationSelect();
  }
  _setupPaginationSelect() {
    this._select = d.findOne(Fb, this._element), this._selectInstance = new $o(this._select), h.on(
      this._select,
      "valueChange.te.select",
      (t) => this._setEntries(t)
    );
  }
  _removeEventListeners() {
    this._options.pagination && (h.off(this._paginationRight, "click"), h.off(this._paginationLeft, "click"), h.off(this._select, "valueChange.te.select"), this._options.fullPagination && (h.off(this._paginationStart, "click"), h.off(this._paginationEnd, "click"))), this._options.edit && d.find(zn, this._element).forEach((t) => {
      h.off(t, "input");
    }), this._options.clickableRows && d.find(di, this._element).forEach((t) => {
      h.off(t, "click");
    }), d.find(Un, this._element).forEach((t) => {
      const [e] = d.parents(t, "th");
      h.off(e, "click");
    }), this._options.selectable && (h.off(this._headerCheckbox, "input"), this._checkboxes.forEach((t) => {
      h.off(t, "input");
    }));
  }
  _renderTable() {
    this._element.innerHTML = Va(this.tableOptions).table, this._formatCells(), h.trigger(this._element, Ya);
  }
  _renderRows() {
    const t = d.findOne("tbody", this._element);
    if (this._options.pagination) {
      const e = d.findOne(
        Vb,
        this._element
      );
      e.innerText = this.navigationText;
    }
    t.innerHTML = Va(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), h.trigger(this._element, Ya);
  }
  _formatCells() {
    d.find(di, this._element).forEach((e) => {
      const i = c.getDataAttribute(e, "index");
      d.find(zn, e).forEach((o) => {
        const r = c.getDataAttribute(o, "field"), a = this.columns.find((l) => l.field === r);
        a && a.format !== null && a.format(o, this.rows[i][r]);
      });
    });
  }
  _toggleDisableState() {
    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute("disabled", ""), this._options.fullPagination && this._paginationStart.setAttribute("disabled", "")) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute("disabled", ""), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", "")) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")));
  }
  _toggleSelectAll(t) {
    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();
  }
  _toggleSelectRow(t, e) {
    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {
      i !== t.target && (i.checked = !1);
    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();
  }
  _updateRow(t, e) {
    const i = c.getDataAttribute(t.target, "field"), n = t.target.textContent, o = this._rows[e];
    if (Array.isArray(o)) {
      const a = this.columns.find((l) => l.field === i).columnIndex;
      o[a] = n;
    } else
      o[i] = n;
    h.trigger(this._element, Kb, {
      rows: this._rows,
      columns: this._columns
    });
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, gi);
      const o = typeof t == "object" && t;
      if (!(!n && /dispose/.test(t)) && (n || (n = new wc(this, o, e)), typeof t == "string")) {
        if (typeof n[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        n[t](e, i);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, gi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ja = "rating", $s = "te.rating", Xv = "data-te-rating-init", Gv = "[data-te-rating-icon-ref]", ti = `.${$s}`, qv = "ArrowLeft", Zv = "ArrowRight", Qv = {
  tooltip: "string",
  value: "(string|number)",
  readonly: "boolean",
  after: "string",
  before: "string",
  dynamic: "boolean",
  active: "string"
}, Jv = {
  tooltip: "top",
  value: "",
  readonly: !1,
  after: "",
  before: "",
  dynamic: !1,
  active: "fill-current"
}, Ka = `onSelect${ti}`, t0 = `onHover${ti}`, za = `keyup${ti}`, Ua = `focusout${ti}`, Xa = `keydown${ti}`, Ga = `mousedown${ti}`;
class z0 {
  constructor(t, e) {
    this._element = t, this._icons = d.find(Gv, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (I.setData(t, $s, this), this._init());
  }
  // Getters
  static get NAME() {
    return ja;
  }
  dispose() {
    I.removeData(this._element, $s), this._options.readonly || (h.off(this._element, za), h.off(this._element, Ua), h.off(this._element, Xa), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
      h.off(t, Ga), t.removeEventListener("mouseenter", this._fn.mouseenter[e]), c.removeClass(t, "cursor-pointer");
    }), this._tooltips.forEach((t) => {
      t._element.removeAttribute(Xv), t.dispose();
    }), this._icons.removeAttribute("tabIndex")), this._element = null;
  }
  // Private
  _init() {
    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {
      c.addClass(t, "cursor-pointer");
    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));
  }
  _getConfig(t) {
    const e = c.getDataAttributes(this._element);
    return t = {
      ...Jv,
      ...e,
      ...t
    }, L(ja, t, Qv), t;
  }
  _bindMouseEnter() {
    this._fn.mouseenter = [], this._icons.forEach((t, e) => {
      t.addEventListener(
        "mouseenter",
        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose
        // prettier-ignore
        this._fn.mouseenter[e] = (i) => {
          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, t0);
        }
      );
    });
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      "mouseleave",
      // this._fn.mouseleave is needed to create reference and unpin events after call dispose
      // prettier-ignore
      this._fn.mouseleave = () => {
        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());
      }
    );
  }
  _bindMouseDown() {
    this._icons.forEach((t) => {
      h.on(t, Ga, () => {
        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, Ka);
      });
    });
  }
  _bindKeyDown() {
    this._element.tabIndex = 0, h.on(
      this._element,
      Xa,
      (t) => this._updateAfterKeyDown(t)
    );
  }
  _bindKeyUp() {
    h.on(
      this._element,
      za,
      () => this._setElementOutline("auto")
    );
  }
  _bindFocusLost() {
    h.on(
      this._element,
      Ua,
      () => this._setElementOutline("none")
    );
  }
  _setElementOutline(t) {
    this._element.style.outline = t;
  }
  _triggerEvents(t, e) {
    h.trigger(t, e, {
      value: this._index + 1
    });
  }
  _updateAfterKeyDown(t) {
    const e = this._icons.length - 1, i = this._index;
    t.key === Zv && this._index < e && (this._index += 1), t.key === qv && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Ka));
  }
  _updateRating(t) {
    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {
      i <= t && c.addClass(e.querySelector("svg"), this._options.active);
    });
  }
  _clearRating() {
    this._icons.forEach((t, e) => {
      const i = t.querySelector("svg");
      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), c.removeClass(i, this._options.active);
    });
  }
  _setToolTips() {
    this._icons.forEach((t, e) => {
      const i = c.getDataAttribute(t, "toggle");
      t.title && !i && (c.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new Qe(t, {
        placement: this._options.tooltip
      }));
    });
  }
  _setCustomText() {
    this._icons.forEach((t) => {
      const e = c.getDataAttribute(t, "after"), i = c.getDataAttribute(t, "before");
      e && t.insertAdjacentHTML("afterEnd", e), i && t.insertAdjacentHTML("beforeBegin", i);
    });
  }
  _saveOriginalClassList() {
    this._icons.forEach((t) => {
      const e = t.classList.value;
      this._originalClassList.push(e);
    });
  }
  _saveOriginalIcons() {
    this._icons.forEach((t) => {
      const e = t.querySelector("svg").innerHTML;
      this._originalIcons.push(e);
    });
  }
  _restoreOriginalIcon(t) {
    const e = this._originalClassList[t], i = this._originalIcons[t];
    this._icons.forEach((n, o) => {
      if (o <= t) {
        const r = n.querySelector("svg");
        r.innerHTML = i, n.classList = e;
      }
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, $s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Gn = "popconfirm", bi = "te.popconfirm", xc = `.${bi}`, e0 = `cancel${xc}`, i0 = `confirm${xc}`, s0 = "[data-te-popconfirm-body]", qn = "data-te-popconfirm-popover", n0 = "data-te-popconfirm-modal", qa = "data-te-popconfirm-backdrop", o0 = {
  popconfirmMode: "string",
  message: "string",
  cancelText: "(null|string)",
  okText: "(null|string)",
  popconfirmIconTemplate: "string",
  cancelLabel: "(null|string)",
  confirmLabel: "(null|string)",
  position: "(null|string)"
}, r0 = {
  popconfirmMode: "inline",
  message: "Are you sure?",
  cancelText: "Cancel",
  okText: "OK",
  popconfirmIconTemplate: "",
  cancelLabel: "Cancel",
  confirmLabel: "Confirm",
  position: "bottom"
}, a0 = {
  backdrop: "string",
  body: "string",
  btnCancel: "string",
  btnConfirm: "string",
  btnsContainer: "string",
  fade: "string",
  icon: "string",
  message: "string",
  messageText: "string",
  modal: "string",
  popover: "string"
}, l0 = {
  backdrop: "h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center",
  body: "p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700",
  btnCancel: "inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200",
  btnConfirm: "inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]",
  btnsContainer: "flex justify-end space-x-2",
  fade: "transition-opacity duration-[150ms] ease-linear",
  icon: "pr-2",
  message: "flex mb-3",
  messageText: "text-neutral-600 dark:text-white",
  modal: "absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]",
  popover: "w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm"
};
class kc {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : bt("popconfirm-"), t && I.setData(t, bi, this), this._clickHandler = this.open.bind(this), h.on(this._element, "click", this._clickHandler);
  }
  // Getters
  static get NAME() {
    return Gn;
  }
  get container() {
    return d.findOne(`#${this._uid}`);
  }
  get popconfirmBody() {
    return d.findOne(
      s0,
      this.container
    );
  }
  // Public
  dispose() {
    (this._isOpen || this.container !== null) && this.close(), I.removeData(this._element, bi), h.off(this._element, "click", this._clickHandler), this._element = null;
  }
  open() {
    this._isOpen || (this._options.popconfirmMode === "inline" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());
  }
  close() {
    if (this._isOpen) {
      if (this._popper !== null || d.findOne(`[${qn}]`) !== null)
        h.on(
          this.popconfirmBody,
          "transitionend",
          this._handlePopconfirmTransitionEnd.bind(this)
        ), c.removeClass(this.popconfirmBody, "opacity-100");
      else {
        const t = d.findOne(
          `[${qa}]`
        );
        c.removeClass(this.popconfirmBody, "opacity-100"), document.body.removeChild(t), this._isOpen = !1;
      }
      h.off(document, "click", this._handleOutsideClick.bind(this)), h.off(document, "keydown", this._handleEscapeKey.bind(this));
    }
  }
  _handlePopconfirmTransitionEnd(t) {
    if (t.target !== this.popconfirmBody)
      return;
    const e = d.findOne(
      `[${qn}]`
    );
    h.off(this.popconfirmBody, "transitionend"), this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);
  }
  // Private
  _getPopoverTemplate() {
    const t = D("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(qn, ""), c.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;
  }
  _getModalTemplate() {
    const t = D("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(n0, ""), c.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;
  }
  _getPopconfirmTemplate() {
    return `<div data-te-popconfirm-body class="${this._classes.body}">
      <p class="${this._classes.message}">
      ${this._options.popconfirmIconTemplate ? `<span class="${this._classes.icon}">${this._options.popconfirmIconTemplate}</span>` : ""}
      <span class="${this._classes.messageText}">${this._options.message}</span>
      </p>
      <div class="${this._classes.btnsContainer}">
      ${this._options.cancelText ? `<button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"
        class="${this._classes.btnCancel}">${this._options.cancelText}</button>` : ""}
      <button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-confirm"
      aria-label="${this._options.confirmLabel}"
      class="${this._classes.btnConfirm}">${this._options.okText ? this._options.okText : "Ok"}</button>
      </div>
    </div>`;
  }
  _getConfig(t) {
    return t = {
      ...r0,
      ...c.getDataAttributes(this._element),
      ...t
    }, L(Gn, t, o0), t;
  }
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...l0,
      ...e,
      ...t
    }, L(Gn, t, a0), t;
  }
  _openPopover(t) {
    this._popper = Ee(this._element, t, {
      placement: this._translatePositionValue(),
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    }), document.body.appendChild(t), setTimeout(() => {
      c.addClass(
        this.popconfirmBody,
        `${this._classes.fade} opacity-100`
      ), this._isOpen = !0;
    }, 0);
  }
  _openModal(t) {
    const e = D("div");
    e.setAttribute(qa, ""), c.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), c.addClass(this.popconfirmBody, "opacity-100"), this._isOpen = !0;
  }
  _handleCancelButtonClick() {
    const t = this.container;
    this._cancelButton = d.findOne(
      "#popconfirm-button-cancel",
      t
    ), Ue.getOrCreateInstance(this._cancelButton, { rippleColor: "light" }), this._cancelButton !== null && h.on(this._cancelButton, "click", () => {
      this.close(), h.trigger(this._element, e0);
    });
  }
  _handleConfirmButtonClick() {
    const t = this.container;
    this._confirmButton = d.findOne(
      "#popconfirm-button-confirm",
      t
    ), Ue.getOrCreateInstance(this._confirmButton, { rippleColor: "light" }), h.on(this._confirmButton, "click", () => {
      this.close(), h.trigger(this._element, i0);
    });
  }
  _listenToEscapeKey() {
    h.on(document, "keydown", this._handleEscapeKey.bind(this));
  }
  _handleEscapeKey(t) {
    t.keyCode === Li && this.close();
  }
  _listenToOutsideClick() {
    h.on(document, "click", this._handleOutsideClick.bind(this));
  }
  _handleOutsideClick(t) {
    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);
    !i && !n && !o && !r && this.close();
  }
  _translatePositionValue() {
    switch (this._options.position) {
      case "top left":
        return "top-end";
      case "top":
        return "top";
      case "top right":
        return "top-start";
      case "bottom left":
        return "bottom-end";
      case "bottom":
        return "bottom";
      case "bottom right":
        return "bottom-start";
      case "left":
        return "left";
      case "left top":
        return "left-end";
      case "left bottom":
        return "left-start";
      case "right":
        return "right";
      case "right top":
        return "right-end";
      case "right bottom":
        return "right-start";
      case void 0:
        return "bottom";
      default:
        return "bottom";
    }
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = I.getData(this, bi), n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t))) {
        if (!i)
          return new kc(this, n);
        if (typeof t == "string") {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, bi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Zn = "lightbox", vi = "te.lightbox", c0 = `.${vi}`, h0 = ".data-api", Se = `click${c0}${h0}`, Oc = "[data-te-lightbox-init]", d0 = `${Oc} img:not([data-te-lightbox-disabled])`, Za = "data-te-lightbox-caption", u0 = "data-te-lightbox-disabled", St = "data-te-lightbox-active", p0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75" />
</svg>
`, _0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" />
</svg>
`, f0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
</svg>
`, m0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" />
</svg>
`, g0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" />
</svg>
`, b0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
<path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" />
</svg>
`, v0 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
</svg>
`, T0 = {
  container: "string",
  zoomLevel: "(number|string)",
  prevIconTemplate: "string",
  nextIconTemplate: "string",
  showFullscreenIconTemplate: "string",
  hideFullscreenIconTemplate: "string",
  zoomInIconTemplate: "string",
  closeIconTemplate: "string",
  zoomOutIconTemplate: "string",
  spinnerContent: "string"
}, E0 = {
  container: "body",
  zoomLevel: 1,
  prevIconTemplate: p0,
  nextIconTemplate: _0,
  showFullscreenIconTemplate: f0,
  hideFullscreenIconTemplate: m0,
  zoomInIconTemplate: g0,
  zoomOutIconTemplate: b0,
  closeIconTemplate: v0,
  spinnerContent: "Loading..."
}, C0 = {
  caption: "text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center",
  captionWrapper: "fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center",
  closeBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  fullscreenBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  gallery: "invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none",
  galleryContent: "fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]",
  galleryCounter: "flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]",
  img: "absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto",
  imgWrapper: "absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none",
  leftTools: "float-left h-full",
  loader: "fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none",
  nextBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  nextBtnWrapper: "fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  prevBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  prevBtnWrapper: "fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  rightTools: "float-right",
  spinner: "inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]",
  spinnerContent: "!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]",
  toolbar: "absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none",
  vertical: "h-full max-h-full w-auto",
  zoomBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none"
}, A0 = {
  caption: "string",
  captionWrapper: "string",
  closeBtn: "string",
  fullscreenBtn: "string",
  gallery: "string",
  galleryContent: "string",
  galleryCounter: "string",
  img: "string",
  imgWrapper: "string",
  leftTools: "string",
  loader: "string",
  nextBtn: "string",
  nextBtnWrapper: "string",
  prevBtn: "string",
  prevBtnWrapper: "string",
  rightTools: "string",
  spinner: "string",
  spinnerContent: "string",
  toolbar: "string",
  vertical: "string",
  zoomBtn: "string"
};
class Ls {
  constructor(t, e = {}, i) {
    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (I.setData(t, vi, this), this.init());
  }
  // Getters
  static get NAME() {
    return Zn;
  }
  get activeImg() {
    return this._activeImg;
  }
  get currentImg() {
    return d.findOne(
      `[${St}]`,
      this._galleryContent
    );
  }
  get options() {
    const t = {
      ...E0,
      ...c.getDataAttributes(this._element),
      ...this._options
    };
    return L(Zn, t, T0), t;
  }
  // Public
  init() {
    this._initiated || (this._appendTemplate(), this._initiated = !0);
  }
  open(t = 0) {
    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then((e) => {
      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();
    });
  }
  close() {
    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed");
  }
  slide(t = "right") {
    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents("slide", "slided"), this._beforeSlideEvents(), t === "right" && this._slideHorizontally(t), t === "left" && this._slideHorizontally(t), t === "first" && this._slideToTarget(t), t === "last" && this._slideToTarget(t), this._afterSlideEvents());
  }
  zoomIn() {
    this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn());
  }
  zoomOut() {
    this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  toggleFullscreen() {
    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(St, ""), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(St), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);
  }
  reset() {
    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);
  }
  dispose() {
    h.off(
      document,
      Se,
      d0,
      this.toggle
    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), I.removeData(this._element, vi), this._element = null;
  }
  // Private
  _getClasses(t) {
    const e = c.getDataClassAttributes(this._element);
    return t = {
      ...C0,
      ...e,
      ...t
    }, L(Zn, t, A0), t;
  }
  _getImages() {
    const e = d.find("img", this._element).filter(
      (i) => !i.hasAttribute(u0)
    );
    this._images = e;
  }
  _getContainer() {
    this._container = d.findOne(this.options.container);
  }
  _setActiveImg(t) {
    this._activeImg = typeof t == "number" ? t : this._images.indexOf(t.target);
  }
  _appendTemplate() {
    this._gallery = D("div"), c.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);
  }
  _appendToolbar() {
    this._galleryToolbar = D("div"), this._imgCounter = D("p"), this._fullscreenBtn = D("button"), this._zoomBtn = D("button");
    const t = D("button"), e = D("div"), i = D("div");
    c.addClass(this._galleryToolbar, `${this._classes.toolbar}`), c.addClass(this._imgCounter, `${this._classes.galleryCounter}`), c.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), c.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), c.addClass(this._zoomBtn, this._classes.zoomBtn), c.addClass(e, `${this._classes.leftTools}`), c.addClass(i, `${this._classes.rightTools}`), c.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), t.setAttribute("aria-label", "Close"), h.on(
      this._fullscreenBtn,
      Se,
      () => this.toggleFullscreen()
    ), h.on(
      this._zoomBtn,
      Se,
      () => this._toggleZoom()
    ), h.on(t, Se, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);
  }
  _appendContent() {
    this._galleryContent = D("div"), c.addClass(
      this._galleryContent,
      `${this._classes.galleryContent}`
    ), this._gallery.append(this._galleryContent);
  }
  _appendLoader() {
    this._loader = D("div");
    const t = D("div"), e = D("span");
    c.addClass(this._loader, `${this._classes.loader}`), c.addClass(t, `${this._classes.spinner}`), c.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute("role", "status"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);
  }
  _appendArrows() {
    this._leftArrowWrapper = D("div"), c.addClass(
      this._leftArrowWrapper,
      `${this._classes.prevBtnWrapper}`
    );
    const t = D("button");
    t.setAttribute("aria-label", "Previous"), c.addClass(t, `${this._classes.prevBtn}`), h.on(t, Se, () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = D("div"), c.addClass(
      this._rightArrowWrapper,
      `${this._classes.nextBtnWrapper}`
    ), this._rightArrow = D("button"), this._rightArrow.setAttribute("aria-label", "Next"), c.addClass(this._rightArrow, `${this._classes.nextBtn}`), h.on(this._rightArrow, Se, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));
  }
  _appendCaption() {
    const t = D("div"), e = D("p");
    e.setAttribute(Za, ""), c.addClass(t, `${this._classes.captionWrapper}`), c.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);
  }
  _sortImages() {
    for (let t = 0; t < this._activeImg; t++)
      this._images.push(this._images.shift());
  }
  async _loadImages() {
    const t = [], e = [];
    this._galleryContent.innerHTML = "";
    let i = 0;
    return this._images.forEach((n, o) => {
      t.push(
        new Promise((r) => {
          const a = new Image(), l = D("div");
          c.addClass(l, `${this._classes.imgWrapper}`), c.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;
        })
      );
    }), await Promise.all(t), e;
  }
  _addImgStyles(t, e, i, n, o) {
    t.alt = o.alt, t.draggable = !1, c.style(e, {
      position: "absolute",
      left: `${i}%`,
      top: 0
    }), (o.dataset.teCaption || o.dataset.teCaption === "") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && c.addClass(t, `${this._classes.vertical}`), c.style(e, { opacity: 1 }), t.setAttribute(St, "")) : t.removeAttribute(St), n === this._images.length - 1 && this._images.length > 1 && c.style(e, { left: "-100%" });
  }
  _resizeImages(t) {
    t.forEach((e) => {
      this._calculateImgSize(e);
    });
  }
  _calculateImgSize(t) {
    t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = "auto", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = "auto", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;
  }
  _onResize() {
    this._images = d.find("img", this._galleryContent), this._images.forEach((t) => {
      this._calculateImgSize(t);
    });
  }
  _onFullscreenChange() {
    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(St));
  }
  _beforeSlideEvents() {
    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();
  }
  _slideHorizontally(t) {
    this._images = d.find("img", this._galleryContent), this._images.forEach((e) => {
      let i;
      t === "right" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);
    }), this._updateActiveImg(t);
  }
  _slideImg(t, e) {
    e === 0 ? (t.setAttribute(St, ""), c.style(t.parentNode, { opacity: 1, transform: "scale(1)" })) : (t.removeAttribute(St), c.style(t.parentNode, {
      opacity: 0,
      transform: "scale(0.25)"
    })), t.parentNode.style.left = `${e}%`;
  }
  _slideToTarget(t) {
    t === "first" && this._activeImg === 0 || t === "last" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === "first" ? 0 : this._images.length - 1, this._sortImages(), c.style(this.currentImg.parentNode, {
      transform: "scale(0.25)",
      opacity: 0
    }), setTimeout(() => {
      this._loadImages().then((e) => {
        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
          c.style(this.currentImg.parentNode, {
            transform: "scale(1)",
            opacity: 1
          });
        }, 10);
      });
    }, 400));
  }
  _updateActiveImg(t) {
    t === "right" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === "left" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);
  }
  _afterSlideEvents() {
    this._updateCounter(), this._updateCaption();
  }
  _updateCounter() {
    this._images.length <= 1 || setTimeout(() => {
      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;
    }, 200);
  }
  _updateCaption() {
    setTimeout(() => {
      let t = this.currentImg.alt;
      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === "") && (t = this.currentImg.dataset.caption), d.findOne(
        `[${Za}]`,
        this._gallery
      ).innerHTML = t;
    }, 200);
  }
  _toggleTemplate() {
    this._gallery.style.visibility === "visible" ? (c.style(this.currentImg.parentNode, {
      transform: "scale(0.25)"
    }), setTimeout(() => {
      this._hideGallery(), this._enableScroll(), this._showLoader();
    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());
  }
  _showLoader() {
    c.style(this._loader, { opacity: 1 });
  }
  _hideLoader() {
    c.style(this._loader, { opacity: 0 });
  }
  _hideGallery() {
    c.style(this._gallery, {
      opacity: 0,
      pointerEvents: "none",
      visibility: "hidden"
    });
  }
  _showGallery() {
    c.style(this._gallery, {
      opacity: 1,
      pointerEvents: "initial",
      visibility: "visible"
    }), setTimeout(() => {
      c.style(this.currentImg.parentNode, { transform: "scale(1)" });
    }, 50);
  }
  _toggleZoom() {
    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();
  }
  _updateZoomBtn() {
    this._zoom > 1 ? (this._zoomBtn.setAttribute(St, ""), this._zoomBtn.setAttribute("aria-label", "Zoom out"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(St), this._zoomBtn.setAttribute("aria-label", "Zoom in"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);
  }
  _updateImgPosition() {
    this._zoom === 1 && this._restoreDefaultPosition();
  }
  _addEvents() {
    const t = d.find("img", this._galleryContent);
    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {
      h.on(e, "mousedown", this._onImgMousedown, {
        passive: !0
      }), h.on(e, "touchstart", this._onImgMousedown, {
        passive: !0
      }), h.on(e, "mousemove", this._onImgMousemove, {
        passive: !0
      }), h.on(e, "touchmove", this._onImgMousemove, {
        passive: !0
      }), h.on(e, "wheel", this._onImgWheel, { passive: !0 }), h.on(e, "dblclick", this._onImgDoubleClick, {
        passive: !0
      });
    }), document.addEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), h.on(window, "touchstart", this._onWindowTouchstart), h.on(window, "mouseup", this._onImgMouseup), h.on(window, "touchend", this._onImgTouchend), h.on(window, "resize", this._onWindowResize), h.on(window, "orientationchange", this._onWindowResize), h.on(window, "keyup", this._onKeyupEvent), h.on(window, "fullscreenchange", this._onWindowFullscreenChange), h.on(this._gallery, "mousemove", this._onAnyImgAction), h.on(this._gallery, "click", this._onGalleryClick), h.on(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), h.on(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _removeEvents() {
    d.find("img", this._galleryContent).forEach((e) => {
      h.off(e, "mousedown", this._onImgMousedown), h.off(e, "touchstart", this._onImgMousedown), h.off(e, "mousemove", this._onImgMousemove), h.off(e, "touchmove", this._onImgMousemove), h.off(e, "wheel", this._onImgWheel), h.off(e, "dblclick", this._onImgDoubleClick);
    }), document.removeEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), h.off(window, "touchstart", this._onWindowTouchstart), h.off(window, "mouseup", this._onImgMouseup), h.off(window, "touchend", this._onImgTouchend), h.off(window, "resize", this._onWindowResize), h.off(window, "orientationchange", this._onWindowResize), h.off(window, "keyup", this._onKeyupEvent), h.off(
      window,
      "fullscreenchange",
      this._onWindowFullscreenChange
    ), h.off(this._gallery, "mousemove", this._onAnyImgAction), h.off(this._gallery, "click", this._onGalleryClick), h.off(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), h.off(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _onMousedown(t) {
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === "touchstart" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onMousemove(t) {
    if (!this._mousedown)
      return;
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    if (e && this._resetToolsToggler(), !this._multitouch)
      if (this._zoom !== 1)
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, c.style(this.currentImg, {
          left: `${this._positionX}px`,
          top: `${this._positionY}px`
        });
      else {
        if (this._images.length <= 1)
          return;
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, c.style(this.currentImg, { left: `${this._positionX}px` });
      }
  }
  _onMouseup(t) {
    this._mousedown = !1, this._moveImg(t.target);
  }
  _onTouchend(t) {
    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));
  }
  _calculateTouchZoom(t) {
    const e = Math.hypot(
      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,
      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY
    ), i = Math.hypot(
      t.touches[1].pageX - t.touches[0].pageX,
      t.touches[1].pageY - t.touches[0].pageY
    ), n = Math.abs(e - i), o = t.view.screen.width;
    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);
  }
  _onWindowTouchstart(t) {
    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onWindowTouchmove(t) {
    t.preventDefault(), t.type === "touchmove" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);
  }
  _onRightArrowKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (t.shiftKey)
          break;
        t.preventDefault(), this._focusFullscreenBtn();
        break;
    }
  }
  _onFullscreenBtnKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (!t.shiftKey)
          break;
        t.preventDefault(), this._focusRightArrow();
        break;
    }
  }
  _onKeyup(t) {
    switch (this._resetToolsToggler(), t.keyCode) {
      case 39:
        this.slide();
        break;
      case 37:
        this.slide("left");
        break;
      case 27:
        this.close();
        break;
      case 36:
        this.slide("first");
        break;
      case 35:
        this.slide("last");
        break;
      case 38:
        this.zoomIn();
        break;
      case 40:
        this.zoomOut();
        break;
    }
  }
  _focusFullscreenBtn() {
    setTimeout(() => {
      this._fullscreenBtn.focus();
    }, 100);
  }
  _focusRightArrow() {
    this._rightArrow.focus();
  }
  _moveImg(t) {
    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)
      return;
    const e = this._positionX - this._originalPositionX;
    e > 0 ? this.slide("left") : e < 0 && this.slide();
  }
  _checkDoubleTap(t) {
    clearTimeout(this._doubleTapTimer);
    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;
    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;
    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());
  }
  _resetDoubleTap() {
    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);
  }
  _onDoubleClick(t) {
    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());
  }
  _onZoom(t) {
    if (t.deltaY > 0)
      this.zoomOut();
    else {
      if (this._zoom >= 3)
        return;
      this._setNewPositionOnZoomIn(t), this.zoomIn();
    }
  }
  _onBackdropClick(t) {
    this._resetToolsToggler(), t.target.tagName === "DIV" && this.close();
  }
  _setNewPositionOnZoomIn(t) {
    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {
      this.currentImg.style.transition = "none";
    }, 500);
  }
  _resetToolsToggler() {
    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();
  }
  _setToolsToggleTimout() {
    this._toolsToggleTimer = setTimeout(() => {
      this._hideTools(), clearTimeout(this._toolsToggleTimer);
    }, 4e3);
  }
  _hideTools() {
    c.style(this._galleryToolbar, { opacity: 0 }), c.style(this._leftArrowWrapper, { opacity: 0 }), c.style(this._rightArrowWrapper, { opacity: 0 });
  }
  _showTools() {
    c.style(this._galleryToolbar, { opacity: 1 }), c.style(this._leftArrowWrapper, { opacity: 1 }), c.style(this._rightArrowWrapper, { opacity: 1 });
  }
  _disableScroll() {
    c.addClass(document.body, "overflow-y-hidden relative"), document.documentElement.scrollHeight > document.documentElement.clientHeight && c.addClass(document.body, "md:pr-[17px]");
  }
  _enableScroll() {
    setTimeout(() => {
      c.removeClass(document.body, "overflow-y-hidden relative"), c.removeClass(document.body, "md:pr-[17px]");
    }, 300);
  }
  _animationStart() {
    this._animating = !0, setTimeout(() => {
      this._animating = !1;
    }, 400);
  }
  _restoreDefaultZoom() {
    this._zoom !== 1 && (this._zoom = 1, c.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  _restoreDefaultFullscreen() {
    this._fullscreen && this.toggleFullscreen();
  }
  _restoreDefaultPosition() {
    clearTimeout(this._zoomTimer);
    const t = this.currentImg;
    c.style(this.currentImg.parentNode, { left: 0, top: 0 }), c.style(this.currentImg, {
      transition: "all 0.5s ease-out",
      left: 0,
      top: 0
    }), this._calculateImgSize(t), setTimeout(() => {
      c.style(this.currentImg, { transition: "none" });
    }, 500);
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.te.lightbox`);
    }, 505);
  }
  static getInstance(t) {
    return I.getData(t, vi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static toggle() {
    return function(t) {
      const e = d.closest(
        t.target,
        `${Oc}`
      );
      (Ls.getInstance(e) || new Ls(e)).open(t);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, vi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Ls(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const y0 = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  h.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), me(this))
        return;
      const o = Qt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  );
}, w0 = (s) => {
  il(() => {
    const t = el();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, x0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, k0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), me(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, O0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = Qt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), me(this))
        return;
      h.one(i, s.EVENT_HIDDEN, () => {
        Lt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, S0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, I0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = Qt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), h.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || h.one(i, s.EVENT_HIDDEN, () => {
          Lt(this) && this.focus();
        });
      });
      const n = d.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, D0 = (s, t) => {
  h.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, $0 = (s, t) => {
  h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = fo(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, L0 = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, M0 = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, N0 = (s, t) => {
  d.find(t).forEach((e) => {
    new s(e);
  }), h.on(
    document,
    `click.te.${s.NAME}.data-api`,
    `${t} img:not([data-te-lightbox-disabled])`,
    s.toggle()
  );
}, R0 = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  d.find(t).forEach((o) => {
    if (c.getDataAttribute(o, "chart") !== "bubble" && c.getDataAttribute(o, "chart") !== "scatter") {
      const r = c.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...mi[a.type]
      });
    }
    return null;
  });
};
class P0 {
  constructor() {
    this.inits = [];
  }
  get initialized() {
    return this.inits;
  }
  isInited(t) {
    return this.inits.includes(t);
  }
  add(t) {
    this.inits.push(t);
  }
}
const _o = new P0(), Ti = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1,
    dismissMethod: "close"
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-te-perfect-scrollbar-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-te-rating-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1,
    dismissMethod: "hide"
  },
  datatable: {
    name: "Datatable",
    selector: "[data-te-datatable-init]"
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-te-toggle='popconfirm']"
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: R0
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: S0
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: $0
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: x0
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    dismissMethod: "hide",
    isToggler: !0,
    callback: I0
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: D0
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    dismissMethod: "hide",
    isToggler: !0,
    callback: O0
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: k0
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-te-toggle='tooltip']",
    isToggler: !1,
    callback: L0
  },
  popover: {
    name: "Popover",
    selector: "[data-te-toggle='popover']",
    isToggler: !0,
    callback: M0
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-te-lightbox-init]",
    isToggler: !0,
    callback: N0
  }
}, B0 = (s) => Ti[s.NAME] || null, H0 = (s) => {
  if (!s || _o.isInited(s.NAME))
    return;
  _o.add(s.NAME);
  const t = B0(s), e = (t == null ? void 0 : t.isToggler) || !1;
  if (w0(s), t != null && t.dismissMethod && y0(s, t.dismissMethod), t != null && t.advanced) {
    t == null || t.advanced(s, t == null ? void 0 : t.selector);
    return;
  }
  if (e) {
    t == null || t.callback(s, t == null ? void 0 : t.selector);
    return;
  }
  d.find(t == null ? void 0 : t.selector).forEach((i) => {
    let n = s.getInstance(i);
    n || (n = new s(i), t != null && t.onInit && n[t.onInit]());
  });
}, W0 = (s) => {
  s.forEach((t) => H0(t));
}, U0 = (s, t = !1) => {
  const e = Object.keys(Ti).map((i) => {
    if (!!document.querySelector(Ti[i].selector)) {
      const o = s[Ti[i].name];
      return !o && !_o.isInited(i) && t && console.warn(
        `Please import ${Ti[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  W0(e);
};

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcG5wbV90dy1lbGVtZW50c18xXzBfMC1iZXRhM19wb3N0Y3NzXzhfNF8yN19ub2RlX21vZHVsZXNfdHctZWxlbWVudHNfZGlzLWEyYjI5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUVBQXVFLEVBQUUsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLFlBQVksRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRTtBQUN2RjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELFVBQVUsWUFBWTtBQUN0QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksS0FBSyxpQkFBaUI7QUFDakQsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssMEdBQTBHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sV0FBVyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdNQUF3TTtBQUMzTTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0QsR0FBRztBQUNwRCxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FB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QTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0RBQXNELEdBQUcsaUNBQWlDLEdBQUcsRUFBRSxHQUFHO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCxHQUFHO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWUsR0FBRztBQUNsQixtQkFBbUIsR0FBRztBQUN0QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEIsdUJBQXVCLEdBQUc7QUFDMUIsaUJBQWlCLEdBQUc7QUFDcEIscUJBQXFCLEdBQUc7QUFDeEIsdUJBQXVCLEdBQUc7QUFDMUIsMkJBQTJCLEdBQUc7QUFDOUIsMkJBQTJCLEdBQUc7QUFDOUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsa05BQWtOLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUM3UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQUcsYUFBYSxHQUFHO0FBQzlkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLHVCQUF1QixFQUFFLHFCQUFxQixFQUFFLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLDhCQUE4QixFQUFFLHNCQUFzQixFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFO0FBQ3p4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLEVBQUUsR0FBRyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpREFBaUQsR0FBRztBQUNwRCxZQUFZLHlCQUF5QjtBQUNyQyxjQUFjLDJEQUEyRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyxHQUFHLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa29DQUFrb0MsZUFBZTtBQUNqcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQsMENBQTBDLEVBQUUsRUFBRSxVQUFVLEdBQUcsRUFBRSxvQ0FBb0MsR0FBRyxFQUFFLEVBQUUsZ0NBQWdDLEVBQUU7QUFDMUksTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUcsbUNBQW1DLEdBQUcsdUZBQXVGLEdBQUcsaUNBQWlDLEdBQUcsZ0NBQWdDLEdBQUcsa0NBQWtDLEdBQUcsaUNBQWlDLEdBQUc7QUFDbFQsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQTZELG1CQUFtQixtQ0FBbUM7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLGdDQUFnQyxHQUFHO0FBQ25FLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGdDQUFnQyxFQUFFO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHLEdBQUcsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUcsTUFBTSxHQUFHO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLDRRQUE0USxHQUFHLHNCQUFzQixHQUFHO0FBQ3hWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRztBQUMvQixTQUFTLFdBQVc7QUFDcEIsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYSxHQUFHLEdBQUcsRUFBRTtBQUNyQixrQkFBa0IsdUJBQXVCLEdBQUcsMEJBQTBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUVBQWlFLEdBQUcsNEJBQTRCLEdBQUcsRUFBRSxjQUFjO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2IsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DLEdBQUc7QUFDbEQ7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQsV0FBVztBQUNYLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1o7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1o7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCLGNBQWMseUJBQXlCO0FBQ3ZDLGdCQUFnQixnREFBZ0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCLE9BQU8sOERBQThEO0FBQzFHLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QyxhQUFhO0FBQ2I7QUFDQSwrREFBK0QsR0FBRztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1o7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixFQUFFO0FBQzlCLEtBQUssNERBQTRELEVBQUUsc0xBQXNMLEVBQUU7QUFDM1A7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQXFFO0FBQ2pGO0FBQ0Esd0lBQXdJLFdBQVc7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLG1CQUFtQixpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFLHdDQUF3QyxjQUFjO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxlQUFlO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUEr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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLHdDQUF3QyxFQUFFLHdDQUF3QztBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQixtQ0FBbUMsaUJBQWlCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCLElBQUksSUFBSSxpQkFBaUIsZ0NBQWdDLE1BQU0sZ0NBQWdDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3T0FBd08saUJBQWlCO0FBQ3pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBLGtEQUFrRCxtQkFBbUI7QUFDckUsa0JBQWtCLHNCQUFzQjtBQUN4QyxRQUFRLHVEQUF1RCxtQkFBbUIsSUFBSSxxQ0FBcUM7QUFDM0gscUJBQXFCLDBCQUEwQixJQUFJLHNCQUFzQjtBQUN6RTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsUUFBUSwrSUFBK0ksMEJBQTBCO0FBQ2pMLGlCQUFpQix3QkFBd0IsSUFBSSx5QkFBeUI7QUFDdEU7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLGVBQWUseUJBQXlCLElBQUksbURBQW1EO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRyxrQ0FBa0MsR0FBRyxFQUFFLEdBQUcsMkNBQTJDLElBQUk7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUErQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS90dy1lbGVtZW50c0AxLjAuMC1iZXRhM19wb3N0Y3NzQDguNC4yNy9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIFRhaWx3aW5kIEVsZW1lbnRzIDEuMC4wLWJldGEzXG4qIFxuKiBUYWlsd2luZCBFbGVtZW50cyBpcyBhbiBvcGVuLXNvdXJjZSBVSSBraXQgb2YgYWR2YW5jZWQgY29tcG9uZW50cyBmb3IgVGFpbHdpbmRDU1MuXG4qIENvcHlyaWdodCDCqSAyMDIzIE1EQm9vdHN0cmFwLmNvbVxuKiBcbiogVW5sZXNzIGEgY3VzdG9tLCBpbmRpdmlkdWFsbHkgYXNzaWduZWQgbGljZW5zZSBoYXMgYmVlbiBncmFudGVkLCB0aGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiogSW4gYWRkaXRpb24sIGEgY3VzdG9tIGxpY2Vuc2UgbWF5IGJlIGF2YWlsYWJsZSB1cG9uIHJlcXVlc3QsIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHRoYXQgbGljZW5zZS4gUGxlYXNlIGNvbnRhY3QgdGFpbHdpbmRAbWRib290c3RyYXAuY29tIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9idGFpbmluZyBhIGN1c3RvbSBsaWNlbnNlLlxuKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuKiBcbiovXG52YXIgTmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgUmMgPSAocywgdCwgZSkgPT4gdCBpbiBzID8gTmMocywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IHNbdF0gPSBlO1xudmFyIEF0ID0gKHMsIHQsIGUpID0+IChSYyhzLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5jb25zdCBacyA9ICgoKSA9PiB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgbGV0IHQgPSAxO1xuICByZXR1cm4ge1xuICAgIHNldChlLCBpLCBuKSB7XG4gICAgICB0eXBlb2YgZVtpXSA+IFwidVwiICYmIChlW2ldID0ge1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIGlkOiB0XG4gICAgICB9LCB0KyspLCBzW2VbaV0uaWRdID0gbjtcbiAgICB9LFxuICAgIGdldChlLCBpKSB7XG4gICAgICBpZiAoIWUgfHwgdHlwZW9mIGVbaV0gPiBcInVcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIHJldHVybiBuLmtleSA9PT0gaSA/IHNbbi5pZF0gOiBudWxsO1xuICAgIH0sXG4gICAgZGVsZXRlKGUsIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIG4ua2V5ID09PSBpICYmIChkZWxldGUgc1tuLmlkXSwgZGVsZXRlIGVbaV0pO1xuICAgIH1cbiAgfTtcbn0pKCksIEkgPSB7XG4gIHNldERhdGEocywgdCwgZSkge1xuICAgIFpzLnNldChzLCB0LCBlKTtcbiAgfSxcbiAgZ2V0RGF0YShzLCB0KSB7XG4gICAgcmV0dXJuIFpzLmdldChzLCB0KTtcbiAgfSxcbiAgcmVtb3ZlRGF0YShzLCB0KSB7XG4gICAgWnMuZGVsZXRlKHMsIHQpO1xuICB9XG59LCBQYyA9IDFlNiwgQmMgPSAxZTMsIFFuID0gXCJ0cmFuc2l0aW9uZW5kXCIsIEhjID0gKHMpID0+IHMgPT0gbnVsbCA/IGAke3N9YCA6IHt9LnRvU3RyaW5nLmNhbGwocykubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCksIGJ0ID0gKHMpID0+IHtcbiAgZG9cbiAgICBzICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFBjKTtcbiAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHMpKTtcbiAgcmV0dXJuIHM7XG59LCBRYSA9IChzKSA9PiB7XG4gIGxldCB0ID0gcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXRhcmdldFwiKTtcbiAgaWYgKCF0IHx8IHQgPT09IFwiI1wiKSB7XG4gICAgbGV0IGUgPSBzLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgaWYgKCFlIHx8ICFlLmluY2x1ZGVzKFwiI1wiKSAmJiAhZS5zdGFydHNXaXRoKFwiLlwiKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIjXCIpICYmIChlID0gYCMke2Uuc3BsaXQoXCIjXCIpWzFdfWApLCB0ID0gZSAmJiBlICE9PSBcIiNcIiA/IGUudHJpbSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gdDtcbn0sIGZvID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IFFhKHMpO1xuICByZXR1cm4gdCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpID8gdCA6IG51bGw7XG59LCBRdCA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSBRYShzKTtcbiAgcmV0dXJuIHQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIDogbnVsbDtcbn0sIFdjID0gKHMpID0+IHtcbiAgaWYgKCFzKVxuICAgIHJldHVybiAwO1xuICBsZXQgeyB0cmFuc2l0aW9uRHVyYXRpb246IHQsIHRyYW5zaXRpb25EZWxheTogZSB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocyk7XG4gIGNvbnN0IGkgPSBOdW1iZXIucGFyc2VGbG9hdCh0KSwgbiA9IE51bWJlci5wYXJzZUZsb2F0KGUpO1xuICByZXR1cm4gIWkgJiYgIW4gPyAwIDogKHQgPSB0LnNwbGl0KFwiLFwiKVswXSwgZSA9IGUuc3BsaXQoXCIsXCIpWzBdLCAoTnVtYmVyLnBhcnNlRmxvYXQodCkgKyBOdW1iZXIucGFyc2VGbG9hdChlKSkgKiBCYyk7XG59LCBKYSA9IChzKSA9PiB7XG4gIHMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoUW4pKTtcbn0sIFZlID0gKHMpID0+ICFzIHx8IHR5cGVvZiBzICE9IFwib2JqZWN0XCIgPyAhMSA6ICh0eXBlb2Ygcy5qcXVlcnkgPCBcInVcIiAmJiAocyA9IHNbMF0pLCB0eXBlb2Ygcy5ub2RlVHlwZSA8IFwidVwiKSwgSnQgPSAocykgPT4gVmUocykgPyBzLmpxdWVyeSA/IHNbMF0gOiBzIDogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiBzLmxlbmd0aCA+IDAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHMpIDogbnVsbCwgTCA9IChzLCB0LCBlKSA9PiB7XG4gIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGkpID0+IHtcbiAgICBjb25zdCBuID0gZVtpXSwgbyA9IHRbaV0sIHIgPSBvICYmIFZlKG8pID8gXCJlbGVtZW50XCIgOiBIYyhvKTtcbiAgICBpZiAoIW5ldyBSZWdFeHAobikudGVzdChyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7cy50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtpfVwiIHByb3ZpZGVkIHR5cGUgXCIke3J9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke259XCIuYFxuICAgICAgKTtcbiAgfSk7XG59LCBMdCA9IChzKSA9PiB7XG4gIGlmICghcyB8fCBzLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHMuc3R5bGUgJiYgcy5wYXJlbnROb2RlICYmIHMucGFyZW50Tm9kZS5zdHlsZSkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKHMpLCBlID0gZ2V0Q29tcHV0ZWRTdHlsZShzLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpID09PSBcInZpc2libGVcIiB8fCB0LmRpc3BsYXkgIT09IFwibm9uZVwiICYmIGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdC52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIG1lID0gKHMpID0+ICFzIHx8IHMubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IHMuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgPyAhMCA6IHR5cGVvZiBzLmRpc2FibGVkIDwgXCJ1XCIgPyBzLmRpc2FibGVkIDogcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiBzLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpICE9PSBcImZhbHNlXCIsIHRsID0gKHMpID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHMuZ2V0Um9vdE5vZGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Um9vdE5vZGUoKTtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyB0IDogbnVsbDtcbiAgfVxuICByZXR1cm4gcyBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBzIDogcy5wYXJlbnROb2RlID8gdGwocy5wYXJlbnROb2RlKSA6IG51bGw7XG59LCBNcyA9ICgpID0+IGZ1bmN0aW9uKCkge1xufSwgR2UgPSAocykgPT4ge1xuICBzLm9mZnNldEhlaWdodDtcbn0sIGVsID0gKCkgPT4ge1xuICBjb25zdCB7IGpRdWVyeTogcyB9ID0gd2luZG93O1xuICByZXR1cm4gcyAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLW5vLWpxdWVyeVwiKSA/IHMgOiBudWxsO1xufSwgUXMgPSBbXSwgaWwgPSAocykgPT4ge1xuICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIiA/IChRcy5sZW5ndGggfHwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgIFFzLmZvckVhY2goKHQpID0+IHQoKSk7XG4gIH0pLCBRcy5wdXNoKHMpKSA6IHMoKTtcbn0sIEYgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSBcInJ0bFwiLCBWYyA9IChzKSA9PiBBcnJheS5mcm9tKHMpLCBEID0gKHMpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocyksIGZlID0gKHMpID0+IHtcbiAgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIHMoKTtcbn0sIHNsID0gKHMsIHQsIGUgPSAhMCkgPT4ge1xuICBpZiAoIWUpIHtcbiAgICBmZShzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaSA9IDUsIG4gPSBXYyh0KSArIGk7XG4gIGxldCBvID0gITE7XG4gIGNvbnN0IHIgPSAoeyB0YXJnZXQ6IGEgfSkgPT4ge1xuICAgIGEgPT09IHQgJiYgKG8gPSAhMCwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFFuLCByKSwgZmUocykpO1xuICB9O1xuICB0LmFkZEV2ZW50TGlzdGVuZXIoUW4sIHIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBvIHx8IEphKHQpO1xuICB9LCBuKTtcbn0sIG5sID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgbGV0IG4gPSBzLmluZGV4T2YodCk7XG4gIGlmIChuID09PSAtMSlcbiAgICByZXR1cm4gc1shZSAmJiBpID8gcy5sZW5ndGggLSAxIDogMF07XG4gIGNvbnN0IG8gPSBzLmxlbmd0aDtcbiAgcmV0dXJuIG4gKz0gZSA/IDEgOiAtMSwgaSAmJiAobiA9IChuICsgbykgJSBvKSwgc1tNYXRoLm1heCgwLCBNYXRoLm1pbihuLCBvIC0gMSkpXTtcbn0sIEZjID0gL1teLl0qKD89XFwuLiopXFwufC4qLywgWWMgPSAvXFwuLiovLCBqYyA9IC86OlxcZCskLywgSnMgPSB7fTtcbmxldCBZbyA9IDE7XG5jb25zdCBLYyA9IHtcbiAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG59LCB6YyA9IC9eKG1vdXNlZW50ZXJ8bW91c2VsZWF2ZSkvaSwgb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIm1vdXNldXBcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcIm1vdXNld2hlZWxcIixcbiAgXCJET01Nb3VzZVNjcm9sbFwiLFxuICBcIm1vdXNlb3ZlclwiLFxuICBcIm1vdXNlb3V0XCIsXG4gIFwibW91c2Vtb3ZlXCIsXG4gIFwic2VsZWN0c3RhcnRcIixcbiAgXCJzZWxlY3RlbmRcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJrZXl1cFwiLFxuICBcIm9yaWVudGF0aW9uY2hhbmdlXCIsXG4gIFwidG91Y2hzdGFydFwiLFxuICBcInRvdWNobW92ZVwiLFxuICBcInRvdWNoZW5kXCIsXG4gIFwidG91Y2hjYW5jZWxcIixcbiAgXCJwb2ludGVyZG93blwiLFxuICBcInBvaW50ZXJtb3ZlXCIsXG4gIFwicG9pbnRlcnVwXCIsXG4gIFwicG9pbnRlcmxlYXZlXCIsXG4gIFwicG9pbnRlcmNhbmNlbFwiLFxuICBcImdlc3R1cmVzdGFydFwiLFxuICBcImdlc3R1cmVjaGFuZ2VcIixcbiAgXCJnZXN0dXJlZW5kXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJibHVyXCIsXG4gIFwiY2hhbmdlXCIsXG4gIFwicmVzZXRcIixcbiAgXCJzZWxlY3RcIixcbiAgXCJzdWJtaXRcIixcbiAgXCJmb2N1c2luXCIsXG4gIFwiZm9jdXNvdXRcIixcbiAgXCJsb2FkXCIsXG4gIFwidW5sb2FkXCIsXG4gIFwiYmVmb3JldW5sb2FkXCIsXG4gIFwicmVzaXplXCIsXG4gIFwibW92ZVwiLFxuICBcIkRPTUNvbnRlbnRMb2FkZWRcIixcbiAgXCJyZWFkeXN0YXRlY2hhbmdlXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJhYm9ydFwiLFxuICBcInNjcm9sbFwiXG5dKTtcbmZ1bmN0aW9uIHJsKHMsIHQpIHtcbiAgcmV0dXJuIHQgJiYgYCR7dH06OiR7WW8rK31gIHx8IHMudWlkRXZlbnQgfHwgWW8rKztcbn1cbmZ1bmN0aW9uIGFsKHMpIHtcbiAgY29uc3QgdCA9IHJsKHMpO1xuICByZXR1cm4gcy51aWRFdmVudCA9IHQsIEpzW3RdID0gSnNbdF0gfHwge30sIEpzW3RdO1xufVxuZnVuY3Rpb24gVWMocywgdCkge1xuICByZXR1cm4gZnVuY3Rpb24gZShpKSB7XG4gICAgcmV0dXJuIGkuZGVsZWdhdGVUYXJnZXQgPSBzLCBlLm9uZU9mZiAmJiBoLm9mZihzLCBpLnR5cGUsIHQpLCB0LmFwcGx5KHMsIFtpXSk7XG4gIH07XG59XG5mdW5jdGlvbiBYYyhzLCB0LCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpKG4pIHtcbiAgICBjb25zdCBvID0gcy5xdWVyeVNlbGVjdG9yQWxsKHQpO1xuICAgIGZvciAobGV0IHsgdGFyZ2V0OiByIH0gPSBuOyByICYmIHIgIT09IHRoaXM7IHIgPSByLnBhcmVudE5vZGUpXG4gICAgICBmb3IgKGxldCBhID0gby5sZW5ndGg7IGEtLTsgXCJcIilcbiAgICAgICAgaWYgKG9bYV0gPT09IHIpXG4gICAgICAgICAgcmV0dXJuIG4uZGVsZWdhdGVUYXJnZXQgPSByLCBpLm9uZU9mZiAmJiBoLm9mZihzLCBuLnR5cGUsIGUpLCBlLmFwcGx5KHIsIFtuXSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5mdW5jdGlvbiBsbChzLCB0LCBlID0gbnVsbCkge1xuICBjb25zdCBpID0gT2JqZWN0LmtleXMocyk7XG4gIGZvciAobGV0IG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyBuKyspIHtcbiAgICBjb25zdCByID0gc1tpW25dXTtcbiAgICBpZiAoci5vcmlnaW5hbEhhbmRsZXIgPT09IHQgJiYgci5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGUpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIsIG4gPSBpID8gZSA6IHQ7XG4gIGxldCBvID0gaGwocyk7XG4gIHJldHVybiBvbC5oYXMobykgfHwgKG8gPSBzKSwgW2ksIG4sIG9dO1xufVxuZnVuY3Rpb24gam8ocywgdCwgZSwgaSwgbikge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICByZXR1cm47XG4gIGlmIChlIHx8IChlID0gaSwgaSA9IG51bGwpLCB6Yy50ZXN0KHQpKSB7XG4gICAgY29uc3QgbSA9IChnKSA9PiBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIXYucmVsYXRlZFRhcmdldCB8fCB2LnJlbGF0ZWRUYXJnZXQgIT09IHYuZGVsZWdhdGVUYXJnZXQgJiYgIXYuZGVsZWdhdGVUYXJnZXQuY29udGFpbnModi5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIGcuY2FsbCh0aGlzLCB2KTtcbiAgICB9O1xuICAgIGkgPyBpID0gbShpKSA6IGUgPSBtKGUpO1xuICB9XG4gIGNvbnN0IFtvLCByLCBhXSA9IGNsKFxuICAgIHQsXG4gICAgZSxcbiAgICBpXG4gICksIGwgPSBhbChzKSwgcCA9IGxbYV0gfHwgKGxbYV0gPSB7fSksIHUgPSBsbChcbiAgICBwLFxuICAgIHIsXG4gICAgbyA/IGUgOiBudWxsXG4gICk7XG4gIGlmICh1KSB7XG4gICAgdS5vbmVPZmYgPSB1Lm9uZU9mZiAmJiBuO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmID0gcmwoXG4gICAgcixcbiAgICB0LnJlcGxhY2UoRmMsIFwiXCIpXG4gICksIF8gPSBvID8gWGMocywgZSwgaSkgOiBVYyhzLCBlKTtcbiAgXy5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBvID8gZSA6IG51bGwsIF8ub3JpZ2luYWxIYW5kbGVyID0gciwgXy5vbmVPZmYgPSBuLCBfLnVpZEV2ZW50ID0gZiwgcFtmXSA9IF8sIHMuYWRkRXZlbnRMaXN0ZW5lcihhLCBfLCBvKTtcbn1cbmZ1bmN0aW9uIEpuKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IGxsKHRbZV0sIGksIG4pO1xuICBvICYmIChzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbywgISFuKSwgZGVsZXRlIHRbZV1bby51aWRFdmVudF0pO1xufVxuZnVuY3Rpb24gR2MocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gdFtlXSB8fCB7fTtcbiAgT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChvLmluY2x1ZGVzKGkpKSB7XG4gICAgICBjb25zdCByID0gbltvXTtcbiAgICAgIEpuKFxuICAgICAgICBzLFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICByLm9yaWdpbmFsSGFuZGxlcixcbiAgICAgICAgci5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhsKHMpIHtcbiAgcmV0dXJuIHMgPSBzLnJlcGxhY2UoWWMsIFwiXCIpLCBLY1tzXSB8fCBzO1xufVxuY29uc3QgaCA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIGpvKHMsIHQsIGUsIGksICExKTtcbiAgfSxcbiAgb25lKHMsIHQsIGUsIGkpIHtcbiAgICBqbyhzLCB0LCBlLCBpLCAhMCk7XG4gIH0sXG4gIG9mZihzLCB0LCBlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW24sIG8sIHJdID0gY2woXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGlcbiAgICApLCBhID0gciAhPT0gdCwgbCA9IGFsKHMpLCBwID0gdC5zdGFydHNXaXRoKFwiLlwiKTtcbiAgICBpZiAodHlwZW9mIG8gPCBcInVcIikge1xuICAgICAgaWYgKCFsIHx8ICFsW3JdKVxuICAgICAgICByZXR1cm47XG4gICAgICBKbihcbiAgICAgICAgcyxcbiAgICAgICAgbCxcbiAgICAgICAgcixcbiAgICAgICAgbyxcbiAgICAgICAgbiA/IGUgOiBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwICYmIE9iamVjdC5rZXlzKGwpLmZvckVhY2goKGYpID0+IHtcbiAgICAgIEdjKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICBmLFxuICAgICAgICB0LnNsaWNlKDEpXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHUgPSBsW3JdIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHUpLmZvckVhY2goKGYpID0+IHtcbiAgICAgIGNvbnN0IF8gPSBmLnJlcGxhY2UoamMsIFwiXCIpO1xuICAgICAgaWYgKCFhIHx8IHQuaW5jbHVkZXMoXykpIHtcbiAgICAgICAgY29uc3QgbSA9IHVbZl07XG4gICAgICAgIEpuKFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbCxcbiAgICAgICAgICByLFxuICAgICAgICAgIG0ub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICAgIG0uZGVsZWdhdGlvblNlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHRyaWdnZXIocywgdCwgZSkge1xuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IGVsKCksIG4gPSBobCh0KSwgbyA9IHQgIT09IG4sIHIgPSBvbC5oYXMobik7XG4gICAgbGV0IGEsIGwgPSAhMCwgcCA9ICEwLCB1ID0gITEsIGYgPSBudWxsO1xuICAgIHJldHVybiBvICYmIGkgJiYgKGEgPSBpLkV2ZW50KHQsIGUpLCBpKHMpLnRyaWdnZXIoYSksIGwgPSAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpLCBwID0gIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSwgdSA9IGEuaXNEZWZhdWx0UHJldmVudGVkKCkpLCByID8gKGYgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIiksIGYuaW5pdEV2ZW50KG4sIGwsICEwKSkgOiBmID0gbmV3IEN1c3RvbUV2ZW50KHQsIHtcbiAgICAgIGJ1YmJsZXM6IGwsXG4gICAgICBjYW5jZWxhYmxlOiAhMFxuICAgIH0pLCB0eXBlb2YgZSA8IFwidVwiICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKF8pID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBfLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZVtfXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIHUgJiYgZi5wcmV2ZW50RGVmYXVsdCgpLCBwICYmIHMuZGlzcGF0Y2hFdmVudChmKSwgZi5kZWZhdWx0UHJldmVudGVkICYmIHR5cGVvZiBhIDwgXCJ1XCIgJiYgYS5wcmV2ZW50RGVmYXVsdCgpLCBmO1xuICB9XG59LCBvZSA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBoLm9uKHMsIG5bb10sIGUsIGkpO1xuICB9LFxuICBvZmYocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBoLm9mZihzLCBuW29dLCBlLCBpKTtcbiAgfVxufSwgcWMgPSBcIjUuMS4zXCI7XG5jbGFzcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0ID0gSnQodCksIHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LCBJLnNldERhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLCBoLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXNbdF0gPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIF9xdWV1ZUNhbGxiYWNrKHQsIGUsIGkgPSAhMCkge1xuICAgIHNsKHQsIGUsIGkpO1xuICB9XG4gIC8qKiBTdGF0aWMgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKEp0KHQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gcWM7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBgdGUuJHt0aGlzLk5BTUV9YDtcbiAgfVxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcbiAgfVxufVxuY29uc3QgWmMgPSBcImJ1dHRvblwiLCBRYyA9IFwiYWN0aXZlXCI7XG5jbGFzcyBkbCBleHRlbmRzIEV0IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFpjO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtcHJlc3NlZFwiLFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFFjKVxuICAgICk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gZGwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIHQgPT09IFwidG9nZ2xlXCIgJiYgZVt0XSgpO1xuICAgIH0pO1xuICB9XG59XG52YXIgUSA9IFwidG9wXCIsIGh0ID0gXCJib3R0b21cIiwgZHQgPSBcInJpZ2h0XCIsIEogPSBcImxlZnRcIiwgSWkgPSBcImF1dG9cIiwgcWUgPSBbUSwgaHQsIGR0LCBKXSwgdmUgPSBcInN0YXJ0XCIsIEZlID0gXCJlbmRcIiwgdWwgPSBcImNsaXBwaW5nUGFyZW50c1wiLCBtbyA9IFwidmlld3BvcnRcIiwgSWUgPSBcInBvcHBlclwiLCBwbCA9IFwicmVmZXJlbmNlXCIsIHRvID0gLyogQF9fUFVSRV9fICovIHFlLnJlZHVjZShmdW5jdGlvbihzLCB0KSB7XG4gIHJldHVybiBzLmNvbmNhdChbdCArIFwiLVwiICsgdmUsIHQgKyBcIi1cIiArIEZlXSk7XG59LCBbXSksIGdvID0gLyogQF9fUFVSRV9fICovIFtdLmNvbmNhdChxZSwgW0lpXSkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0LCB0ICsgXCItXCIgKyB2ZSwgdCArIFwiLVwiICsgRmVdKTtcbn0sIFtdKSwgX2wgPSBcImJlZm9yZVJlYWRcIiwgZmwgPSBcInJlYWRcIiwgbWwgPSBcImFmdGVyUmVhZFwiLCBnbCA9IFwiYmVmb3JlTWFpblwiLCBibCA9IFwibWFpblwiLCB2bCA9IFwiYWZ0ZXJNYWluXCIsIFRsID0gXCJiZWZvcmVXcml0ZVwiLCBFbCA9IFwid3JpdGVcIiwgQ2wgPSBcImFmdGVyV3JpdGVcIiwgTnMgPSBbX2wsIGZsLCBtbCwgZ2wsIGJsLCB2bCwgVGwsIEVsLCBDbF07XG5mdW5jdGlvbiBOdChzKSB7XG4gIHJldHVybiBzID8gKHMubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5mdW5jdGlvbiB1dChzKSB7XG4gIGlmIChzID09IG51bGwpXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHMudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IFdpbmRvd11cIikge1xuICAgIHZhciB0ID0gcy5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiB0ICYmIHQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gVGUocykge1xuICB2YXIgdCA9IHV0KHMpLkVsZW1lbnQ7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGN0KHMpIHtcbiAgdmFyIHQgPSB1dChzKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGJvKHMpIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID4gXCJ1XCIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IHV0KHMpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIEpjKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlO1xuICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaSA9IHQuc3R5bGVzW2VdIHx8IHt9LCBuID0gdC5hdHRyaWJ1dGVzW2VdIHx8IHt9LCBvID0gdC5lbGVtZW50c1tlXTtcbiAgICAhY3QobykgfHwgIU50KG8pIHx8IChPYmplY3QuYXNzaWduKG8uc3R5bGUsIGkpLCBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBhID0gbltyXTtcbiAgICAgIGEgPT09ICExID8gby5yZW1vdmVBdHRyaWJ1dGUocikgOiBvLnNldEF0dHJpYnV0ZShyLCBhID09PSAhMCA/IFwiXCIgOiBhKTtcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdGgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICB0b3A6IFwiMFwiLFxuICAgICAgbWFyZ2luOiBcIjBcIlxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGUucG9wcGVyKSwgdC5zdHlsZXMgPSBlLCB0LmVsZW1lbnRzLmFycm93ICYmIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5hcnJvdy5zdHlsZSwgZS5hcnJvdyksIGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIG4gPSB0LmVsZW1lbnRzW2ldLCBvID0gdC5hdHRyaWJ1dGVzW2ldIHx8IHt9LCByID0gT2JqZWN0LmtleXModC5zdHlsZXMuaGFzT3duUHJvcGVydHkoaSkgPyB0LnN0eWxlc1tpXSA6IGVbaV0pLCBhID0gci5yZWR1Y2UoZnVuY3Rpb24obCwgcCkge1xuICAgICAgICByZXR1cm4gbFtwXSA9IFwiXCIsIGw7XG4gICAgICB9LCB7fSk7XG4gICAgICAhY3QobikgfHwgIU50KG4pIHx8IChPYmplY3QuYXNzaWduKG4uc3R5bGUsIGEpLCBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUobCk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCB2byA9IHtcbiAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IEpjLFxuICBlZmZlY3Q6IHRoLFxuICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxufTtcbmZ1bmN0aW9uIHZ0KHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzBdO1xufVxudmFyIGdlID0gTWF0aC5tYXgsIFJzID0gTWF0aC5taW4sIFllID0gTWF0aC5yb3VuZDtcbmZ1bmN0aW9uIGVvKCkge1xuICB2YXIgcyA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICByZXR1cm4gcyAhPSBudWxsICYmIHMuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkocy5icmFuZHMpID8gcy5icmFuZHMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5icmFuZCArIFwiL1wiICsgdC52ZXJzaW9uO1xuICB9KS5qb2luKFwiIFwiKSA6IG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5mdW5jdGlvbiBBbCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGVvKCkpO1xufVxuZnVuY3Rpb24gamUocywgdCwgZSkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSAhMSksIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIGkgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gMSwgbyA9IDE7XG4gIHQgJiYgY3QocykgJiYgKG4gPSBzLm9mZnNldFdpZHRoID4gMCAmJiBZZShpLndpZHRoKSAvIHMub2Zmc2V0V2lkdGggfHwgMSwgbyA9IHMub2Zmc2V0SGVpZ2h0ID4gMCAmJiBZZShpLmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxKTtcbiAgdmFyIHIgPSBUZShzKSA/IHV0KHMpIDogd2luZG93LCBhID0gci52aXN1YWxWaWV3cG9ydCwgbCA9ICFBbCgpICYmIGUsIHAgPSAoaS5sZWZ0ICsgKGwgJiYgYSA/IGEub2Zmc2V0TGVmdCA6IDApKSAvIG4sIHUgPSAoaS50b3AgKyAobCAmJiBhID8gYS5vZmZzZXRUb3AgOiAwKSkgLyBvLCBmID0gaS53aWR0aCAvIG4sIF8gPSBpLmhlaWdodCAvIG87XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGYsXG4gICAgaGVpZ2h0OiBfLFxuICAgIHRvcDogdSxcbiAgICByaWdodDogcCArIGYsXG4gICAgYm90dG9tOiB1ICsgXyxcbiAgICBsZWZ0OiBwLFxuICAgIHg6IHAsXG4gICAgeTogdVxuICB9O1xufVxuZnVuY3Rpb24gVG8ocykge1xuICB2YXIgdCA9IGplKHMpLCBlID0gcy5vZmZzZXRXaWR0aCwgaSA9IHMub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gTWF0aC5hYnModC53aWR0aCAtIGUpIDw9IDEgJiYgKGUgPSB0LndpZHRoKSwgTWF0aC5hYnModC5oZWlnaHQgLSBpKSA8PSAxICYmIChpID0gdC5oZWlnaHQpLCB7XG4gICAgeDogcy5vZmZzZXRMZWZ0LFxuICAgIHk6IHMub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlLFxuICAgIGhlaWdodDogaVxuICB9O1xufVxuZnVuY3Rpb24geWwocywgdCkge1xuICB2YXIgZSA9IHQuZ2V0Um9vdE5vZGUgJiYgdC5nZXRSb290Tm9kZSgpO1xuICBpZiAocy5jb250YWlucyh0KSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChlICYmIGJvKGUpKSB7XG4gICAgdmFyIGkgPSB0O1xuICAgIGRvIHtcbiAgICAgIGlmIChpICYmIHMuaXNTYW1lTm9kZShpKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaSA9IGkucGFyZW50Tm9kZSB8fCBpLmhvc3Q7XG4gICAgfSB3aGlsZSAoaSk7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gVHQocykge1xuICByZXR1cm4gdXQocykuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbn1cbmZ1bmN0aW9uIGVoKHMpIHtcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmRleE9mKE50KHMpKSA+PSAwO1xufVxuZnVuY3Rpb24gdGUocykge1xuICByZXR1cm4gKChUZShzKSA/IHMub3duZXJEb2N1bWVudCA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmRvY3VtZW50XG4gICkpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gSHMocykge1xuICByZXR1cm4gTnQocykgPT09IFwiaHRtbFwiID8gcyA6IChcbiAgICAvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIHMucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIChibyhzKSA/IHMuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgdGUocylcbiAgKTtcbn1cbmZ1bmN0aW9uIEtvKHMpIHtcbiAgcmV0dXJuICFjdChzKSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBUdChzKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gbnVsbCA6IHMub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gaWgocykge1xuICB2YXIgdCA9IC9maXJlZm94L2kudGVzdChlbygpKSwgZSA9IC9UcmlkZW50L2kudGVzdChlbygpKTtcbiAgaWYgKGUgJiYgY3QocykpIHtcbiAgICB2YXIgaSA9IFR0KHMpO1xuICAgIGlmIChpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbiA9IEhzKHMpO1xuICBmb3IgKGJvKG4pICYmIChuID0gbi5ob3N0KTsgY3QobikgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihOdChuKSkgPCAwOyApIHtcbiAgICB2YXIgbyA9IFR0KG4pO1xuICAgIGlmIChvLnRyYW5zZm9ybSAhPT0gXCJub25lXCIgfHwgby5wZXJzcGVjdGl2ZSAhPT0gXCJub25lXCIgfHwgby5jb250YWluID09PSBcInBhaW50XCIgfHwgW1widHJhbnNmb3JtXCIsIFwicGVyc3BlY3RpdmVcIl0uaW5kZXhPZihvLndpbGxDaGFuZ2UpICE9PSAtMSB8fCB0ICYmIG8ud2lsbENoYW5nZSA9PT0gXCJmaWx0ZXJcIiB8fCB0ICYmIG8uZmlsdGVyICYmIG8uZmlsdGVyICE9PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiBuO1xuICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBEaShzKSB7XG4gIGZvciAodmFyIHQgPSB1dChzKSwgZSA9IEtvKHMpOyBlICYmIGVoKGUpICYmIFR0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiOyApXG4gICAgZSA9IEtvKGUpO1xuICByZXR1cm4gZSAmJiAoTnQoZSkgPT09IFwiaHRtbFwiIHx8IE50KGUpID09PSBcImJvZHlcIiAmJiBUdChlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikgPyB0IDogZSB8fCBpaChzKSB8fCB0O1xufVxuZnVuY3Rpb24gRW8ocykge1xuICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluZGV4T2YocykgPj0gMCA/IFwieFwiIDogXCJ5XCI7XG59XG5mdW5jdGlvbiBFaShzLCB0LCBlKSB7XG4gIHJldHVybiBnZShzLCBScyh0LCBlKSk7XG59XG5mdW5jdGlvbiBzaChzLCB0LCBlKSB7XG4gIHZhciBpID0gRWkocywgdCwgZSk7XG4gIHJldHVybiBpID4gZSA/IGUgOiBpO1xufVxuZnVuY3Rpb24gd2woKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5mdW5jdGlvbiB4bChzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB3bCgpLCBzKTtcbn1cbmZ1bmN0aW9uIGtsKHMsIHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICByZXR1cm4gZVtpXSA9IHMsIGU7XG4gIH0sIHt9KTtcbn1cbnZhciBuaCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KE9iamVjdC5hc3NpZ24oe30sIGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XG4gIH0pKSA6IHQsIHhsKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgPyB0IDoga2wodCwgcWUpKTtcbn07XG5mdW5jdGlvbiBvaChzKSB7XG4gIHZhciB0LCBlID0gcy5zdGF0ZSwgaSA9IHMubmFtZSwgbiA9IHMub3B0aW9ucywgbyA9IGUuZWxlbWVudHMuYXJyb3csIHIgPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgYSA9IHZ0KGUucGxhY2VtZW50KSwgbCA9IEVvKGEpLCBwID0gW0osIGR0XS5pbmRleE9mKGEpID49IDAsIHUgPSBwID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIW8gfHwgIXIpKSB7XG4gICAgdmFyIGYgPSBuaChuLnBhZGRpbmcsIGUpLCBfID0gVG8obyksIG0gPSBsID09PSBcInlcIiA/IFEgOiBKLCBnID0gbCA9PT0gXCJ5XCIgPyBodCA6IGR0LCB2ID0gZS5yZWN0cy5yZWZlcmVuY2VbdV0gKyBlLnJlY3RzLnJlZmVyZW5jZVtsXSAtIHJbbF0gLSBlLnJlY3RzLnBvcHBlclt1XSwgYiA9IHJbbF0gLSBlLnJlY3RzLnJlZmVyZW5jZVtsXSwgQyA9IERpKG8pLCB5ID0gQyA/IGwgPT09IFwieVwiID8gQy5jbGllbnRIZWlnaHQgfHwgMCA6IEMuY2xpZW50V2lkdGggfHwgMCA6IDAsIEUgPSB2IC8gMiAtIGIgLyAyLCBUID0gZlttXSwgQSA9IHkgLSBfW3VdIC0gZltnXSwgdyA9IHkgLyAyIC0gX1t1XSAvIDIgKyBFLCBTID0gRWkoVCwgdywgQSksIGsgPSBsO1xuICAgIGUubW9kaWZpZXJzRGF0YVtpXSA9ICh0ID0ge30sIHRba10gPSBTLCB0LmNlbnRlck9mZnNldCA9IFMgLSB3LCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gcmgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmVsZW1lbnQsIG4gPSBpID09PSB2b2lkIDAgPyBcIltkYXRhLXBvcHBlci1hcnJvd11cIiA6IGk7XG4gIGlmIChuICE9IG51bGwgJiYgISh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gdC5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihuKSwgIW4pKSkge1xuICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGN0KG4pIHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCBcIlRvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXNcIiwgXCJ0aGUgYXJyb3cuXCJdLmpvaW4oXCIgXCIpKSksICF5bCh0LmVsZW1lbnRzLnBvcHBlciwgbikpIHtcbiAgICAgICh7fSkuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgXCJlbGVtZW50LlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuZWxlbWVudHMuYXJyb3cgPSBuO1xuICB9XG59XG5jb25zdCBPbCA9IHtcbiAgbmFtZTogXCJhcnJvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogb2gsXG4gIGVmZmVjdDogcmgsXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl1cbn07XG5mdW5jdGlvbiBLZShzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiLVwiKVsxXTtcbn1cbnZhciBhaCA9IHtcbiAgdG9wOiBcImF1dG9cIixcbiAgcmlnaHQ6IFwiYXV0b1wiLFxuICBib3R0b206IFwiYXV0b1wiLFxuICBsZWZ0OiBcImF1dG9cIlxufTtcbmZ1bmN0aW9uIGxoKHMsIHQpIHtcbiAgdmFyIGUgPSBzLngsIGkgPSBzLnksIG4gPSB0LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiBZZShlICogbikgLyBuIHx8IDAsXG4gICAgeTogWWUoaSAqIG4pIC8gbiB8fCAwXG4gIH07XG59XG5mdW5jdGlvbiB6byhzKSB7XG4gIHZhciB0LCBlID0gcy5wb3BwZXIsIGkgPSBzLnBvcHBlclJlY3QsIG4gPSBzLnBsYWNlbWVudCwgbyA9IHMudmFyaWF0aW9uLCByID0gcy5vZmZzZXRzLCBhID0gcy5wb3NpdGlvbiwgbCA9IHMuZ3B1QWNjZWxlcmF0aW9uLCBwID0gcy5hZGFwdGl2ZSwgdSA9IHMucm91bmRPZmZzZXRzLCBmID0gcy5pc0ZpeGVkLCBfID0gci54LCBtID0gXyA9PT0gdm9pZCAwID8gMCA6IF8sIGcgPSByLnksIHYgPSBnID09PSB2b2lkIDAgPyAwIDogZywgYiA9IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUoe1xuICAgIHg6IG0sXG4gICAgeTogdlxuICB9KSA6IHtcbiAgICB4OiBtLFxuICAgIHk6IHZcbiAgfTtcbiAgbSA9IGIueCwgdiA9IGIueTtcbiAgdmFyIEMgPSByLmhhc093blByb3BlcnR5KFwieFwiKSwgeSA9IHIuaGFzT3duUHJvcGVydHkoXCJ5XCIpLCBFID0gSiwgVCA9IFEsIEEgPSB3aW5kb3c7XG4gIGlmIChwKSB7XG4gICAgdmFyIHcgPSBEaShlKSwgUyA9IFwiY2xpZW50SGVpZ2h0XCIsIGsgPSBcImNsaWVudFdpZHRoXCI7XG4gICAgaWYgKHcgPT09IHV0KGUpICYmICh3ID0gdGUoZSksIFR0KHcpLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiICYmIGEgPT09IFwiYWJzb2x1dGVcIiAmJiAoUyA9IFwic2Nyb2xsSGVpZ2h0XCIsIGsgPSBcInNjcm9sbFdpZHRoXCIpKSwgdyA9IHcsIG4gPT09IFEgfHwgKG4gPT09IEogfHwgbiA9PT0gZHQpICYmIG8gPT09IEZlKSB7XG4gICAgICBUID0gaHQ7XG4gICAgICB2YXIgeCA9IGYgJiYgdyA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICB3W1NdXG4gICAgICApO1xuICAgICAgdiAtPSB4IC0gaS5oZWlnaHQsIHYgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IEogfHwgKG4gPT09IFEgfHwgbiA9PT0gaHQpICYmIG8gPT09IEZlKSB7XG4gICAgICBFID0gZHQ7XG4gICAgICB2YXIgJCA9IGYgJiYgdyA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC53aWR0aCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIHdba11cbiAgICAgICk7XG4gICAgICBtIC09ICQgLSBpLndpZHRoLCBtICo9IGwgPyAxIDogLTE7XG4gICAgfVxuICB9XG4gIHZhciBPID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IGFcbiAgfSwgcCAmJiBhaCksIE0gPSB1ID09PSAhMCA/IGxoKHtcbiAgICB4OiBtLFxuICAgIHk6IHZcbiAgfSwgdXQoZSkpIDoge1xuICAgIHg6IG0sXG4gICAgeTogdlxuICB9O1xuICBpZiAobSA9IE0ueCwgdiA9IE0ueSwgbCkge1xuICAgIHZhciBQO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBPLCAoUCA9IHt9LCBQW1RdID0geSA/IFwiMFwiIDogXCJcIiwgUFtFXSA9IEMgPyBcIjBcIiA6IFwiXCIsIFAudHJhbnNmb3JtID0gKEEuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyBtICsgXCJweCwgXCIgKyB2ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyBtICsgXCJweCwgXCIgKyB2ICsgXCJweCwgMClcIiwgUCkpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBPLCAodCA9IHt9LCB0W1RdID0geSA/IHYgKyBcInB4XCIgOiBcIlwiLCB0W0VdID0gQyA/IG0gKyBcInB4XCIgOiBcIlwiLCB0LnRyYW5zZm9ybSA9IFwiXCIsIHQpKTtcbn1cbmZ1bmN0aW9uIGNoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gZS5ncHVBY2NlbGVyYXRpb24sIG4gPSBpID09PSB2b2lkIDAgPyAhMCA6IGksIG8gPSBlLmFkYXB0aXZlLCByID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBhID0gZS5yb3VuZE9mZnNldHMsIGwgPSBhID09PSB2b2lkIDAgPyAhMCA6IGE7XG4gIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgcCA9IFR0KHQuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgXCJcIjtcbiAgICByICYmIFtcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXS5zb21lKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBwLmluZGV4T2YoZikgPj0gMDtcbiAgICB9KSAmJiBjb25zb2xlLndhcm4oW1wiUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmdcIiwgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsIGBcblxuYCwgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsIFwiZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTXCIsIFwidHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nXCIsIFwib3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLlwiLCBgXG5cbmAsIFwiV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyXCIsIFwiZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLlwiXS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgdmFyIHUgPSB7XG4gICAgcGxhY2VtZW50OiB2dCh0LnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBLZSh0LnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiB0LmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiB0LnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IG4sXG4gICAgaXNGaXhlZDogdC5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCJcbiAgfTtcbiAgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCAmJiAodC5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMucG9wcGVyLCB6byhPYmplY3QuYXNzaWduKHt9LCB1LCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgcG9zaXRpb246IHQub3B0aW9ucy5zdHJhdGVneSxcbiAgICBhZGFwdGl2ZTogcixcbiAgICByb3VuZE9mZnNldHM6IGxcbiAgfSkpKSksIHQubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsICYmICh0LnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLmFycm93LCB6byhPYmplY3QuYXNzaWduKHt9LCB1LCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgYWRhcHRpdmU6ICExLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IENvID0ge1xuICBuYW1lOiBcImNvbXB1dGVTdHlsZXNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcImJlZm9yZVdyaXRlXCIsXG4gIGZuOiBjaCxcbiAgZGF0YToge31cbn07XG52YXIgamkgPSB7XG4gIHBhc3NpdmU6ICEwXG59O1xuZnVuY3Rpb24gaGgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLmluc3RhbmNlLCBpID0gcy5vcHRpb25zLCBuID0gaS5zY3JvbGwsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBpLnJlc2l6ZSwgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IHV0KHQuZWxlbWVudHMucG9wcGVyKSwgcCA9IFtdLmNvbmNhdCh0LnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCB0LnNjcm9sbFBhcmVudHMucG9wcGVyKTtcbiAgcmV0dXJuIG8gJiYgcC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICB1LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIGppKTtcbiAgfSksIGEgJiYgbC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBqaSksIGZ1bmN0aW9uKCkge1xuICAgIG8gJiYgcC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgIHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgamkpO1xuICAgIH0pLCBhICYmIGwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnVwZGF0ZSwgamkpO1xuICB9O1xufVxuY29uc3QgQW8gPSB7XG4gIG5hbWU6IFwiZXZlbnRMaXN0ZW5lcnNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIndyaXRlXCIsXG4gIGZuOiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgZWZmZWN0OiBoaCxcbiAgZGF0YToge31cbn07XG52YXIgZGggPSB7XG4gIGxlZnQ6IFwicmlnaHRcIixcbiAgcmlnaHQ6IFwibGVmdFwiLFxuICBib3R0b206IFwidG9wXCIsXG4gIHRvcDogXCJib3R0b21cIlxufTtcbmZ1bmN0aW9uIGJzKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZGhbdF07XG4gIH0pO1xufVxudmFyIHVoID0ge1xuICBzdGFydDogXCJlbmRcIixcbiAgZW5kOiBcInN0YXJ0XCJcbn07XG5mdW5jdGlvbiBVbyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHVoW3RdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHlvKHMpIHtcbiAgdmFyIHQgPSB1dChzKSwgZSA9IHQucGFnZVhPZmZzZXQsIGkgPSB0LnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGUsXG4gICAgc2Nyb2xsVG9wOiBpXG4gIH07XG59XG5mdW5jdGlvbiB3byhzKSB7XG4gIHJldHVybiBqZSh0ZShzKSkubGVmdCArIHlvKHMpLnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBwaChzLCB0KSB7XG4gIHZhciBlID0gdXQocyksIGkgPSB0ZShzKSwgbiA9IGUudmlzdWFsVmlld3BvcnQsIG8gPSBpLmNsaWVudFdpZHRoLCByID0gaS5jbGllbnRIZWlnaHQsIGEgPSAwLCBsID0gMDtcbiAgaWYgKG4pIHtcbiAgICBvID0gbi53aWR0aCwgciA9IG4uaGVpZ2h0O1xuICAgIHZhciBwID0gQWwoKTtcbiAgICAocCB8fCAhcCAmJiB0ID09PSBcImZpeGVkXCIpICYmIChhID0gbi5vZmZzZXRMZWZ0LCBsID0gbi5vZmZzZXRUb3ApO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEgKyB3byhzKSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBfaChzKSB7XG4gIHZhciB0LCBlID0gdGUocyksIGkgPSB5byhzKSwgbiA9ICh0ID0gcy5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5ib2R5LCBvID0gZ2UoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgbiA/IG4uc2Nyb2xsV2lkdGggOiAwLCBuID8gbi5jbGllbnRXaWR0aCA6IDApLCByID0gZ2UoZS5zY3JvbGxIZWlnaHQsIGUuY2xpZW50SGVpZ2h0LCBuID8gbi5zY3JvbGxIZWlnaHQgOiAwLCBuID8gbi5jbGllbnRIZWlnaHQgOiAwKSwgYSA9IC1pLnNjcm9sbExlZnQgKyB3byhzKSwgbCA9IC1pLnNjcm9sbFRvcDtcbiAgcmV0dXJuIFR0KG4gfHwgZSkuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChhICs9IGdlKGUuY2xpZW50V2lkdGgsIG4gPyBuLmNsaWVudFdpZHRoIDogMCkgLSBvKSwge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogcixcbiAgICB4OiBhLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHhvKHMpIHtcbiAgdmFyIHQgPSBUdChzKSwgZSA9IHQub3ZlcmZsb3csIGkgPSB0Lm92ZXJmbG93WCwgbiA9IHQub3ZlcmZsb3dZO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KGUgKyBuICsgaSk7XG59XG5mdW5jdGlvbiBTbChzKSB7XG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKE50KHMpKSA+PSAwID8gcy5vd25lckRvY3VtZW50LmJvZHkgOiBjdChzKSAmJiB4byhzKSA/IHMgOiBTbChIcyhzKSk7XG59XG5mdW5jdGlvbiBDaShzLCB0KSB7XG4gIHZhciBlO1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBbXSk7XG4gIHZhciBpID0gU2wocyksIG4gPSBpID09PSAoKGUgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBlLmJvZHkpLCBvID0gdXQoaSksIHIgPSBuID8gW29dLmNvbmNhdChvLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCB4byhpKSA/IGkgOiBbXSkgOiBpLCBhID0gdC5jb25jYXQocik7XG4gIHJldHVybiBuID8gYSA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICBhLmNvbmNhdChDaShIcyhyKSkpXG4gICk7XG59XG5mdW5jdGlvbiBpbyhzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzLCB7XG4gICAgbGVmdDogcy54LFxuICAgIHRvcDogcy55LFxuICAgIHJpZ2h0OiBzLnggKyBzLndpZHRoLFxuICAgIGJvdHRvbTogcy55ICsgcy5oZWlnaHRcbiAgfSk7XG59XG5mdW5jdGlvbiBmaChzLCB0KSB7XG4gIHZhciBlID0gamUocywgITEsIHQgPT09IFwiZml4ZWRcIik7XG4gIHJldHVybiBlLnRvcCA9IGUudG9wICsgcy5jbGllbnRUb3AsIGUubGVmdCA9IGUubGVmdCArIHMuY2xpZW50TGVmdCwgZS5ib3R0b20gPSBlLnRvcCArIHMuY2xpZW50SGVpZ2h0LCBlLnJpZ2h0ID0gZS5sZWZ0ICsgcy5jbGllbnRXaWR0aCwgZS53aWR0aCA9IHMuY2xpZW50V2lkdGgsIGUuaGVpZ2h0ID0gcy5jbGllbnRIZWlnaHQsIGUueCA9IGUubGVmdCwgZS55ID0gZS50b3AsIGU7XG59XG5mdW5jdGlvbiBYbyhzLCB0LCBlKSB7XG4gIHJldHVybiB0ID09PSBtbyA/IGlvKHBoKHMsIGUpKSA6IFRlKHQpID8gZmgodCwgZSkgOiBpbyhfaCh0ZShzKSkpO1xufVxuZnVuY3Rpb24gbWgocykge1xuICB2YXIgdCA9IENpKEhzKHMpKSwgZSA9IFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5kZXhPZihUdChzKS5wb3NpdGlvbikgPj0gMCwgaSA9IGUgJiYgY3QocykgPyBEaShzKSA6IHM7XG4gIHJldHVybiBUZShpKSA/IHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gVGUobikgJiYgeWwobiwgaSkgJiYgTnQobikgIT09IFwiYm9keVwiO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZ2gocywgdCwgZSwgaSkge1xuICB2YXIgbiA9IHQgPT09IFwiY2xpcHBpbmdQYXJlbnRzXCIgPyBtaChzKSA6IFtdLmNvbmNhdCh0KSwgbyA9IFtdLmNvbmNhdChuLCBbZV0pLCByID0gb1swXSwgYSA9IG8ucmVkdWNlKGZ1bmN0aW9uKGwsIHApIHtcbiAgICB2YXIgdSA9IFhvKHMsIHAsIGkpO1xuICAgIHJldHVybiBsLnRvcCA9IGdlKHUudG9wLCBsLnRvcCksIGwucmlnaHQgPSBScyh1LnJpZ2h0LCBsLnJpZ2h0KSwgbC5ib3R0b20gPSBScyh1LmJvdHRvbSwgbC5ib3R0b20pLCBsLmxlZnQgPSBnZSh1LmxlZnQsIGwubGVmdCksIGw7XG4gIH0sIFhvKHMsIHIsIGkpKTtcbiAgcmV0dXJuIGEud2lkdGggPSBhLnJpZ2h0IC0gYS5sZWZ0LCBhLmhlaWdodCA9IGEuYm90dG9tIC0gYS50b3AsIGEueCA9IGEubGVmdCwgYS55ID0gYS50b3AsIGE7XG59XG5mdW5jdGlvbiBJbChzKSB7XG4gIHZhciB0ID0gcy5yZWZlcmVuY2UsIGUgPSBzLmVsZW1lbnQsIGkgPSBzLnBsYWNlbWVudCwgbiA9IGkgPyB2dChpKSA6IG51bGwsIG8gPSBpID8gS2UoaSkgOiBudWxsLCByID0gdC54ICsgdC53aWR0aCAvIDIgLSBlLndpZHRoIC8gMiwgYSA9IHQueSArIHQuaGVpZ2h0IC8gMiAtIGUuaGVpZ2h0IC8gMiwgbDtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSBROlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55IC0gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGh0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGR0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSjpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCAtIGUud2lkdGgsXG4gICAgICAgIHk6IGFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH07XG4gIH1cbiAgdmFyIHAgPSBuID8gRW8obikgOiBudWxsO1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgdmFyIHUgPSBwID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIHZlOlxuICAgICAgICBsW3BdID0gbFtwXSAtICh0W3VdIC8gMiAtIGVbdV0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZlOlxuICAgICAgICBsW3BdID0gbFtwXSArICh0W3VdIC8gMiAtIGVbdV0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24gemUocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gaSA9PT0gdm9pZCAwID8gcy5wbGFjZW1lbnQgOiBpLCBvID0gZS5zdHJhdGVneSwgciA9IG8gPT09IHZvaWQgMCA/IHMuc3RyYXRlZ3kgOiBvLCBhID0gZS5ib3VuZGFyeSwgbCA9IGEgPT09IHZvaWQgMCA/IHVsIDogYSwgcCA9IGUucm9vdEJvdW5kYXJ5LCB1ID0gcCA9PT0gdm9pZCAwID8gbW8gOiBwLCBmID0gZS5lbGVtZW50Q29udGV4dCwgXyA9IGYgPT09IHZvaWQgMCA/IEllIDogZiwgbSA9IGUuYWx0Qm91bmRhcnksIGcgPSBtID09PSB2b2lkIDAgPyAhMSA6IG0sIHYgPSBlLnBhZGRpbmcsIGIgPSB2ID09PSB2b2lkIDAgPyAwIDogdiwgQyA9IHhsKHR5cGVvZiBiICE9IFwibnVtYmVyXCIgPyBiIDoga2woYiwgcWUpKSwgeSA9IF8gPT09IEllID8gcGwgOiBJZSwgRSA9IHMucmVjdHMucG9wcGVyLCBUID0gcy5lbGVtZW50c1tnID8geSA6IF9dLCBBID0gZ2goVGUoVCkgPyBUIDogVC5jb250ZXh0RWxlbWVudCB8fCB0ZShzLmVsZW1lbnRzLnBvcHBlciksIGwsIHUsIHIpLCB3ID0gamUocy5lbGVtZW50cy5yZWZlcmVuY2UpLCBTID0gSWwoe1xuICAgIHJlZmVyZW5jZTogdyxcbiAgICBlbGVtZW50OiBFLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiBuXG4gIH0pLCBrID0gaW8oT2JqZWN0LmFzc2lnbih7fSwgRSwgUykpLCB4ID0gXyA9PT0gSWUgPyBrIDogdywgJCA9IHtcbiAgICB0b3A6IEEudG9wIC0geC50b3AgKyBDLnRvcCxcbiAgICBib3R0b206IHguYm90dG9tIC0gQS5ib3R0b20gKyBDLmJvdHRvbSxcbiAgICBsZWZ0OiBBLmxlZnQgLSB4LmxlZnQgKyBDLmxlZnQsXG4gICAgcmlnaHQ6IHgucmlnaHQgLSBBLnJpZ2h0ICsgQy5yaWdodFxuICB9LCBPID0gcy5tb2RpZmllcnNEYXRhLm9mZnNldDtcbiAgaWYgKF8gPT09IEllICYmIE8pIHtcbiAgICB2YXIgTSA9IE9bbl07XG4gICAgT2JqZWN0LmtleXMoJCkuZm9yRWFjaChmdW5jdGlvbihQKSB7XG4gICAgICB2YXIgdHQgPSBbZHQsIGh0XS5pbmRleE9mKFApID49IDAgPyAxIDogLTEsIGV0ID0gW1EsIGh0XS5pbmRleE9mKFApID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgJFtQXSArPSBNW2V0XSAqIHR0O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAkO1xufVxuZnVuY3Rpb24gYmgocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gZS5ib3VuZGFyeSwgbyA9IGUucm9vdEJvdW5kYXJ5LCByID0gZS5wYWRkaW5nLCBhID0gZS5mbGlwVmFyaWF0aW9ucywgbCA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCBwID0gbCA9PT0gdm9pZCAwID8gZ28gOiBsLCB1ID0gS2UoaSksIGYgPSB1ID8gYSA/IHRvIDogdG8uZmlsdGVyKGZ1bmN0aW9uKGcpIHtcbiAgICByZXR1cm4gS2UoZykgPT09IHU7XG4gIH0pIDogcWUsIF8gPSBmLmZpbHRlcihmdW5jdGlvbihnKSB7XG4gICAgcmV0dXJuIHAuaW5kZXhPZihnKSA+PSAwO1xuICB9KTtcbiAgXy5sZW5ndGggPT09IDAgJiYgKF8gPSBmLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbXCJQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnlcIiwgXCJwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb25cIiwgXCJvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLlwiLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oXCIgXCIpKSk7XG4gIHZhciBtID0gXy5yZWR1Y2UoZnVuY3Rpb24oZywgdikge1xuICAgIHJldHVybiBnW3ZdID0gemUocywge1xuICAgICAgcGxhY2VtZW50OiB2LFxuICAgICAgYm91bmRhcnk6IG4sXG4gICAgICByb290Qm91bmRhcnk6IG8sXG4gICAgICBwYWRkaW5nOiByXG4gICAgfSlbdnQodildLCBnO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtKS5zb3J0KGZ1bmN0aW9uKGcsIHYpIHtcbiAgICByZXR1cm4gbVtnXSAtIG1bdl07XG4gIH0pO1xufVxuZnVuY3Rpb24gdmgocykge1xuICBpZiAodnQocykgPT09IElpKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSBicyhzKTtcbiAgcmV0dXJuIFtVbyhzKSwgdCwgVW8odCldO1xufVxuZnVuY3Rpb24gVGgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWU7XG4gIGlmICghdC5tb2RpZmllcnNEYXRhW2ldLl9za2lwKSB7XG4gICAgZm9yICh2YXIgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIGwgPSBlLmZhbGxiYWNrUGxhY2VtZW50cywgcCA9IGUucGFkZGluZywgdSA9IGUuYm91bmRhcnksIGYgPSBlLnJvb3RCb3VuZGFyeSwgXyA9IGUuYWx0Qm91bmRhcnksIG0gPSBlLmZsaXBWYXJpYXRpb25zLCBnID0gbSA9PT0gdm9pZCAwID8gITAgOiBtLCB2ID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIGIgPSB0Lm9wdGlvbnMucGxhY2VtZW50LCBDID0gdnQoYiksIHkgPSBDID09PSBiLCBFID0gbCB8fCAoeSB8fCAhZyA/IFticyhiKV0gOiB2aChiKSksIFQgPSBbYl0uY29uY2F0KEUpLnJlZHVjZShmdW5jdGlvbihBZSwgSHQpIHtcbiAgICAgIHJldHVybiBBZS5jb25jYXQodnQoSHQpID09PSBJaSA/IGJoKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBIdCxcbiAgICAgICAgYm91bmRhcnk6IHUsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogZixcbiAgICAgICAgcGFkZGluZzogcCxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IGcsXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogdlxuICAgICAgfSkgOiBIdCk7XG4gICAgfSwgW10pLCBBID0gdC5yZWN0cy5yZWZlcmVuY2UsIHcgPSB0LnJlY3RzLnBvcHBlciwgUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGsgPSAhMCwgeCA9IFRbMF0sICQgPSAwOyAkIDwgVC5sZW5ndGg7ICQrKykge1xuICAgICAgdmFyIE8gPSBUWyRdLCBNID0gdnQoTyksIFAgPSBLZShPKSA9PT0gdmUsIHR0ID0gW1EsIGh0XS5pbmRleE9mKE0pID49IDAsIGV0ID0gdHQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBVID0gemUodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IE8sXG4gICAgICAgIGJvdW5kYXJ5OiB1LFxuICAgICAgICByb290Qm91bmRhcnk6IGYsXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBfLFxuICAgICAgICBwYWRkaW5nOiBwXG4gICAgICB9KSwgbXQgPSB0dCA/IFAgPyBkdCA6IEogOiBQID8gaHQgOiBRO1xuICAgICAgQVtldF0gPiB3W2V0XSAmJiAobXQgPSBicyhtdCkpO1xuICAgICAgdmFyIEhpID0gYnMobXQpLCBpZSA9IFtdO1xuICAgICAgaWYgKG8gJiYgaWUucHVzaChVW01dIDw9IDApLCBhICYmIGllLnB1c2goVVttdF0gPD0gMCwgVVtIaV0gPD0gMCksIGllLmV2ZXJ5KGZ1bmN0aW9uKEFlKSB7XG4gICAgICAgIHJldHVybiBBZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHggPSBPLCBrID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgUy5zZXQoTywgaWUpO1xuICAgIH1cbiAgICBpZiAoaylcbiAgICAgIGZvciAodmFyIFdpID0gZyA/IDMgOiAxLCBVcyA9IGZ1bmN0aW9uKEh0KSB7XG4gICAgICAgIHZhciBpaSA9IFQuZmluZChmdW5jdGlvbihGaSkge1xuICAgICAgICAgIHZhciBzZSA9IFMuZ2V0KEZpKTtcbiAgICAgICAgICBpZiAoc2UpXG4gICAgICAgICAgICByZXR1cm4gc2Uuc2xpY2UoMCwgSHQpLmV2ZXJ5KGZ1bmN0aW9uKFhzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBYcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlpKVxuICAgICAgICAgIHJldHVybiB4ID0gaWksIFwiYnJlYWtcIjtcbiAgICAgIH0sIGVpID0gV2k7IGVpID4gMDsgZWktLSkge1xuICAgICAgICB2YXIgVmkgPSBVcyhlaSk7XG4gICAgICAgIGlmIChWaSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHQucGxhY2VtZW50ICE9PSB4ICYmICh0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXAgPSAhMCwgdC5wbGFjZW1lbnQgPSB4LCB0LnJlc2V0ID0gITApO1xuICB9XG59XG5jb25zdCBEbCA9IHtcbiAgbmFtZTogXCJmbGlwXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBUaCxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wib2Zmc2V0XCJdLFxuICBkYXRhOiB7XG4gICAgX3NraXA6ICExXG4gIH1cbn07XG5mdW5jdGlvbiBHbyhzLCB0LCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pLCB7XG4gICAgdG9wOiBzLnRvcCAtIHQuaGVpZ2h0IC0gZS55LFxuICAgIHJpZ2h0OiBzLnJpZ2h0IC0gdC53aWR0aCArIGUueCxcbiAgICBib3R0b206IHMuYm90dG9tIC0gdC5oZWlnaHQgKyBlLnksXG4gICAgbGVmdDogcy5sZWZ0IC0gdC53aWR0aCAtIGUueFxuICB9O1xufVxuZnVuY3Rpb24gcW8ocykge1xuICByZXR1cm4gW1EsIGR0LCBodCwgSl0uc29tZShmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHNbdF0gPj0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBFaChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMubmFtZSwgaSA9IHQucmVjdHMucmVmZXJlbmNlLCBuID0gdC5yZWN0cy5wb3BwZXIsIG8gPSB0Lm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93LCByID0gemUodCwge1xuICAgIGVsZW1lbnRDb250ZXh0OiBcInJlZmVyZW5jZVwiXG4gIH0pLCBhID0gemUodCwge1xuICAgIGFsdEJvdW5kYXJ5OiAhMFxuICB9KSwgbCA9IEdvKHIsIGkpLCBwID0gR28oYSwgbiwgbyksIHUgPSBxbyhsKSwgZiA9IHFvKHApO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiBsLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHAsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IHUsXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogZlxuICB9LCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiB1LFxuICAgIFwiZGF0YS1wb3BwZXItZXNjYXBlZFwiOiBmXG4gIH0pO1xufVxuY29uc3QgJGwgPSB7XG4gIG5hbWU6IFwiaGlkZVwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl0sXG4gIGZuOiBFaFxufTtcbmZ1bmN0aW9uIENoKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSB2dChzKSwgbiA9IFtKLCBRXS5pbmRleE9mKGkpID49IDAgPyAtMSA6IDEsIG8gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IHNcbiAgfSkpIDogZSwgciA9IG9bMF0sIGEgPSBvWzFdO1xuICByZXR1cm4gciA9IHIgfHwgMCwgYSA9IChhIHx8IDApICogbiwgW0osIGR0XS5pbmRleE9mKGkpID49IDAgPyB7XG4gICAgeDogYSxcbiAgICB5OiByXG4gIH0gOiB7XG4gICAgeDogcixcbiAgICB5OiBhXG4gIH07XG59XG5mdW5jdGlvbiBBaChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUub2Zmc2V0LCBvID0gbiA9PT0gdm9pZCAwID8gWzAsIDBdIDogbiwgciA9IGdvLnJlZHVjZShmdW5jdGlvbih1LCBmKSB7XG4gICAgcmV0dXJuIHVbZl0gPSBDaChmLCB0LnJlY3RzLCBvKSwgdTtcbiAgfSwge30pLCBhID0gclt0LnBsYWNlbWVudF0sIGwgPSBhLngsIHAgPSBhLnk7XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0gbCwgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSBwKSwgdC5tb2RpZmllcnNEYXRhW2ldID0gcjtcbn1cbmNvbnN0IExsID0ge1xuICBuYW1lOiBcIm9mZnNldFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgZm46IEFoXG59O1xuZnVuY3Rpb24geWgocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWU7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IElsKHtcbiAgICByZWZlcmVuY2U6IHQucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IGtvID0ge1xuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcInJlYWRcIixcbiAgZm46IHloLFxuICBkYXRhOiB7fVxufTtcbmZ1bmN0aW9uIHdoKHMpIHtcbiAgcmV0dXJuIHMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIHhoKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lLCBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICExIDogciwgbCA9IGUuYm91bmRhcnksIHAgPSBlLnJvb3RCb3VuZGFyeSwgdSA9IGUuYWx0Qm91bmRhcnksIGYgPSBlLnBhZGRpbmcsIF8gPSBlLnRldGhlciwgbSA9IF8gPT09IHZvaWQgMCA/ICEwIDogXywgZyA9IGUudGV0aGVyT2Zmc2V0LCB2ID0gZyA9PT0gdm9pZCAwID8gMCA6IGcsIGIgPSB6ZSh0LCB7XG4gICAgYm91bmRhcnk6IGwsXG4gICAgcm9vdEJvdW5kYXJ5OiBwLFxuICAgIHBhZGRpbmc6IGYsXG4gICAgYWx0Qm91bmRhcnk6IHVcbiAgfSksIEMgPSB2dCh0LnBsYWNlbWVudCksIHkgPSBLZSh0LnBsYWNlbWVudCksIEUgPSAheSwgVCA9IEVvKEMpLCBBID0gd2goVCksIHcgPSB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgUyA9IHQucmVjdHMucmVmZXJlbmNlLCBrID0gdC5yZWN0cy5wb3BwZXIsIHggPSB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgPyB2KE9iamVjdC5hc3NpZ24oe30sIHQucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pKSA6IHYsICQgPSB0eXBlb2YgeCA9PSBcIm51bWJlclwiID8ge1xuICAgIG1haW5BeGlzOiB4LFxuICAgIGFsdEF4aXM6IHhcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgeCksIE8gPSB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gdC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF0gOiBudWxsLCBNID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAodykge1xuICAgIGlmIChvKSB7XG4gICAgICB2YXIgUCwgdHQgPSBUID09PSBcInlcIiA/IFEgOiBKLCBldCA9IFQgPT09IFwieVwiID8gaHQgOiBkdCwgVSA9IFQgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgbXQgPSB3W1RdLCBIaSA9IG10ICsgYlt0dF0sIGllID0gbXQgLSBiW2V0XSwgV2kgPSBtID8gLWtbVV0gLyAyIDogMCwgVXMgPSB5ID09PSB2ZSA/IFNbVV0gOiBrW1VdLCBlaSA9IHkgPT09IHZlID8gLWtbVV0gOiAtU1tVXSwgVmkgPSB0LmVsZW1lbnRzLmFycm93LCBBZSA9IG0gJiYgVmkgPyBUbyhWaSkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIEh0ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IHdsKCksIGlpID0gSHRbdHRdLCBGaSA9IEh0W2V0XSwgc2UgPSBFaSgwLCBTW1VdLCBBZVtVXSksIFhzID0gRSA/IFNbVV0gLyAyIC0gV2kgLSBzZSAtIGlpIC0gJC5tYWluQXhpcyA6IFVzIC0gc2UgLSBpaSAtICQubWFpbkF4aXMsIFNjID0gRSA/IC1TW1VdIC8gMiArIFdpICsgc2UgKyBGaSArICQubWFpbkF4aXMgOiBlaSArIHNlICsgRmkgKyAkLm1haW5BeGlzLCBHcyA9IHQuZWxlbWVudHMuYXJyb3cgJiYgRGkodC5lbGVtZW50cy5hcnJvdyksIEljID0gR3MgPyBUID09PSBcInlcIiA/IEdzLmNsaWVudFRvcCB8fCAwIDogR3MuY2xpZW50TGVmdCB8fCAwIDogMCwgTW8gPSAoUCA9IE8gPT0gbnVsbCA/IHZvaWQgMCA6IE9bVF0pICE9IG51bGwgPyBQIDogMCwgRGMgPSBtdCArIFhzIC0gTW8gLSBJYywgJGMgPSBtdCArIFNjIC0gTW8sIE5vID0gRWkobSA/IFJzKEhpLCBEYykgOiBIaSwgbXQsIG0gPyBnZShpZSwgJGMpIDogaWUpO1xuICAgICAgd1tUXSA9IE5vLCBNW1RdID0gTm8gLSBtdDtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIHZhciBSbywgTGMgPSBUID09PSBcInhcIiA/IFEgOiBKLCBNYyA9IFQgPT09IFwieFwiID8gaHQgOiBkdCwgbmUgPSB3W0FdLCBZaSA9IEEgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgUG8gPSBuZSArIGJbTGNdLCBCbyA9IG5lIC0gYltNY10sIHFzID0gW1EsIEpdLmluZGV4T2YoQykgIT09IC0xLCBIbyA9IChSbyA9IE8gPT0gbnVsbCA/IHZvaWQgMCA6IE9bQV0pICE9IG51bGwgPyBSbyA6IDAsIFdvID0gcXMgPyBQbyA6IG5lIC0gU1tZaV0gLSBrW1lpXSAtIEhvICsgJC5hbHRBeGlzLCBWbyA9IHFzID8gbmUgKyBTW1lpXSArIGtbWWldIC0gSG8gLSAkLmFsdEF4aXMgOiBCbywgRm8gPSBtICYmIHFzID8gc2goV28sIG5lLCBWbykgOiBFaShtID8gV28gOiBQbywgbmUsIG0gPyBWbyA6IEJvKTtcbiAgICAgIHdbQV0gPSBGbywgTVtBXSA9IEZvIC0gbmU7XG4gICAgfVxuICAgIHQubW9kaWZpZXJzRGF0YVtpXSA9IE07XG4gIH1cbn1cbmNvbnN0IE1sID0ge1xuICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogeGgsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxufTtcbmZ1bmN0aW9uIGtoKHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzLnNjcm9sbFRvcFxuICB9O1xufVxuZnVuY3Rpb24gT2gocykge1xuICByZXR1cm4gcyA9PT0gdXQocykgfHwgIWN0KHMpID8geW8ocykgOiBraChzKTtcbn1cbmZ1bmN0aW9uIFNoKHMpIHtcbiAgdmFyIHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBlID0gWWUodC53aWR0aCkgLyBzLm9mZnNldFdpZHRoIHx8IDEsIGkgPSBZZSh0LmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gZSAhPT0gMSB8fCBpICE9PSAxO1xufVxuZnVuY3Rpb24gSWgocywgdCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XG4gIHZhciBpID0gY3QodCksIG4gPSBjdCh0KSAmJiBTaCh0KSwgbyA9IHRlKHQpLCByID0gamUocywgbiwgZSksIGEgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfSwgbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgcmV0dXJuIChpIHx8ICFpICYmICFlKSAmJiAoKE50KHQpICE9PSBcImJvZHlcIiB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgeG8obykpICYmIChhID0gT2godCkpLCBjdCh0KSA/IChsID0gamUodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogbyAmJiAobC54ID0gd28obykpKSwge1xuICAgIHg6IHIubGVmdCArIGEuc2Nyb2xsTGVmdCAtIGwueCxcbiAgICB5OiByLnRvcCArIGEuc2Nyb2xsVG9wIC0gbC55LFxuICAgIHdpZHRoOiByLndpZHRoLFxuICAgIGhlaWdodDogci5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIERoKHMpIHtcbiAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgaSA9IFtdO1xuICBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIHQuc2V0KG8ubmFtZSwgbyk7XG4gIH0pO1xuICBmdW5jdGlvbiBuKG8pIHtcbiAgICBlLmFkZChvLm5hbWUpO1xuICAgIHZhciByID0gW10uY29uY2F0KG8ucmVxdWlyZXMgfHwgW10sIG8ucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgci5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmICghZS5oYXMoYSkpIHtcbiAgICAgICAgdmFyIGwgPSB0LmdldChhKTtcbiAgICAgICAgbCAmJiBuKGwpO1xuICAgICAgfVxuICAgIH0pLCBpLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgZS5oYXMoby5uYW1lKSB8fCBuKG8pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uICRoKHMpIHtcbiAgdmFyIHQgPSBEaChzKTtcbiAgcmV0dXJuIE5zLnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgcmV0dXJuIGUuY29uY2F0KHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuLnBoYXNlID09PSBpO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gTGgocykge1xuICB2YXIgdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24oZSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IHZvaWQgMCwgZShzKCkpO1xuICAgICAgfSk7XG4gICAgfSkpLCB0O1xuICB9O1xufVxuZnVuY3Rpb24gV3Qocykge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIGkgPSAxOyBpIDwgdDsgaSsrKVxuICAgIGVbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICByZXR1cm4gW10uY29uY2F0KGUpLnJlZHVjZShmdW5jdGlvbihuLCBvKSB7XG4gICAgcmV0dXJuIG4ucmVwbGFjZSgvJXMvLCBvKTtcbiAgfSwgcyk7XG59XG52YXIgcmUgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcycsIE1oID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJywgWm8gPSBbXCJuYW1lXCIsIFwiZW5hYmxlZFwiLCBcInBoYXNlXCIsIFwiZm5cIiwgXCJlZmZlY3RcIiwgXCJyZXF1aXJlc1wiLCBcIm9wdGlvbnNcIl07XG5mdW5jdGlvbiBOaChzKSB7XG4gIHMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgW10uY29uY2F0KE9iamVjdC5rZXlzKHQpLCBabykuZmlsdGVyKGZ1bmN0aW9uKGUsIGksIG4pIHtcbiAgICAgIHJldHVybiBuLmluZGV4T2YoZSkgPT09IGk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICB0eXBlb2YgdC5uYW1lICE9IFwic3RyaW5nXCIgJiYgY29uc29sZS5lcnJvcihXdChyZSwgU3RyaW5nKHQubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgJ1wiJyArIFN0cmluZyh0Lm5hbWUpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5hYmxlZFwiOlxuICAgICAgICAgIHR5cGVvZiB0LmVuYWJsZWQgIT0gXCJib29sZWFuXCIgJiYgY29uc29sZS5lcnJvcihXdChyZSwgdC5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCAnXCInICsgU3RyaW5nKHQuZW5hYmxlZCkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwaGFzZVwiOlxuICAgICAgICAgIE5zLmluZGV4T2YodC5waGFzZSkgPCAwICYmIGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgTnMuam9pbihcIiwgXCIpLCAnXCInICsgU3RyaW5nKHQucGhhc2UpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm5cIjpcbiAgICAgICAgICB0eXBlb2YgdC5mbiAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihXdChyZSwgdC5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsICdcIicgKyBTdHJpbmcodC5mbikgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlZmZlY3RcIjpcbiAgICAgICAgICB0LmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiB0LmVmZmVjdCAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihXdChyZSwgdC5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNcIjpcbiAgICAgICAgICB0LnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodC5yZXF1aXJlcykgJiYgY29uc29sZS5lcnJvcihXdChyZSwgdC5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlcykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlc0lmRXhpc3RzXCI6XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0LnJlcXVpcmVzSWZFeGlzdHMpIHx8IGNvbnNvbGUuZXJyb3IoV3QocmUsIHQubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlc0lmRXhpc3RzKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9wdGlvbnNcIjpcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXCInICsgdC5uYW1lICsgJ1wiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSAnICsgWm8ubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgaSArICdcIic7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpICsgJzsgYnV0IFwiJyArIGUgKyAnXCIgd2FzIHByb3ZpZGVkLicpO1xuICAgICAgfVxuICAgICAgdC5yZXF1aXJlcyAmJiB0LnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBzLmZpbmQoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLm5hbWUgPT09IGk7XG4gICAgICAgIH0pID09IG51bGwgJiYgY29uc29sZS5lcnJvcihXdChNaCwgU3RyaW5nKHQubmFtZSksIGksIGkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFJoKHMsIHQpIHtcbiAgdmFyIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gcy5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgIHZhciBuID0gdChpKTtcbiAgICBpZiAoIWUuaGFzKG4pKVxuICAgICAgcmV0dXJuIGUuYWRkKG4pLCAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBQaChzKSB7XG4gIHZhciB0ID0gcy5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHZhciBuID0gZVtpLm5hbWVdO1xuICAgIHJldHVybiBlW2kubmFtZV0gPSBuID8gT2JqZWN0LmFzc2lnbih7fSwgbiwgaSwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgbi5vcHRpb25zLCBpLm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbi5kYXRhLCBpLmRhdGEpXG4gICAgfSkgOiBpLCBlO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0KS5tYXAoZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0W2VdO1xuICB9KTtcbn1cbnZhciBRbyA9IFwiUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuXCIsIEJoID0gXCJQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLlwiLCBKbyA9IHtcbiAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiXG59O1xuZnVuY3Rpb24gdHIoKSB7XG4gIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KHMpLCBlID0gMDsgZSA8IHM7IGUrKylcbiAgICB0W2VdID0gYXJndW1lbnRzW2VdO1xuICByZXR1cm4gIXQuc29tZShmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuICEoaSAmJiB0eXBlb2YgaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT0gXCJmdW5jdGlvblwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBXcyhzKSB7XG4gIHMgPT09IHZvaWQgMCAmJiAocyA9IHt9KTtcbiAgdmFyIHQgPSBzLCBlID0gdC5kZWZhdWx0TW9kaWZpZXJzLCBpID0gZSA9PT0gdm9pZCAwID8gW10gOiBlLCBuID0gdC5kZWZhdWx0T3B0aW9ucywgbyA9IG4gPT09IHZvaWQgMCA/IEpvIDogbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGwsIHApIHtcbiAgICBwID09PSB2b2lkIDAgJiYgKHAgPSBvKTtcbiAgICB2YXIgdSA9IHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgSm8sIG8pLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGEsXG4gICAgICAgIHBvcHBlcjogbFxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH0sIGYgPSBbXSwgXyA9ICExLCBtID0ge1xuICAgICAgc3RhdGU6IHUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihDKSB7XG4gICAgICAgIHZhciB5ID0gdHlwZW9mIEMgPT0gXCJmdW5jdGlvblwiID8gQyh1Lm9wdGlvbnMpIDogQztcbiAgICAgICAgdigpLCB1Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvLCB1Lm9wdGlvbnMsIHkpLCB1LnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBUZShhKSA/IENpKGEpIDogYS5jb250ZXh0RWxlbWVudCA/IENpKGEuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBDaShsKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgRSA9ICRoKFBoKFtdLmNvbmNhdChpLCB1Lm9wdGlvbnMubW9kaWZpZXJzKSkpO1xuICAgICAgICBpZiAodS5vcmRlcmVkTW9kaWZpZXJzID0gRS5maWx0ZXIoZnVuY3Rpb24oTykge1xuICAgICAgICAgIHJldHVybiBPLmVuYWJsZWQ7XG4gICAgICAgIH0pLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgVCA9IFJoKFtdLmNvbmNhdChFLCB1Lm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgdmFyIE0gPSBPLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gTTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoTmgoVCksIHZ0KHUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBJaSkge1xuICAgICAgICAgICAgdmFyIEEgPSB1Lm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbihPKSB7XG4gICAgICAgICAgICAgIHZhciBNID0gTy5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gTSA9PT0gXCJmbGlwXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEEgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsIFwicHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3ID0gVHQobCksIFMgPSB3Lm1hcmdpblRvcCwgayA9IHcubWFyZ2luUmlnaHQsIHggPSB3Lm1hcmdpbkJvdHRvbSwgJCA9IHcubWFyZ2luTGVmdDtcbiAgICAgICAgICBbUywgaywgeCwgJF0uc29tZShmdW5jdGlvbihPKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChPKTtcbiAgICAgICAgICB9KSAmJiBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgXCJiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS5cIiwgXCJUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzXCIsIFwidGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGBcIiwgXCJtb2RpZmllcnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZygpLCBtLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfKSB7XG4gICAgICAgICAgdmFyIEMgPSB1LmVsZW1lbnRzLCB5ID0gQy5yZWZlcmVuY2UsIEUgPSBDLnBvcHBlcjtcbiAgICAgICAgICBpZiAoIXRyKHksIEUpKSB7XG4gICAgICAgICAgICAoe30pLk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFFvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdS5yZWN0cyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogSWgoeSwgRGkoRSksIHUub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiKSxcbiAgICAgICAgICAgIHBvcHBlcjogVG8oRSlcbiAgICAgICAgICB9LCB1LnJlc2V0ID0gITEsIHUucGxhY2VtZW50ID0gdS5vcHRpb25zLnBsYWNlbWVudCwgdS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgcmV0dXJuIHUubW9kaWZpZXJzRGF0YVtPLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgTy5kYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHZhciBUID0gMCwgQSA9IDA7IEEgPCB1Lm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBBKyspIHtcbiAgICAgICAgICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFQgKz0gMSwgVCA+IDEwMCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihCaCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUucmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICAgIHUucmVzZXQgPSAhMSwgQSA9IC0xO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ID0gdS5vcmRlcmVkTW9kaWZpZXJzW0FdLCBTID0gdy5mbiwgayA9IHcub3B0aW9ucywgeCA9IGsgPT09IHZvaWQgMCA/IHt9IDogaywgJCA9IHcubmFtZTtcbiAgICAgICAgICAgIHR5cGVvZiBTID09IFwiZnVuY3Rpb25cIiAmJiAodSA9IFMoe1xuICAgICAgICAgICAgICBzdGF0ZTogdSxcbiAgICAgICAgICAgICAgb3B0aW9uczogeCxcbiAgICAgICAgICAgICAgbmFtZTogJCxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IG1cbiAgICAgICAgICAgIH0pIHx8IHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IExoKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYikge1xuICAgICAgICAgIG0uZm9yY2VVcGRhdGUoKSwgYih1KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2KCksIF8gPSAhMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghdHIoYSwgbCkpXG4gICAgICByZXR1cm4ge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoUW8pLCBtO1xuICAgIG0uc2V0T3B0aW9ucyhwKS50aGVuKGZ1bmN0aW9uKGIpIHtcbiAgICAgICFfICYmIHAub25GaXJzdFVwZGF0ZSAmJiBwLm9uRmlyc3RVcGRhdGUoYik7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIHUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgdmFyIEMgPSBiLm5hbWUsIHkgPSBiLm9wdGlvbnMsIEUgPSB5ID09PSB2b2lkIDAgPyB7fSA6IHksIFQgPSBiLmVmZmVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHZhciBBID0gVCh7XG4gICAgICAgICAgICBzdGF0ZTogdSxcbiAgICAgICAgICAgIG5hbWU6IEMsXG4gICAgICAgICAgICBpbnN0YW5jZTogbSxcbiAgICAgICAgICAgIG9wdGlvbnM6IEVcbiAgICAgICAgICB9KSwgdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH07XG4gICAgICAgICAgZi5wdXNoKEEgfHwgdyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIoKTtcbiAgICAgIH0pLCBmID0gW107XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xufVxudmFyIEhoID0gLyogQF9fUFVSRV9fICovIFdzKCksIFdoID0gW0FvLCBrbywgQ28sIHZvXSwgVmggPSAvKiBAX19QVVJFX18gKi8gV3Moe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBXaFxufSksIEZoID0gW0FvLCBrbywgQ28sIHZvLCBMbCwgRGwsIE1sLCBPbCwgJGxdLCBFZSA9IC8qIEBfX1BVUkVfXyAqLyBXcyh7XG4gIGRlZmF1bHRNb2RpZmllcnM6IEZoXG59KTtcbmNvbnN0IE5sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWZ0ZXJNYWluOiB2bCxcbiAgYWZ0ZXJSZWFkOiBtbCxcbiAgYWZ0ZXJXcml0ZTogQ2wsXG4gIGFwcGx5U3R5bGVzOiB2byxcbiAgYXJyb3c6IE9sLFxuICBhdXRvOiBJaSxcbiAgYmFzZVBsYWNlbWVudHM6IHFlLFxuICBiZWZvcmVNYWluOiBnbCxcbiAgYmVmb3JlUmVhZDogX2wsXG4gIGJlZm9yZVdyaXRlOiBUbCxcbiAgYm90dG9tOiBodCxcbiAgY2xpcHBpbmdQYXJlbnRzOiB1bCxcbiAgY29tcHV0ZVN0eWxlczogQ28sXG4gIGNyZWF0ZVBvcHBlcjogRWUsXG4gIGNyZWF0ZVBvcHBlckJhc2U6IEhoLFxuICBjcmVhdGVQb3BwZXJMaXRlOiBWaCxcbiAgZGV0ZWN0T3ZlcmZsb3c6IHplLFxuICBlbmQ6IEZlLFxuICBldmVudExpc3RlbmVyczogQW8sXG4gIGZsaXA6IERsLFxuICBoaWRlOiAkbCxcbiAgbGVmdDogSixcbiAgbWFpbjogYmwsXG4gIG1vZGlmaWVyUGhhc2VzOiBOcyxcbiAgb2Zmc2V0OiBMbCxcbiAgcGxhY2VtZW50czogZ28sXG4gIHBvcHBlcjogSWUsXG4gIHBvcHBlckdlbmVyYXRvcjogV3MsXG4gIHBvcHBlck9mZnNldHM6IGtvLFxuICBwcmV2ZW50T3ZlcmZsb3c6IE1sLFxuICByZWFkOiBmbCxcbiAgcmVmZXJlbmNlOiBwbCxcbiAgcmlnaHQ6IGR0LFxuICBzdGFydDogdmUsXG4gIHRvcDogUSxcbiAgdmFyaWF0aW9uUGxhY2VtZW50czogdG8sXG4gIHZpZXdwb3J0OiBtbyxcbiAgd3JpdGU6IEVsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gdG4ocykge1xuICByZXR1cm4gcyA9PT0gXCJ0cnVlXCIgPyAhMCA6IHMgPT09IFwiZmFsc2VcIiA/ICExIDogcyA9PT0gTnVtYmVyKHMpLnRvU3RyaW5nKCkgPyBOdW1iZXIocykgOiBzID09PSBcIlwiIHx8IHMgPT09IFwibnVsbFwiID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiBlbihzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgYyA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShzLCB0LCBlKSB7XG4gICAgcy5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlbih0KX1gLCBlKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcy5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlbih0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZVwiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGUvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSB0bihzLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnMuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZUNsYXNzLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gdG4odFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHJldHVybiB0bihcbiAgICAgIHMuZ2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7ZW4odCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBzLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MocywgdCkge1xuICAgIHMgJiYgc24odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBzLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBzLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKHMsIHQpIHtcbiAgICBzbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKHMsIHQpIHtcbiAgICBzbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH0sXG4gIG1heE9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxZXG4gICAgICApLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXG4gICAgICApXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNuKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkocykgPyBzIDogITE7XG59XG5jb25zdCBZaCA9IDMsIGQgPSB7XG4gIGNsb3Nlc3QocywgdCkge1xuICAgIHJldHVybiBzLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMocywgdCkge1xuICAgIHJldHVybiBzLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgcylcbiAgICApO1xuICB9LFxuICBmaW5kT25lKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIHMpO1xuICB9LFxuICBjaGlsZHJlbihzLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5zLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMocywgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgaSA9IHMucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgaSAmJiBpLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBpLm5vZGVUeXBlICE9PSBZaDsgKVxuICAgICAgdGhpcy5tYXRjaGVzKGksIHQpICYmIGUucHVzaChpKSwgaSA9IGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihzLCB0KSB7XG4gICAgbGV0IGUgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChzLCB0KSB7XG4gICAgbGV0IGUgPSBzLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKHMpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBzKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIW1lKGUpICYmIEx0KGUpXG4gICAgKTtcbiAgfVxufSwgbm4gPSBcImRyb3Bkb3duXCIsIGpoID0gXCJ0ZS5kcm9wZG93blwiLCBDZSA9IGAuJHtqaH1gLCBPbyA9IFwiLmRhdGEtYXBpXCIsIHZzID0gXCJFc2NhcGVcIiwgZXIgPSBcIlNwYWNlXCIsIGlyID0gXCJUYWJcIiwgc28gPSBcIkFycm93VXBcIiwgVHMgPSBcIkFycm93RG93blwiLCBLaCA9IDIsIHpoID0gbmV3IFJlZ0V4cChcbiAgYCR7c299fCR7VHN9fCR7dnN9YFxuKSwgVWggPSBgaGlkZSR7Q2V9YCwgWGggPSBgaGlkZGVuJHtDZX1gLCBHaCA9IGBzaG93JHtDZX1gLCBxaCA9IGBzaG93biR7Q2V9YCwgWmggPSBgY2xpY2ske0NlfSR7T299YCwgc3IgPSBga2V5ZG93biR7Q2V9JHtPb31gLCBRaCA9IGBrZXl1cCR7Q2V9JHtPb31gLCBWdCA9IFwic2hvd1wiLCBKaCA9IFwiZHJvcHVwXCIsIHRkID0gXCJkcm9wZW5kXCIsIGVkID0gXCJkcm9wc3RhcnRcIiwgaWQgPSBcIltkYXRhLXRlLW5hdmJhci1yZWZdXCIsIEtpID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBvbiA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCIsIHNkID0gXCJbZGF0YS10ZS1uYXZiYXItbmF2LXJlZl1cIiwgbmQgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1pdGVtLXJlZl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgb2QgPSBGKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsIHJkID0gRigpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLCBhZCA9IEYoKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIiwgbGQgPSBGKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsIGNkID0gRigpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsIGhkID0gRigpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsIGRkID0gW3sgb3BhY2l0eTogXCIwXCIgfSwgeyBvcGFjaXR5OiBcIjFcIiB9XSwgdWQgPSBbeyBvcGFjaXR5OiBcIjFcIiB9LCB7IG9wYWNpdHk6IFwiMFwiIH1dLCB6aSA9IHtcbiAgZHVyYXRpb246IDU1MCxcbiAgaXRlcmF0aW9uczogMSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZmlsbDogXCJib3RoXCJcbn0sIHBkID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiAhMCxcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIlxufSwgX2QgPSB7XG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIHJlZmVyZW5jZTogXCIoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KVwiLFxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICBhdXRvQ2xvc2U6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEl0IGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fbWVudSA9IHRoaXMuX2dldE1lbnVFbGVtZW50KCksIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gbnVsbDtcbiAgICBjb25zdCBpID0gd2luZG93Lm1hdGNoTWVkaWEoXG4gICAgICBcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCJcbiAgICApLm1hdGNoZXM7XG4gICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA9IHRoaXMuX2NvbmZpZy5kcm9wZG93bkFuaW1hdGlvbiA9PT0gXCJvblwiICYmICFpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gcGQ7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gX2Q7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBubjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKG1lKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIGlmIChoLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgR2gsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBJdC5nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9pbk5hdmJhciA/IGMuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcIm5vbmVcIikgOiB0aGlzLl9jcmVhdGVQb3BwZXIoaSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFpLmNsb3Nlc3Qoc2QpICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChuKSA9PiBoLm9uKG4sIFwibW91c2VvdmVyXCIsIE1zKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtWdH1gLCBcIlwiKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiB0aGlzLl9tZW51LmFuaW1hdGUoZGQsIHppKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtWdH1gLCBcIlwiKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHFoLCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gemkuZHVyYXRpb24gOiAwXG4gICAgKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmIChtZSh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIHNyLFxuICAgICAgS2ksXG4gICAgICBJdC5kYXRhQXBpS2V5ZG93bkhhbmRsZXJcbiAgICApLCBoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBzcixcbiAgICAgIG9uLFxuICAgICAgSXQuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgaC5vbihkb2N1bWVudCwgWmgsIEl0LmNsZWFyTWVudXMpLCBoLm9uKGRvY3VtZW50LCBRaCwgSXQuY2xlYXJNZW51cyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2NvbXBsZXRlSGlkZSh0KSB7XG4gICAgdGhpcy5fZmFkZU91dEFuaW1hdGUgJiYgdGhpcy5fZmFkZU91dEFuaW1hdGUucGxheVN0YXRlID09PSBcInJ1bm5pbmdcIiB8fCBoLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgVWgsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkIHx8IChcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoaSkgPT4gaC5vZmYoaSwgXCJtb3VzZW92ZXJcIiwgTXMpKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiAodGhpcy5fZmFkZU91dEFuaW1hdGUgPSB0aGlzLl9tZW51LmFuaW1hdGUoXG4gICAgICB1ZCxcbiAgICAgIHppXG4gICAgKSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1Z0fWApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1Z0fWApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgYy5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWGgsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyB6aS5kdXJhdGlvbiA6IDBcbiAgICApKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgTChubiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHR5cGVvZiB0LnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmICFWZSh0LnJlZmVyZW5jZSkgJiYgdHlwZW9mIHQucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgJHtubi50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gXG4gICAgICApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodCkge1xuICAgIGlmICh0eXBlb2YgTmwgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgbGV0IGUgPSB0aGlzLl9lbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09IFwicGFyZW50XCIgPyBlID0gdCA6IFZlKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpID8gZSA9IEp0KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpIDogdHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAoZSA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSwgbiA9IGkubW9kaWZpZXJzLmZpbmQoXG4gICAgICAobykgPT4gby5uYW1lID09PSBcImFwcGx5U3R5bGVzXCIgJiYgby5lbmFibGVkID09PSAhMVxuICAgICk7XG4gICAgdGhpcy5fcG9wcGVyID0gRWUoXG4gICAgICBlLFxuICAgICAgdGhpcy5fbWVudSxcbiAgICAgIGlcbiAgICApLCBuICYmIGMuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcbiAgfVxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiB0LmRhdGFzZXRbYHRlRHJvcGRvd24ke1Z0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgVnQuc2xpY2UoMSl9YF0gPT09IFwiXCI7XG4gIH1cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIHJldHVybiBkLm5leHQodGhpcy5fZWxlbWVudCwgb24pWzBdO1xuICB9XG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAodC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gdGQpXG4gICAgICByZXR1cm4gY2Q7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IGVkKVxuICAgICAgcmV0dXJuIGhkO1xuICAgIGNvbnN0IGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoXCItLXRlLXBvc2l0aW9uXCIpLnRyaW0oKSA9PT0gXCJlbmRcIjtcbiAgICByZXR1cm4gdC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gSmggPyBlID8gcmQgOiBvZCA6IGUgPyBsZCA6IGFkO1xuICB9XG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChpZCkgIT09IG51bGw7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdC5zcGxpdChcIixcIikubWFwKChlKSA9PiBOdW1iZXIucGFyc2VJbnQoZSwgMTApKSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChlKSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gXCJzdGF0aWNcIiAmJiAodC5tb2RpZmllcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgICAgICAgZW5hYmxlZDogITFcbiAgICAgIH1cbiAgICBdKSwge1xuICAgICAgLi4udCxcbiAgICAgIC4uLnR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcodCkgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfTtcbiAgfVxuICBfc2VsZWN0TWVudUl0ZW0oeyBrZXk6IHQsIHRhcmdldDogZSB9KSB7XG4gICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgIG5kLFxuICAgICAgdGhpcy5fbWVudVxuICAgICkuZmlsdGVyKEx0KTtcbiAgICBpLmxlbmd0aCAmJiBubChcbiAgICAgIGksXG4gICAgICBlLFxuICAgICAgdCA9PT0gVHMsXG4gICAgICAhaS5pbmNsdWRlcyhlKVxuICAgICkuZm9jdXMoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBJdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xlYXJNZW51cyh0KSB7XG4gICAgaWYgKHQgJiYgKHQuYnV0dG9uID09PSBLaCB8fCB0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSAhPT0gaXIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoS2kpO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBJdC5nZXRJbnN0YW5jZShlW2ldKTtcbiAgICAgIGlmICghbyB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSAhMSB8fCAhby5faXNTaG93bigpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHIgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG8uX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBhID0gdC5jb21wb3NlZFBhdGgoKSwgbCA9IGEuaW5jbHVkZXMoby5fbWVudSk7XG4gICAgICAgIGlmIChhLmluY2x1ZGVzKG8uX2VsZW1lbnQpIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwiaW5zaWRlXCIgJiYgIWwgfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJvdXRzaWRlXCIgJiYgbCB8fCBvLl9tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAodC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgPT09IGlyIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdC50eXBlID09PSBcImNsaWNrXCIgJiYgKHIuY2xpY2tFdmVudCA9IHQpO1xuICAgICAgfVxuICAgICAgby5fY29tcGxldGVIaWRlKHIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQodCkge1xuICAgIHJldHVybiBRdCh0KSB8fCB0LnBhcmVudE5vZGU7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gZXIgfHwgdC5rZXkgIT09IHZzICYmICh0LmtleSAhPT0gVHMgJiYgdC5rZXkgIT09IHNvIHx8IHQudGFyZ2V0LmNsb3Nlc3Qob24pKSA6ICF6aC50ZXN0KHQua2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5kYXRhc2V0W2B0ZURyb3Bkb3duJHtWdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIFZ0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICAgIGlmICghZSAmJiB0LmtleSA9PT0gdnMgfHwgKHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgbWUodGhpcykpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLm1hdGNoZXMoS2kpID8gdGhpcyA6IGQucHJldih0aGlzLCBLaSlbMF0sIG4gPSBJdC5nZXRPckNyZWF0ZUluc3RhbmNlKGkpO1xuICAgIGlmICh0LmtleSA9PT0gdnMpIHtcbiAgICAgIG4uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodC5rZXkgPT09IHNvIHx8IHQua2V5ID09PSBUcykge1xuICAgICAgZSB8fCBuLnNob3coKSwgbi5fc2VsZWN0TWVudUl0ZW0odCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICghZSB8fCB0LmtleSA9PT0gZXIpICYmIEl0LmNsZWFyTWVudXMoKTtcbiAgfVxufVxuY29uc3Qgcm4gPSBcImNvbGxhcHNlXCIsIFJsID0gXCJ0ZS5jb2xsYXBzZVwiLCBWcyA9IGAuJHtSbH1gLCBuciA9IHtcbiAgdG9nZ2xlOiAhMCxcbiAgcGFyZW50OiBudWxsXG59LCBmZCA9IHtcbiAgdG9nZ2xlOiBcImJvb2xlYW5cIixcbiAgcGFyZW50OiBcIihudWxsfGVsZW1lbnQpXCJcbn0sIG1kID0gYHNob3cke1ZzfWAsIGdkID0gYHNob3duJHtWc31gLCBiZCA9IGBoaWRlJHtWc31gLCB2ZCA9IGBoaWRkZW4ke1ZzfWAsIGFuID0gXCJkYXRhLXRlLWNvbGxhcHNlLXNob3dcIiwgb3IgPSBcImRhdGEtdGUtY29sbGFwc2UtY29sbGFwc2VkXCIsIFVpID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNpbmdcIiwgVGQgPSBcImRhdGEtdGUtY29sbGFwc2UtaG9yaXpvbnRhbFwiLCBMZSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIHJyID0gYDpzY29wZSBbJHtMZX1dIFske0xlfV1gLCBFZCA9IFwid2lkdGhcIiwgQ2QgPSBcImhlaWdodFwiLCBBZCA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1zaG93XSwgW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXVwiLCBhciA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaW5pdF1cIiwgeWQgPSB7XG4gIHZpc2libGU6IFwiIXZpc2libGVcIixcbiAgaGlkZGVuOiBcImhpZGRlblwiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nOiBcImgtMCB0cmFuc2l0aW9uLVtoZWlnaHRdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIGNvbGxhcHNpbmdIb3Jpem9udGFsOiBcInctMCBoLWF1dG8gdHJhbnNpdGlvbi1bd2lkdGhdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCJcbn0sIHdkID0ge1xuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBoaWRkZW46IFwic3RyaW5nXCIsXG4gIGJhc2VUcmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIHF0IGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCBuID0gZC5maW5kKGFyKTtcbiAgICBmb3IgKGxldCBvID0gMCwgciA9IG4ubGVuZ3RoOyBvIDwgcjsgbysrKSB7XG4gICAgICBjb25zdCBhID0gbltvXSwgbCA9IGZvKGEpLCBwID0gZC5maW5kKGwpLmZpbHRlcihcbiAgICAgICAgKHUpID0+IHUgPT09IHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBsICE9PSBudWxsICYmIHAubGVuZ3RoICYmICh0aGlzLl9zZWxlY3RvciA9IGwsIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGEpKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCksIHRoaXMuX2NvbmZpZy5wYXJlbnQgfHwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKSwgdGhpcy5fY29uZmlnLnRvZ2dsZSAmJiB0aGlzLnRvZ2dsZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBucjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHJuO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gW10sIGU7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IHUgPSBkLmZpbmQoXG4gICAgICAgIHJyLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApO1xuICAgICAgdCA9IGQuZmluZChcbiAgICAgICAgQWQsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICAgICkuZmlsdGVyKChmKSA9PiAhdS5pbmNsdWRlcyhmKSk7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpO1xuICAgIGlmICh0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdSA9IHQuZmluZCgoZikgPT4gaSAhPT0gZik7XG4gICAgICBpZiAoZSA9IHUgPyBxdC5nZXRJbnN0YW5jZSh1KSA6IG51bGwsIGUgJiYgZS5faXNUcmFuc2l0aW9uaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbWQpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBpICE9PSB1ICYmIHF0LmdldE9yQ3JlYXRlSW5zdGFuY2UodSwgeyB0b2dnbGU6ICExIH0pLmhpZGUoKSwgZSB8fCBJLnNldERhdGEodSwgUmwsIG51bGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgciA9IG8gPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKExlKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoVWksIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gMCwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgITApLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFVpKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTGUsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShhbiwgXCJcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBcIlwiLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZ2QpO1xuICAgIH0sIHAgPSBgc2Nyb2xsJHtvWzBdLnRvVXBwZXJDYXNlKCkgKyBvLnNsaWNlKDEpfWA7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhhLCB0aGlzLl9lbGVtZW50LCAhMCksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBgJHt0aGlzLl9lbGVtZW50W3BdfXB4YDtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSB8fCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYmQpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERpbWVuc2lvbigpLCBpID0gZSA9PT0gXCJoZWlnaHRcIiA/IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZyA6IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZ0hvcml6b250YWw7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZV19cHhgLCBHZSh0aGlzLl9lbGVtZW50KSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoVWksIFwiXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShMZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFuKTtcbiAgICBjb25zdCBuID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX3RyaWdnZXJBcnJheVtyXSwgbCA9IFF0KGEpO1xuICAgICAgbCAmJiAhdGhpcy5faXNTaG93bihsKSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2FdLCAhMSk7XG4gICAgfVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoVWkpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShMZSwgXCJcIiksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB2ZCk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2VdID0gXCJcIiwgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoYW4pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ucixcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgdC50b2dnbGUgPSAhIXQudG9nZ2xlLCB0LnBhcmVudCA9IEp0KHQucGFyZW50KSwgTChybiwgdCwgZmQpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ueWQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwocm4sIHQsIHdkKSwgdDtcbiAgfVxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShUZCkgPyBFZCA6IENkO1xuICB9XG4gIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXG4gICAgICBycixcbiAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICApO1xuICAgIGQuZmluZChhciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKChlKSA9PiAhdC5pbmNsdWRlcyhlKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFF0KGUpO1xuICAgICAgaSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VdLCB0aGlzLl9pc1Nob3duKGkpKTtcbiAgICB9KTtcbiAgfVxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHQsIGUpIHtcbiAgICB0Lmxlbmd0aCAmJiB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIGUgPyBpLnJlbW92ZUF0dHJpYnV0ZShvcikgOiBpLnNldEF0dHJpYnV0ZShgJHtvcn1gLCBcIlwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIGUpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IHt9O1xuICAgICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvc2hvd3xoaWRlLy50ZXN0KHQpICYmIChlLnRvZ2dsZSA9ICExKTtcbiAgICAgIGNvbnN0IGkgPSBxdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGUpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbHIgPSBcIi5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3BcIiwgY3IgPSBcIi5zdGlja3ktdG9wXCI7XG5jbGFzcyBraSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gdCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICBscixcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgICAoZSkgPT4gZSArIHRcbiAgICApLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIGNyLFxuICAgICAgXCJtYXJnaW5SaWdodFwiLFxuICAgICAgKGUpID0+IGUgLSB0XG4gICAgKTtcbiAgfVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICB9XG4gIF9zZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0V2lkdGgoKSwgbyA9IChyKSA9PiB7XG4gICAgICBpZiAociAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IHIuY2xpZW50V2lkdGggKyBuKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShyLCBlKTtcbiAgICAgIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyKVtlXTtcbiAgICAgIHIuc3R5bGVbZV0gPSBgJHtpKFxuICAgICAgICBOdW1iZXIucGFyc2VGbG9hdChhKVxuICAgICAgKX1weGA7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIG8pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcInBhZGRpbmdSaWdodFwiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhsciwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoY3IsIFwibWFyZ2luUmlnaHRcIik7XG4gIH1cbiAgX3NhdmVJbml0aWFsQXR0cmlidXRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC5zdHlsZVtlXTtcbiAgICBpICYmIGMuc2V0RGF0YUF0dHJpYnV0ZSh0LCBlLCBpKTtcbiAgfVxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gYy5nZXREYXRhQXR0cmlidXRlKG4sIGUpO1xuICAgICAgdHlwZW9mIG8gPiBcInVcIiA/IG4uc3R5bGUucmVtb3ZlUHJvcGVydHkoZSkgOiAoYy5yZW1vdmVEYXRhQXR0cmlidXRlKG4sIGUpLCBuLnN0eWxlW2VdID0gbyk7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGkpO1xuICB9XG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGUpIHtcbiAgICBWZSh0KSA/IGUodCkgOiBkLmZpbmQodCwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChlKTtcbiAgfVxuICBpc092ZXJmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICB9XG59XG5jb25zdCB4ZCA9IHtcbiAgaXNWaXNpYmxlOiAhMCxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgaXNBbmltYXRlZDogITEsXG4gIHJvb3RFbGVtZW50OiBcImJvZHlcIixcbiAgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBiYWNrZHJvcENsYXNzZXM6IG51bGxcbn0sIGtkID0ge1xuICBpc1Zpc2libGU6IFwiYm9vbGVhblwiLFxuICBpc0FuaW1hdGVkOiBcImJvb2xlYW5cIixcbiAgcm9vdEVsZW1lbnQ6IFwiKGVsZW1lbnR8c3RyaW5nKVwiLFxuICBjbGlja0NhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICBiYWNrZHJvcENsYXNzZXM6IFwiKGFycmF5fG51bGwpXCJcbn0sIFBsID0gXCJiYWNrZHJvcFwiLCBociA9IGBtb3VzZWRvd24udGUuJHtQbH1gO1xuY2xhc3MgU28ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHQpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEsIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZmUodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiBHZSh0aGlzLl9nZXRFbGVtZW50KCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25maWcuYmFja2Ryb3BDbGFzc2VzIHx8IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIFwiZml4ZWRcIixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotWzEwNDBdXCIsXG4gICAgICBcImJnLWJsYWNrXCIsXG4gICAgICBcInctc2NyZWVuXCIsXG4gICAgICBcImgtc2NyZWVuXCJcbiAgICBdO1xuICAgIGMucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBcIm9wYWNpdHktMFwiKSwgYy5hZGRDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiLCBcIlwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBmZSh0KTtcbiAgICB9KTtcbiAgfVxuICBoaWRlKHQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGZlKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS01MFwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKSwgZmUodCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbGVtZW50ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi54ZCxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCB0LnJvb3RFbGVtZW50ID0gSnQodC5yb290RWxlbWVudCksIEwoUGwsIHQsIGtkKSwgdDtcbiAgfVxuICBfYXBwZW5kKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgfHwgKHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5fZ2V0RWxlbWVudCgpKSwgaC5vbih0aGlzLl9nZXRFbGVtZW50KCksIGhyLCAoKSA9PiB7XG4gICAgICBmZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgfSksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc0FwcGVuZGVkICYmIChoLm9mZih0aGlzLl9lbGVtZW50LCBociksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSk7XG4gIH1cbiAgX2VtdWxhdGVBbmltYXRpb24odCkge1xuICAgIHNsKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgJGkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fdG9nZ2xlciA9IGksIHRoaXMuX2V2ZW50ID0gZS5ldmVudCB8fCBcImJsdXJcIiwgdGhpcy5fY29uZGl0aW9uID0gZS5jb25kaXRpb24gfHwgKCgpID0+ICEwKSwgdGhpcy5fc2VsZWN0b3IgPSBlLnNlbGVjdG9yIHx8ICdidXR0b24sIGEsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLCB0aGlzLl9vbmx5VmlzaWJsZSA9IGUub25seVZpc2libGUgfHwgITEsIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gW10sIHRoaXMuX2ZpcnN0RWxlbWVudCA9IG51bGwsIHRoaXMuX2xhc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5oYW5kbGVyID0gKG4pID0+IHtcbiAgICAgIHRoaXMuX2NvbmRpdGlvbihuKSAmJiAhbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fbGFzdEVsZW1lbnQgPyAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSkgOiB0aGlzLl9jb25kaXRpb24obikgJiYgbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fZmlyc3RFbGVtZW50ICYmIChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2xhc3RFbGVtZW50LmZvY3VzKCkpO1xuICAgIH07XG4gIH1cbiAgdHJhcCgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9pbml0KCksIHRoaXMuX3NldEZvY3VzVHJhcCgpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pLCB0aGlzLl90b2dnbGVyICYmIHRoaXMuX3RvZ2dsZXIuZm9jdXMoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAhdGhpcy5fZmlyc3RFbGVtZW50IHx8IGUua2V5ICE9PSBcIlRhYlwiIHx8IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmluY2x1ZGVzKGUudGFyZ2V0KSB8fCAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KTtcbiAgfVxuICBfZmlsdGVyVmlzaWJsZSh0KSB7XG4gICAgcmV0dXJuIHQuZmlsdGVyKChlKSA9PiB7XG4gICAgICBpZiAoIUx0KGUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBpID0gZC5wYXJlbnRzKGUsIFwiKlwiKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKykge1xuICAgICAgICBjb25zdCBvID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaVtuXSk7XG4gICAgICAgIGlmIChvICYmIChvLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IG8udmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbGVtZW50cygpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IGQuZm9jdXNhYmxlQ2hpbGRyZW4odGhpcy5fZWxlbWVudCksIHRoaXMuX29ubHlWaXNpYmxlICYmICh0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IHRoaXMuX2ZpbHRlclZpc2libGUodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMpKSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbMF0sIHRoaXMuX2xhc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgX3NldEZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBlID09PSB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxIHx8IGUgPT09IDAgPyB0LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcikgOiB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGRyID0gXCJvZmZjYW52YXNcIiwgT2QgPSBcInRlLm9mZmNhbnZhc1wiLCBaZSA9IGAuJHtPZH1gLCBTZCA9IFwiLmRhdGEtYXBpXCIsIElkID0gYGxvYWQke1plfSR7U2R9YCwgRGQgPSBcIkVzY2FwZVwiLCB1ciA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIHNjcm9sbDogITFcbn0sICRkID0ge1xuICBiYWNrZHJvcDogXCJib29sZWFuXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgcHIgPSBcInNob3dcIiwgTGQgPSBcIltkYXRhLXRlLW9mZmNhbnZhcy1pbml0XVtkYXRhLXRlLW9mZmNhbnZhcy1zaG93XVwiLCBNZCA9IGBzaG93JHtaZX1gLCBOZCA9IGBzaG93biR7WmV9YCwgUmQgPSBgaGlkZSR7WmV9YCwgUGQgPSBgaGlkZGVuJHtaZX1gLCBCZCA9IGBrZXlkb3duLmRpc21pc3Mke1plfWA7XG5jbGFzcyBubyBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gZHI7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB1cjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBNZCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTaG93biA9ICEwLCB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIiwgdGhpcy5fYmFja2Ryb3Auc2hvdygpLCB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IG5ldyBraSgpLmhpZGUoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtwcn1gLCBcIlwiKTtcbiAgICBjb25zdCBpID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTmQsIHsgcmVsYXRlZFRhcmdldDogdCB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soaSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBSZCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtwcn1gKSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IGtpKCkucmVzZXQoKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFBkKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChoLm9uKFxuICAgICAgd2luZG93LFxuICAgICAgSWQsXG4gICAgICAoKSA9PiBkLmZpbmQoTGQpLmZvckVhY2goXG4gICAgICAgICh0KSA9PiBuby5nZXRPckNyZWF0ZUluc3RhbmNlKHQpLnNob3coKVxuICAgICAgKVxuICAgICksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi51cixcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgTChkciwgdCwgJGQpLCB0O1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyBTbyh7XG4gICAgICBpc1Zpc2libGU6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIGlzQW5pbWF0ZWQ6ICEwLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyAkaSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleSA9PT0gXCJUYWJcIlxuICAgIH0pO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIEJkLCAodCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBEZCAmJiB0aGlzLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBuby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVbdF0gPT09IHZvaWQgMCB8fCB0LnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbG4gPSBcImFsZXJ0XCIsIEhkID0gXCJ0ZS5hbGVydFwiLCBCbCA9IGAuJHtIZH1gLCBXZCA9IGBjbG9zZSR7Qmx9YCwgVmQgPSBgY2xvc2VkJHtCbH1gLCBzaSA9IFwiZGF0YS10ZS1hbGVydC1zaG93XCIsIEZkID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICBhdXRvaGlkZTogXCJib29sZWFuXCIsXG4gIGRlbGF5OiBcIm51bWJlclwiXG59LCBfciA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgYXV0b2hpZGU6ICEwLFxuICBkZWxheTogMWUzXG59LCBZZCA9IHtcbiAgZmFkZUluOiBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLFxuICBmYWRlT3V0OiBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIlxufSwgamQgPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEhsIGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRmQ7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBfcjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGxuO1xuICB9XG4gIC8vIFB1YmxpY1xuICBjbG9zZSgpIHtcbiAgICBpZiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFdkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlID0gMDtcbiAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChlID0gMzAwLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCkpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShzaSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhcbiAgICAgICAgKCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoKSxcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvblxuICAgICAgKTtcbiAgICB9LCBlKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9oaWRlICYmIHRoaXMuX3NldHVwQXV0b2hpZGUoKSwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHNpKSAmJiAoYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBMdCh0aGlzLl9lbGVtZW50KSkpIHtcbiAgICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgICAgYy5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBoLm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHNpLCBcIlwiKSwgaC5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHNpKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoc2kpO1xuICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGMucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgdGhpcy5fdGltZW91dCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCksIGgub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH07XG4gICAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpO1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uX3IsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgTChsbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ZZCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChsbiwgdCwgamQpLCB0O1xuICB9XG4gIF9zZXR1cEF1dG9oaWRlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cbiAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWZCksIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IEhsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBjbiA9IFwiY2Fyb3VzZWxcIiwgS2QgPSBcInRlLmNhcm91c2VsXCIsIHB0ID0gYC4ke0tkfWAsIFdsID0gXCIuZGF0YS1hcGlcIiwgemQgPSBcIkFycm93TGVmdFwiLCBVZCA9IFwiQXJyb3dSaWdodFwiLCBYZCA9IDUwMCwgR2QgPSA0MCwgZnIgPSB7XG4gIGludGVydmFsOiA1ZTMsXG4gIGtleWJvYXJkOiAhMCxcbiAgcmlkZTogITEsXG4gIHBhdXNlOiBcImhvdmVyXCIsXG4gIHdyYXA6ICEwLFxuICB0b3VjaDogITBcbn0sIHFkID0ge1xuICBpbnRlcnZhbDogXCIobnVtYmVyfGJvb2xlYW4pXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgcmlkZTogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIHBhdXNlOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgd3JhcDogXCJib29sZWFuXCIsXG4gIHRvdWNoOiBcImJvb2xlYW5cIlxufSwgWmQgPSB7XG4gIHBvaW50ZXI6IFwidG91Y2gtcGFuLXlcIixcbiAgYmxvY2s6IFwiIWJsb2NrXCIsXG4gIHZpc2libGU6IFwiZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0xMDAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ei1bMV1cIixcbiAgaW52aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpvcGFjaXR5LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZHVyYXRpb24tWzYwMG1zXSBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpkZWxheS02MDBcIixcbiAgc2xpZGVSaWdodDogXCJ0cmFuc2xhdGUteC1mdWxsXCIsXG4gIHNsaWRlTGVmdDogXCItdHJhbnNsYXRlLXgtZnVsbFwiXG59LCBRZCA9IHtcbiAgcG9pbnRlcjogXCJzdHJpbmdcIixcbiAgYmxvY2s6IFwic3RyaW5nXCIsXG4gIHZpc2libGU6IFwic3RyaW5nXCIsXG4gIGludmlzaWJsZTogXCJzdHJpbmdcIixcbiAgc2xpZGVSaWdodDogXCJzdHJpbmdcIixcbiAgc2xpZGVMZWZ0OiBcInN0cmluZ1wiXG59LCBhZSA9IFwibmV4dFwiLCBsZSA9IFwicHJldlwiLCBwZSA9IFwibGVmdFwiLCB1aSA9IFwicmlnaHRcIiwgSmQgPSB7XG4gIFt6ZF06IHVpLFxuICBbVWRdOiBwZVxufSwgdHUgPSBgc2xpZGUke3B0fWAsIGhuID0gYHNsaWQke3B0fWAsIGV1ID0gYGtleWRvd24ke3B0fWAsIGl1ID0gYG1vdXNlZW50ZXIke3B0fWAsIHN1ID0gYG1vdXNlbGVhdmUke3B0fWAsIG51ID0gYHRvdWNoc3RhcnQke3B0fWAsIG91ID0gYHRvdWNobW92ZSR7cHR9YCwgcnUgPSBgdG91Y2hlbmQke3B0fWAsIGF1ID0gYHBvaW50ZXJkb3duJHtwdH1gLCBsdSA9IGBwb2ludGVydXAke3B0fWAsIGN1ID0gYGRyYWdzdGFydCR7cHR9YCwgaHUgPSBgbG9hZCR7cHR9JHtXbH1gLCBkdSA9IGBjbGljayR7cHR9JHtXbH1gLCBtciA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pbml0XCIsIGNlID0gXCJkYXRhLXRlLWNhcm91c2VsLWFjdGl2ZVwiLCB1dSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLWVuZFwiLCBkbiA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXN0YXJ0XCIsIHB1ID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dFwiLCBfdSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXByZXZcIiwgZnUgPSBcImRhdGEtdGUtY2Fyb3VzZWwtcG9pbnRlci1ldmVudFwiLCBtdSA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5pdF1cIiwgVmwgPSBcIltkYXRhLXRlLWNhcm91c2VsLWFjdGl2ZV1cIiwgSW8gPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW1dXCIsIHllID0gYCR7Vmx9JHtJb31gLCBndSA9IGAke0lvfSBpbWdgLCBidSA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbS1uZXh0XSwgW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XVwiLCB2dSA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5kaWNhdG9yc11cIiwgVHUgPSBcIltkYXRhLXRlLXRhcmdldF1cIiwgRXUgPSBcIltkYXRhLXRlLXNsaWRlXSwgW2RhdGEtdGUtc2xpZGUtdG9dXCIsIEN1ID0gXCJ0b3VjaFwiLCBBdSA9IFwicGVuXCI7XG5jbGFzcyBVdCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pdGVtcyA9IG51bGwsIHRoaXMuX2ludGVydmFsID0gbnVsbCwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGwsIHRoaXMuX2lzUGF1c2VkID0gITEsIHRoaXMuX2lzU2xpZGluZyA9ICExLCB0aGlzLnRvdWNoVGltZW91dCA9IG51bGwsIHRoaXMudG91Y2hTdGFydFggPSAwLCB0aGlzLnRvdWNoRGVsdGFYID0gMCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICB2dSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl90b3VjaFN1cHBvcnRlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAsIHRoaXMuX3BvaW50ZXJFdmVudCA9ICEhd2luZG93LlBvaW50ZXJFdmVudCwgdGhpcy5fc2V0QWN0aXZlRWxlbWVudENsYXNzKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpLCB0aGlzLl9jb25maWcucmlkZSA9PT0gXCJjYXJvdXNlbFwiICYmIHRoaXMuY3ljbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZnI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBjbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgbmV4dCgpIHtcbiAgICB0aGlzLl9zbGlkZShhZSk7XG4gIH1cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICFkb2N1bWVudC5oaWRkZW4gJiYgTHQodGhpcy5fZWxlbWVudCkgJiYgdGhpcy5uZXh0KCk7XG4gIH1cbiAgcHJldigpIHtcbiAgICB0aGlzLl9zbGlkZShsZSk7XG4gIH1cbiAgcGF1c2UodCkge1xuICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITApLCBkLmZpbmRPbmUoYnUsIHRoaXMuX2VsZW1lbnQpICYmIChKYSh0aGlzLl9lbGVtZW50KSwgdGhpcy5jeWNsZSghMCkpLCBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICB9XG4gIGN5Y2xlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICExKSwgdGhpcy5faW50ZXJ2YWwgJiYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwpLCB0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCAmJiAodGhpcy5fdXBkYXRlSW50ZXJ2YWwoKSwgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZChcbiAgICAgICAgdGhpc1xuICAgICAgKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICkpO1xuICB9XG4gIHRvKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgeWUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpO1xuICAgIGlmICh0ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCB0IDwgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICBoLm9uZSh0aGlzLl9lbGVtZW50LCBobiwgKCkgPT4gdGhpcy50byh0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID09PSB0KSB7XG4gICAgICB0aGlzLnBhdXNlKCksIHRoaXMuY3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQgPiBlID8gYWUgOiBsZTtcbiAgICB0aGlzLl9zbGlkZShpLCB0aGlzLl9pdGVtc1t0XSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChoLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBkdSxcbiAgICAgIEV1LFxuICAgICAgVXQuZGF0YUFwaUNsaWNrSGFuZGxlclxuICAgICksIGgub24od2luZG93LCBodSwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IGQuZmluZChtdSk7XG4gICAgICBmb3IgKGxldCBlID0gMCwgaSA9IHQubGVuZ3RoOyBlIDwgaTsgZSsrKVxuICAgICAgICBVdC5jYXJvdXNlbEludGVyZmFjZShcbiAgICAgICAgICB0W2VdLFxuICAgICAgICAgIFV0LmdldEluc3RhbmNlKHRbZV0pXG4gICAgICAgICk7XG4gICAgfSksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5mcixcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgTChjbiwgdCwgcWQpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWmQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoY24sIHQsIFFkKSwgdDtcbiAgfVxuICBfZW5hYmxlQ3ljbGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIGgub25lKHRoaXMuX2VsZW1lbnQsIGhuLCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG4gIF9hcHBseUluaXRpYWxDbGFzc2VzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICB5ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHQuY2xhc3NMaXN0LmFkZChcbiAgICAgIHRoaXMuX2NsYXNzZXMuYmxvY2ssXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KTtcbiAgfVxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgdCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO1xuICAgIGlmICh0IDw9IEdkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0IC8gdGhpcy50b3VjaERlbHRhWDtcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMCwgZSAmJiB0aGlzLl9zbGlkZShlID4gMCA/IHVpIDogcGUpO1xuICB9XG4gIF9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIHllLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMuYWRkQ2xhc3ModGhpcy5fYWN0aXZlRWxlbWVudCwgXCJoaWRkZW5cIik7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGV1LFxuICAgICAgKHQpID0+IHRoaXMuX2tleWRvd24odClcbiAgICApLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAoaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBpdSxcbiAgICAgICh0KSA9PiB0aGlzLnBhdXNlKHQpXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBzdSxcbiAgICAgICh0KSA9PiB0aGlzLl9lbmFibGVDeWNsZSh0KVxuICAgICkpLCB0aGlzLl9jb25maWcudG91Y2ggJiYgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgJiYgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpLCB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKCk7XG4gIH1cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IChvKSA9PiB0aGlzLl9wb2ludGVyRXZlbnQgJiYgKG8ucG9pbnRlclR5cGUgPT09IEF1IHx8IG8ucG9pbnRlclR5cGUgPT09IEN1KSwgZSA9IChvKSA9PiB7XG4gICAgICB0KG8pID8gdGhpcy50b3VjaFN0YXJ0WCA9IG8uY2xpZW50WCA6IHRoaXMuX3BvaW50ZXJFdmVudCB8fCAodGhpcy50b3VjaFN0YXJ0WCA9IG8udG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICB9LCBpID0gKG8pID0+IHtcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBvLnRvdWNoZXMgJiYgby50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogby50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgIH0sIG4gPSAobykgPT4ge1xuICAgICAgdChvKSAmJiAodGhpcy50b3VjaERlbHRhWCA9IG8uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFgpLCB0aGlzLl9oYW5kbGVTd2lwZSgpLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAodGhpcy5wYXVzZSgpLCB0aGlzLnRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpLCB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgIChyKSA9PiB0aGlzLl9lbmFibGVDeWNsZShyKSxcbiAgICAgICAgWGQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgICkpO1xuICAgIH07XG4gICAgZC5maW5kKGd1LCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgKG8pID0+IHtcbiAgICAgICAgaC5vbihcbiAgICAgICAgICBvLFxuICAgICAgICAgIGN1LFxuICAgICAgICAgIChyKSA9PiByLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCB0aGlzLl9wb2ludGVyRXZlbnQgPyAoaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBhdSxcbiAgICAgIChvKSA9PiBlKG8pXG4gICAgKSwgaC5vbih0aGlzLl9lbGVtZW50LCBsdSwgKG8pID0+IG4obykpLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5wb2ludGVyKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7ZnV9YCwgXCJcIikpIDogKGgub24odGhpcy5fZWxlbWVudCwgbnUsIChvKSA9PiBlKG8pKSwgaC5vbih0aGlzLl9lbGVtZW50LCBvdSwgKG8pID0+IGkobykpLCBoLm9uKHRoaXMuX2VsZW1lbnQsIHJ1LCAobykgPT4gbihvKSkpO1xuICB9XG4gIF9rZXlkb3duKHQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gSmRbdC5rZXldO1xuICAgIGUgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fc2xpZGUoZSkpO1xuICB9XG4gIF9nZXRJdGVtSW5kZXgodCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcyA9IHQgJiYgdC5wYXJlbnROb2RlID8gZC5maW5kKElvLCB0LnBhcmVudE5vZGUpIDogW10sIHRoaXMuX2l0ZW1zLmluZGV4T2YodCk7XG4gIH1cbiAgX2dldEl0ZW1CeU9yZGVyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdCA9PT0gYWU7XG4gICAgcmV0dXJuIG5sKFxuICAgICAgdGhpcy5faXRlbXMsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIHRoaXMuX2NvbmZpZy53cmFwXG4gICAgKTtcbiAgfVxuICBfdHJpZ2dlclNsaWRlRXZlbnQodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRJdGVtSW5kZXgodCksIG4gPSB0aGlzLl9nZXRJdGVtSW5kZXgoXG4gICAgICBkLmZpbmRPbmUoeWUsIHRoaXMuX2VsZW1lbnQpXG4gICAgKTtcbiAgICByZXR1cm4gaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHR1LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0LFxuICAgICAgZGlyZWN0aW9uOiBlLFxuICAgICAgZnJvbTogbixcbiAgICAgIHRvOiBpXG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgICAgVmwsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUoY2UpLCBlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiKSwgZS5jbGFzc0xpc3QucmVtb3ZlKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgVHUsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKVxuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgIGlbbl0uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zbGlkZS10b1wiKSxcbiAgICAgICAgICAxMFxuICAgICAgICApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgodCkpIHtcbiAgICAgICAgICBpW25dLnNldEF0dHJpYnV0ZShgJHtjZX1gLCBcIlwiKSwgaVtuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpLCBpW25dLmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IGQuZmluZE9uZSh5ZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtaW50ZXJ2YWxcIiksXG4gICAgICAxMFxuICAgICk7XG4gICAgZSA/ICh0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWwsIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGUpIDogdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XG4gIH1cbiAgX3NsaWRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcih0KSwgbiA9IGQuZmluZE9uZShcbiAgICAgIHllLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG8gPSB0aGlzLl9nZXRJdGVtSW5kZXgobiksIHIgPSBlIHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKGksIG4pLCBhID0gdGhpcy5fZ2V0SXRlbUluZGV4KHIpLCBsID0gISF0aGlzLl9pbnRlcnZhbCwgcCA9IGkgPT09IGFlLCB1ID0gcCA/IGRuIDogdXUsIGYgPSBwID8gcHUgOiBfdSwgXyA9IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24oaSksIG0gPSB1ID09PSBkbiA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LCBnID0gdSAhPT0gZG4gPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodDtcbiAgICBpZiAociAmJiByLmhhc0F0dHJpYnV0ZShjZSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTbGlkaW5nIHx8IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KHIsIF8pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIW4gfHwgIXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTbGlkaW5nID0gITAsIGwgJiYgdGhpcy5wYXVzZSgpLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHIpLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gcjtcbiAgICBjb25zdCBiID0gKCkgPT4ge1xuICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhuLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHIsXG4gICAgICAgIGRpcmVjdGlvbjogXyxcbiAgICAgICAgZnJvbTogbyxcbiAgICAgICAgdG86IGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKG1yKSkge1xuICAgICAgci5zZXRBdHRyaWJ1dGUoYCR7Zn1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuYmxvY2ssIGcpLCBHZShyKSwgbi5zZXRBdHRyaWJ1dGUoYCR7dX1gLCBcIlwiKSwgbi5jbGFzc0xpc3QuYWRkKFxuICAgICAgICBtLFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICAgICksIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5zZXRBdHRyaWJ1dGUoYCR7dX1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCByLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCxcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnRcbiAgICAgICk7XG4gICAgICBjb25zdCBDID0gKCkgPT4ge1xuICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZSh1KSwgci5yZW1vdmVBdHRyaWJ1dGUoZiksIHIuc2V0QXR0cmlidXRlKGAke2NlfWAsIFwiXCIpLCBuLnJlbW92ZUF0dHJpYnV0ZShjZSksIG4uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICBtLFxuICAgICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrXG4gICAgICAgICksIG4ucmVtb3ZlQXR0cmlidXRlKGYpLCBuLnJlbW92ZUF0dHJpYnV0ZSh1KSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHNldFRpbWVvdXQoYiwgMCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhDLCBuLCAhMCk7XG4gICAgfSBlbHNlXG4gICAgICBuLnJlbW92ZUF0dHJpYnV0ZShjZSksIG4uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgci5zZXRBdHRyaWJ1dGUoYCR7Y2V9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgdGhpcy5faXNTbGlkaW5nID0gITEsIGIoKTtcbiAgICBsICYmIHRoaXMuY3ljbGUoKTtcbiAgfVxuICBfZGlyZWN0aW9uVG9PcmRlcih0KSB7XG4gICAgcmV0dXJuIFt1aSwgcGVdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gcGUgPyBsZSA6IGFlIDogdCA9PT0gcGUgPyBhZSA6IGxlIDogdDtcbiAgfVxuICBfb3JkZXJUb0RpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIFthZSwgbGVdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gbGUgPyBwZSA6IHVpIDogdCA9PT0gbGUgPyB1aSA6IHBlIDogdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGNhcm91c2VsSW50ZXJmYWNlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gVXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlKTtcbiAgICBsZXQgeyBfY29uZmlnOiBuIH0gPSBpO1xuICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKG4gPSB7XG4gICAgICAuLi5uLFxuICAgICAgLi4uZVxuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuc2xpZGU7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGkudG8oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAodHlwZW9mIGlbb10gPiBcInVcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtvfVwiYCk7XG4gICAgICBpW29dKCk7XG4gICAgfSBlbHNlXG4gICAgICBuLmludGVydmFsICYmIG4ucmlkZSA9PT0gITAgJiYgaS5wYXVzZSgpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBVdC5jYXJvdXNlbEludGVyZmFjZSh0aGlzLCB0KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcih0KSB7XG4gICAgY29uc3QgZSA9IFF0KHRoaXMpO1xuICAgIGlmICghZSB8fCAhZS5oYXNBdHRyaWJ1dGUobXIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxuICAgIH0sIG4gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIik7XG4gICAgbiAmJiAoaS5pbnRlcnZhbCA9ICExKSwgVXQuY2Fyb3VzZWxJbnRlcmZhY2UoZSwgaSksIG4gJiYgVXQuZ2V0SW5zdGFuY2UoZSkudG8obiksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuY29uc3QgdW4gPSBcIm1vZGFsXCIsIHl1ID0gXCJ0ZS5tb2RhbFwiLCBDdCA9IGAuJHt5dX1gLCBnciA9IFwiRXNjYXBlXCIsIGJyID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgZm9jdXM6ICEwXG59LCB3dSA9IHtcbiAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIGZvY3VzOiBcImJvb2xlYW5cIlxufSwgeHUgPSB7XG4gIHNob3c6IFwidHJhbnNmb3JtLW5vbmVcIixcbiAgc3RhdGljOiBcInNjYWxlLVsxLjAyXVwiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCJcbn0sIGt1ID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBzdGF0aWM6IFwic3RyaW5nXCIsXG4gIHN0YXRpY1Byb3BlcnRpZXM6IFwic3RyaW5nXCJcbn0sIE91ID0gYGhpZGUke0N0fWAsIFN1ID0gYGhpZGVQcmV2ZW50ZWQke0N0fWAsIEl1ID0gYGhpZGRlbiR7Q3R9YCwgRHUgPSBgc2hvdyR7Q3R9YCwgJHUgPSBgc2hvd24ke0N0fWAsIHZyID0gYHJlc2l6ZSR7Q3R9YCwgVHIgPSBgY2xpY2suZGlzbWlzcyR7Q3R9YCwgRXIgPSBga2V5ZG93bi5kaXNtaXNzJHtDdH1gLCBMdSA9IGBtb3VzZXVwLmRpc21pc3Mke0N0fWAsIENyID0gYG1vdXNlZG93bi5kaXNtaXNzJHtDdH1gLCBBciA9IFwiZGF0YS10ZS1tb2RhbC1vcGVuXCIsIHlyID0gXCJkYXRhLXRlLW9wZW5cIiwgbmkgPSBcIltkYXRhLXRlLW1vZGFsLWRpYWxvZy1yZWZdXCIsIE11ID0gXCJbZGF0YS10ZS1tb2RhbC1ib2R5LXJlZl1cIjtcbmNsYXNzIEZsIGV4dGVuZHMgRXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2RpYWxvZyA9IGQuZmluZE9uZShuaSwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITEsIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcga2koKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gYnI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB1bjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBEdSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCksIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKEFyLCBcInRydWVcIiksIHRoaXMuX2FkanVzdERpYWxvZygpLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCBoLm9uKHRoaXMuX2RpYWxvZywgQ3IsICgpID0+IHtcbiAgICAgIGgub25lKHRoaXMuX2VsZW1lbnQsIEx1LCAoaSkgPT4ge1xuICAgICAgICBpLnRhcmdldCA9PT0gdGhpcy5fZWxlbWVudCAmJiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICEwKTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLl9zaG93RWxlbWVudCh0KSwgdGhpcy5fc2hvd0JhY2tkcm9wKCkpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgT3UpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTaG93biA9ICExO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XG4gICAgZSAmJiAodGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITApLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBkLmZpbmRPbmUobmksIHRoaXMuX2VsZW1lbnQpLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgaC5vZmYodGhpcy5fZWxlbWVudCwgVHIpLCBoLm9mZih0aGlzLl9kaWFsb2csIENyKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHlyKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChcbiAgICAgICh0KSA9PiBoLm9mZih0LCBDdClcbiAgICApLCB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgU28oe1xuICAgICAgaXNWaXNpYmxlOiAhIXRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyAkaSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleSA9PT0gXCJUYWJcIlxuICAgIH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uYnIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEwodW4sIHQsIHd1KSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnh1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHVuLCB0LCBrdSksIHQ7XG4gIH1cbiAgX3Nob3dFbGVtZW50KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpLCBpID0gZC5maW5kT25lKE11LCB0aGlzLl9kaWFsb2cpO1xuICAgICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHt5cn1gLCBcInRydWVcIiksIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKG5pLCB0aGlzLl9lbGVtZW50KTtcbiAgICBuLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5zaG93KSwgbi5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0wXCIpLCBuLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgaSAmJiAoaS5zY3JvbGxUb3AgPSAwKSwgZSAmJiBHZSh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmZvY3VzICYmIHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgJHUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKG8sIHRoaXMuX2RpYWxvZywgZSk7XG4gIH1cbiAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyBoLm9uKGRvY3VtZW50LCBFciwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gZ3IgPyAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmhpZGUoKSkgOiAhdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBnciAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgfSkgOiBoLm9mZih0aGlzLl9lbGVtZW50LCBFcik7XG4gIH1cbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyBoLm9uKHdpbmRvdywgdnIsICgpID0+IHRoaXMuX2FkanVzdERpYWxvZygpKSA6IGgub2ZmKHdpbmRvdywgdnIpO1xuICB9XG4gIF9oaWRlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShuaSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIHQuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMTAwXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSwgMzAwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShBciksIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBJdSk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgaC5vbih0aGlzLl9lbGVtZW50LCBUciwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhZC5maW5kT25lKG5pLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFN1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IGksIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCBvID0gaSA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgIW8gJiYgbi5vdmVyZmxvd1kgPT09IFwiaGlkZGVuXCIgfHwgZS5jb250YWlucyh0aGlzLl9jbGFzc2VzLnN0YXRpYykgfHwgKG8gfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMzAwKSwgbyB8fCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgbi5vdmVyZmxvd1kgPSBcIlwiO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICB9LCB0aGlzLl9kaWFsb2cpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCkpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGUgPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKSwgaSA9IGUgPiAwO1xuICAgICghaSAmJiB0ICYmICFGKCkgfHwgaSAmJiAhdCAmJiBGKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAoaSAmJiAhdCAmJiAhRigpIHx8ICFpICYmIHQgJiYgRigpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XG4gIH1cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSBGbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IE51ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhY2tncm91bmRcIixcbiAgXCJjaXRlXCIsXG4gIFwiaHJlZlwiLFxuICBcIml0ZW10eXBlXCIsXG4gIFwibG9uZ2Rlc2NcIixcbiAgXCJwb3N0ZXJcIixcbiAgXCJzcmNcIixcbiAgXCJ4bGluazpocmVmXCJcbl0pLCBSdSA9IC9eYXJpYS1bXFx3LV0qJC9pLCBQdSA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksIEJ1ID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSwgSHUgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodC5pbmNsdWRlcyhlKSlcbiAgICByZXR1cm4gTnUuaGFzKGUpID8gISEoUHUudGVzdChzLm5vZGVWYWx1ZSkgfHwgQnUudGVzdChzLm5vZGVWYWx1ZSkpIDogITA7XG4gIGNvbnN0IGkgPSB0LmZpbHRlcihcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICApO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgIGlmIChpW25dLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIFd1ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIFJ1XSxcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJhbHRcIiwgXCJ0aXRsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuZnVuY3Rpb24gd3IocywgdCwgZSkge1xuICBpZiAoIXMubGVuZ3RoKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUocyk7XG4gIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKSwgbyA9IFtdLmNvbmNhdCguLi5uLmJvZHkucXVlcnlTZWxlY3RvckFsbChcIipcIikpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl0sIHAgPSBsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0KS5pbmNsdWRlcyhwKSkge1xuICAgICAgbC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB1ID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIGYgPSBbXS5jb25jYXQoXG4gICAgICB0W1wiKlwiXSB8fCBbXSxcbiAgICAgIHRbcF0gfHwgW11cbiAgICApO1xuICAgIHUuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgSHUoXywgZikgfHwgbC5yZW1vdmVBdHRyaWJ1dGUoXy5ub2RlTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG4uYm9keS5pbm5lckhUTUw7XG59XG5jb25zdCB4ciA9IFwidG9vbHRpcFwiLCBWdSA9IFwidGUudG9vbHRpcFwiLCB5dCA9IGAuJHtWdX1gLCBGdSA9IFwidGUtdG9vbHRpcFwiLCBZdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksIGp1ID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICB0cmlnZ2VyOiBcInN0cmluZ1wiLFxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcbiAgaHRtbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdG9yOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBjb250YWluZXI6IFwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIGN1c3RvbUNsYXNzOiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcbiAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgYWxsb3dMaXN0OiBcIm9iamVjdFwiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXG59LCBLdSA9IHtcbiAgQVVUTzogXCJhdXRvXCIsXG4gIFRPUDogXCJ0b3BcIixcbiAgUklHSFQ6IEYoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIExFRlQ6IEYoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXG59LCB6dSA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgei1bMTA4MF0gYmxvY2sgbS0wIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBkYXRhLXRlLXRvb2x0aXAtaW5uZXItcmVmIGNsYXNzPVwidG9vbHRpcC1pbm5lciBtYXgtdy1bMjAwcHhdIHRleHQtc20gcHktMS41IHB4LTQgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBiZy1bIzZkNmQ2ZF0gcm91bmRlZFwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgdGl0bGU6IFwiXCIsXG4gIGRlbGF5OiAwLFxuICBodG1sOiAhMSxcbiAgc2VsZWN0b3I6ICExLFxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6ICExLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIGN1c3RvbUNsYXNzOiBcIlwiLFxuICBzYW5pdGl6ZTogITAsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIGFsbG93TGlzdDogV3UsXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XG59LCBVdSA9IHtcbiAgSElERTogYGhpZGUke3l0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7eXR9YCxcbiAgU0hPVzogYHNob3cke3l0fWAsXG4gIFNIT1dOOiBgc2hvd24ke3l0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke3l0fWAsXG4gIENMSUNLOiBgY2xpY2ske3l0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHt5dH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHt5dH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7eXR9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3l0fWBcbn0sIFh1ID0gXCJmYWRlXCIsIEd1ID0gXCJtb2RhbFwiLCBwbiA9IFwic2hvd1wiLCBvaSA9IFwic2hvd1wiLCBfbiA9IFwib3V0XCIsIGtyID0gXCIudG9vbHRpcC1pbm5lclwiLCBPciA9IGAuJHtHdX1gLCBTciA9IFwiaGlkZS50ZS5tb2RhbFwiLCByaSA9IFwiaG92ZXJcIiwgZm4gPSBcImZvY3VzXCIsIHF1ID0gXCJjbGlja1wiLCBadSA9IFwibWFudWFsXCI7XG5jbGFzcyBRZSBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGlmICh0eXBlb2YgTmwgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNFbmFibGVkID0gITAsIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIiwgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMudGlwID0gbnVsbCwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHp1O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4geHI7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gVXU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4ganU7XG4gIH1cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICExO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUodCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpXG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xuICAgICAgICBlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWUuX2FjdGl2ZVRyaWdnZXIuY2xpY2ssIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSA/IGUuX2VudGVyKG51bGwsIGUpIDogZS5fbGVhdmUobnVsbCwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKHBuKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgaC5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoT3IpLFxuICAgICAgU3IsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtcbiAgICBpZiAoISh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBoLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXG4gICAgKSwgZSA9IHRsKHRoaXMuX2VsZW1lbnQpLCBpID0gZSA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBlLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSBcInRvb2x0aXBcIiAmJiB0aGlzLnRpcCAmJiB0aGlzLmdldFRpdGxlKCkgIT09IHRoaXMudGlwLnF1ZXJ5U2VsZWN0b3Ioa3IpLmlubmVySFRNTCAmJiAodGhpcy5fZGlzcG9zZVBvcHBlcigpLCB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy50aXAgPSBudWxsKTtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIG8gPSBidCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBvKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGlwLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy50aXAuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcbiAgICB9LCAxMDApO1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChyKTtcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYSk7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGwgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoSS5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IEVlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcbiAgICApLCBuLmdldEF0dHJpYnV0ZShcImlkXCIpLmluY2x1ZGVzKFwidG9vbHRpcFwiKSlcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNvbnN0IHUgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuICAgIHUgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLnUuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG0pID0+IHtcbiAgICAgIGgub24obSwgXCJtb3VzZW92ZXJcIiwgTXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGYgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtID0gdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIG0gPT09IF9uICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgIH0sIF8gPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0cmFuc2l0aW9uLW9wYWNpdHlcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhmLCB0aGlzLnRpcCwgXyk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IG9pICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xuICAgIH07XG4gICAgaWYgKGgudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREVcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG8pID0+IGgub2ZmKG8sIFwibW91c2VvdmVyXCIsIE1zKSksIHRoaXMuX2FjdGl2ZVRyaWdnZXJbcXVdID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbZm5dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbcmldID0gITE7XG4gICAgY29uc3QgbiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcIm9wYWNpdHktMFwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUaXRsZSgpO1xuICB9XG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKVxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgIGNvbnN0IGUgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShYdSwgcG4pLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIGtyKTtcbiAgfVxuICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKGksIHQpO1xuICAgIGlmICghZSAmJiBuKSB7XG4gICAgICBuLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KG4sIGUpO1xuICB9XG4gIHNldEVsZW1lbnRDb250ZW50KHQsIGUpIHtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKFZlKGUpKSB7XG4gICAgICAgIGUgPSBKdChlKSwgdGhpcy5fY29uZmlnLmh0bWwgPyBlLnBhcmVudE5vZGUgIT09IHQgJiYgKHQuaW5uZXJIVE1MID0gXCJcIiwgdC5hcHBlbmQoZSkpIDogdC50ZXh0Q29udGVudCA9IGUudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5odG1sID8gKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSAmJiAoZSA9IHdyKFxuICAgICAgICBlLFxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxuICAgICAgICB0aGlzLl9jb25maWcuc2FuaXRpemVGblxuICAgICAgKSksIHQuaW5uZXJIVE1MID0gZSkgOiB0LnRleHRDb250ZW50ID0gZTtcbiAgICB9XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiKSB8fCB0aGlzLl9jb25maWcudGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xuICB9XG4gIHVwZGF0ZUF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKFxuICAgICAgdC5kZWxlZ2F0ZVRhcmdldCxcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogKGkpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogKGkpID0+IHtcbiAgICAgICAgaS5vcHRpb25zLnBsYWNlbWVudCAhPT0gaS5wbGFjZW1lbnQgJiYgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcbiAgICAgIGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YFxuICAgICk7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiBLdVt0LnRvVXBwZXJDYXNlKCldO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBcImNsaWNrXCIpXG4gICAgICAgIGgub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAoaSkgPT4gdGhpcy50b2dnbGUoaSlcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKGUgIT09IFp1KSB7XG4gICAgICAgIGNvbnN0IGkgPSBlID09PSByaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IHJpID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgaC5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9lbnRlcihvKVxuICAgICAgICApLCBoLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2xlYXZlKG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0sIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoT3IpLFxuICAgICAgU3IsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yID8gdGhpcy5fY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgIHNlbGVjdG9yOiBcIlwiXG4gICAgfSA6IHRoaXMuX2ZpeFRpdGxlKCk7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLCBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XG4gIH1cbiAgX2VudGVyKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gZm4gOiByaV0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhwbikgfHwgZS5faG92ZXJTdGF0ZSA9PT0gb2kpIHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPSBvaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IG9pLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgZS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IG9pICYmIGUuc2hvdygpO1xuICAgIH0sIGUuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgfVxuICBfbGVhdmUodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c291dFwiID8gZm4gOiByaV0gPSBlLl9lbGVtZW50LmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpLCAhZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gX24sICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGUuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUuX2hvdmVyU3RhdGUgPT09IF9uICYmIGUuaGlkZSgpO1xuICAgICAgfSwgZS5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBZdS5oYXMoaSkgJiYgZGVsZXRlIGVbaV07XG4gICAgfSksIHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC5jb250YWluZXIgPSB0LmNvbnRhaW5lciA9PT0gITEgPyBkb2N1bWVudC5ib2R5IDogSnQodC5jb250YWluZXIpLCB0eXBlb2YgdC5kZWxheSA9PSBcIm51bWJlclwiICYmICh0LmRlbGF5ID0ge1xuICAgICAgc2hvdzogdC5kZWxheSxcbiAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICB9KSwgdHlwZW9mIHQudGl0bGUgPT0gXCJudW1iZXJcIiAmJiAodC50aXRsZSA9IHQudGl0bGUudG9TdHJpbmcoKSksIHR5cGVvZiB0LmNvbnRlbnQgPT0gXCJudW1iZXJcIiAmJiAodC5jb250ZW50ID0gdC5jb250ZW50LnRvU3RyaW5nKCkpLCBMKHhyLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdC5zYW5pdGl6ZSAmJiAodC50ZW1wbGF0ZSA9IHdyKFxuICAgICAgdC50ZW1wbGF0ZSxcbiAgICAgIHQuYWxsb3dMaXN0LFxuICAgICAgdC5zYW5pdGl6ZUZuXG4gICAgKSksIHQ7XG4gIH1cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcbiAgICAgIFwiZ1wiXG4gICAgKSwgaSA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goZSk7XG4gICAgaSAhPT0gbnVsbCAmJiBpLmxlbmd0aCA+IDAgJiYgaS5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBGdTtcbiAgfVxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpIHtcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xuICAgIGUgJiYgKHRoaXMudGlwID0gZS5lbGVtZW50cy5wb3BwZXIsIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZS5wbGFjZW1lbnQpKSk7XG4gIH1cbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBRZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgUXUgPSBcInBvcG92ZXJcIiwgSnUgPSBcInRlLnBvcG92ZXJcIiwgd3QgPSBgLiR7SnV9YCwgdHAgPSBcInRlLXBvcG92ZXJcIiwgZXAgPSB7XG4gIC4uLlFlLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICBjb250ZW50OiBcIlwiLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgei1bMTA3MF0gYmxvY2sgbWF4LXctWzI2N3B4XSBicmVhay13b3JkcyBiZy13aGl0ZSBiZy1jbGlwLXBhZGRpbmcgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLWxnIHNoYWRvdy1bMF8wcHhfM3B4XzBfcmdiYSgwLDAsMCwwLjA3KSwwXzJweF8ycHhfMF9yZ2JhKDAsMCwwLDAuMDQpXSB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpiZy1uZXV0cmFsLTcwMCBkYXJrOmJvcmRlci0wIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlciBweS0yIHB4LTQgbWItMCBib3JkZXItYi0yIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLXQtbGcgZm9udC1tZWRpdW0gZW1wdHk6aGlkZGVuIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5IHAtNCB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj48L2Rpdj4nXG59LCBpcCA9IHtcbiAgLi4uUWUuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBzcCA9IHtcbiAgSElERTogYGhpZGUke3d0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7d3R9YCxcbiAgU0hPVzogYHNob3cke3d0fWAsXG4gIFNIT1dOOiBgc2hvd24ke3d0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke3d0fWAsXG4gIENMSUNLOiBgY2xpY2ske3d0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHt3dH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHt3dH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7d3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3d0fWBcbn0sIG5wID0gXCIucG9wb3Zlci1oZWFkZXJcIiwgb3AgPSBcIi5wb3BvdmVyLWJvZHlcIjtcbmNsYXNzIFlsIGV4dGVuZHMgUWUge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZXA7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBRdTtcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBzcDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBpcDtcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBucCksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIG9wKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRwO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFlsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBtbiA9IFwic2Nyb2xsc3B5XCIsIHJwID0gXCJ0ZS5zY3JvbGxzcHlcIiwgRG8gPSBgLiR7cnB9YCwgSXIgPSB7XG4gIG9mZnNldDogMTAsXG4gIG1ldGhvZDogXCJhdXRvXCIsXG4gIHRhcmdldDogXCJcIlxufSwgYXAgPSB7XG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgbWV0aG9kOiBcInN0cmluZ1wiLFxuICB0YXJnZXQ6IFwiKHN0cmluZ3xlbGVtZW50KVwiXG59LCBscCA9IHtcbiAgYWN0aXZlOiBcIiF0ZXh0LXByaW1hcnkgZGFyazohdGV4dC1wcmltYXJ5LTQwMCBmb250LXNlbWlib2xkIGJvcmRlci1sLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5IGRhcms6Ym9yZGVyLXByaW1hcnktNDAwXCJcbn0sIGNwID0ge1xuICBhY3RpdmU6IFwic3RyaW5nXCJcbn0sIGhwID0gYGFjdGl2YXRlJHtEb31gLCBkcCA9IGBzY3JvbGwke0RvfWAsIGduID0gXCJkYXRhLXRlLW5hdi1saW5rLWFjdGl2ZVwiLCBqbCA9IFwiW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdXCIsIHVwID0gXCJbZGF0YS10ZS1uYXYtbGlzdC1yZWZdXCIsIG9vID0gXCJbZGF0YS10ZS1uYXYtbGluay1yZWZdXCIsIHBwID0gXCJbZGF0YS10ZS1uYXYtaXRlbS1yZWZdXCIsIEtsID0gXCJbZGF0YS10ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCBibiA9IGAke29vfSwgJHtLbH0sICR7amx9YCwgX3AgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgZnAgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIG1wID0gXCJtYXhPZmZzZXRcIiwgRHIgPSBcInBvc2l0aW9uXCI7XG5jbGFzcyB6bCBleHRlbmRzIEV0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC50YWdOYW1lID09PSBcIkJPRFlcIiA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCBoLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIGRwLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBJcjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIG1uO1xuICB9XG4gIC8vIFB1YmxpY1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IG1wIDogRHIsIGUgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSBcImF1dG9cIiA/IHQgOiB0aGlzLl9jb25maWcubWV0aG9kLCBpID0gZSA9PT0gRHIgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdLCB0aGlzLl90YXJnZXRzID0gW10sIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBkLmZpbmQoXG4gICAgICBibixcbiAgICAgIHRoaXMuX2NvbmZpZy50YXJnZXRcbiAgICApLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IGZvKG8pLCBhID0gciA/IGQuZmluZE9uZShyKSA6IG51bGw7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBjb25zdCBsID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGwud2lkdGggfHwgbC5oZWlnaHQpXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNbZV0oYSkudG9wICsgaSxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChvKSA9PiBvKS5zb3J0KChvLCByKSA9PiBvWzBdIC0gclswXSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKG9bMF0pLCB0aGlzLl90YXJnZXRzLnB1c2gob1sxXSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBoLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCBEbyksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uSXIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC50YXJnZXQgPSBKdCh0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBMKG1uLCB0LCBhcCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5scCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChtbiwgdCwgY3ApLCB0O1xuICB9XG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cbiAgX3Byb2Nlc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldCwgZSA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBpID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBlICYmIHRoaXMucmVmcmVzaCgpLCB0ID49IGkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IG4gJiYgdGhpcy5fYWN0aXZhdGUobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX2NsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgbi0tOyApXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcbiAgICBjb25zdCBlID0gYm4uc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChuKSA9PiBgJHtufVtkYXRhLXRlLXRhcmdldD1cIiR7dH1cIl0sJHtufVtocmVmPVwiJHt0fVwiXWBcbiAgICApLCBpID0gZC5maW5kT25lKGUuam9pbihcIixcIiksIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBpLnNldEF0dHJpYnV0ZShnbiwgXCJcIiksIGkuZ2V0QXR0cmlidXRlKGpsKSA/IGQuZmluZE9uZShcbiAgICAgIGZwLFxuICAgICAgaS5jbG9zZXN0KF9wKVxuICAgICkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpIDogZC5wYXJlbnRzKGksIHVwKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IHtcbiAgICAgICAgZC5wcmV2KFxuICAgICAgICAgIG4sXG4gICAgICAgICAgYCR7b299LCAke0tsfWBcbiAgICAgICAgKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIG8uc2V0QXR0cmlidXRlKGduLCBcIlwiKTtcbiAgICAgICAgfSksIGQucHJldihuLCBwcCkuZm9yRWFjaChcbiAgICAgICAgICAobykgPT4ge1xuICAgICAgICAgICAgZC5jaGlsZHJlbihvLCBvbykuZm9yRWFjaChcbiAgICAgICAgICAgICAgKHIpID0+IHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCBoLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgaHAsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KTtcbiAgfVxuICBfY2xlYXIoKSB7XG4gICAgZC5maW5kKGJuLCB0aGlzLl9jb25maWcudGFyZ2V0KS5maWx0ZXIoXG4gICAgICAodCkgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIHQucmVtb3ZlQXR0cmlidXRlKGduKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB6bC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgJHIgPSBcInRhYlwiLCBncCA9IFwidGUudGFiXCIsIEZzID0gYC4ke2dwfWAsIGJwID0gYGhpZGUke0ZzfWAsIHZwID0gYGhpZGRlbiR7RnN9YCwgVHAgPSBgc2hvdyR7RnN9YCwgRXAgPSBgc2hvd24ke0ZzfWAsIENwID0gXCJkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXCIsIERlID0gXCJkYXRhLXRlLXRhYi1hY3RpdmVcIiwgRXMgPSBcImRhdGEtdGUtbmF2LWFjdGl2ZVwiLCBBcCA9IFwiW2RhdGEtdGUtZHJvcGRvd24tcmVmXVwiLCB5cCA9IFwiW2RhdGEtdGUtbmF2LXJlZl1cIiwgTHIgPSBgWyR7RGV9XWAsIHdwID0gYFske0VzfV1gLCBNciA9IFwiOnNjb3BlID4gbGkgPiAuYWN0aXZlXCIsIHhwID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBrcCA9IFwiOnNjb3BlID4gW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXRlLWRyb3Bkb3duLXNob3ddXCIsIE9wID0ge1xuICBzaG93OiBcIm9wYWNpdHktMTAwXCIsXG4gIGhpZGU6IFwib3BhY2l0eS0wXCJcbn0sIFNwID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBoaWRlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgVWwgZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoZSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuICRyO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShFcykgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgZSA9IFF0KHRoaXMuX2VsZW1lbnQpLCBpID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KHlwKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIHdwLFxuICAgICAgaVxuICAgICk7XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGwgPSBpLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgaS5ub2RlTmFtZSA9PT0gXCJPTFwiID8gTXIgOiBMcjtcbiAgICAgIHQgPSBkLmZpbmQobCwgaSksIHQgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0ID8gaC50cmlnZ2VyKHQsIGJwLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSkgOiBudWxsO1xuICAgIGlmIChoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVHAsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8IG8gIT09IG51bGwgJiYgby5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGksXG4gICAgICBudWxsLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICBoLnRyaWdnZXIodCwgdnAsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFcCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGUgPyB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIGUsXG4gICAgICBlLnBhcmVudE5vZGUsXG4gICAgICBhLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApIDogYSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5PcCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTCgkciwgdCwgU3ApLCB0O1xuICB9XG4gIF9hY3RpdmF0ZSh0LCBlLCBpLCBuLCBvKSB7XG4gICAgY29uc3QgYSA9IChlICYmIChlLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZS5ub2RlTmFtZSA9PT0gXCJPTFwiKSA/IGQuZmluZChNciwgZSkgOiBkLmNoaWxkcmVuKGUsIExyKSlbMF0sIGwgPSBpICYmIGEgJiYgYS5oYXNBdHRyaWJ1dGUoRGUpLCBwID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKFxuICAgICAgdCxcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICAgIGEgJiYgbCA/IChjLnJlbW92ZUNsYXNzKGEsIHRoaXMuX2NsYXNzZXMuc2hvdyksIGMuYWRkQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgdGhpcy5fcXVldWVDYWxsYmFjayhwLCB0LCAhMCkpIDogcCgpO1xuICB9XG4gIF90cmFuc2l0aW9uQ29tcGxldGUodCwgZSwgaSwgbiwgbykge1xuICAgIGlmIChlICYmIG4pIHtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKERlKSwgbi5yZW1vdmVBdHRyaWJ1dGUoRXMpO1xuICAgICAgY29uc3QgYSA9IGQuZmluZE9uZShcbiAgICAgICAga3AsXG4gICAgICAgIGUucGFyZW50Tm9kZVxuICAgICAgKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoRGUpLCBlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKTtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoRGUsIFwiXCIpLCBvLnNldEF0dHJpYnV0ZShFcywgXCJcIiksIHQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIiAmJiB0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCBHZSh0KSwgdC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5fY2xhc3Nlcy5oaWRlKSAmJiAoYy5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmhpZGUpLCBjLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuc2hvdykpO1xuICAgIGxldCByID0gdC5wYXJlbnROb2RlO1xuICAgIGlmIChyICYmIHIubm9kZU5hbWUgPT09IFwiTElcIiAmJiAociA9IHIucGFyZW50Tm9kZSksIHIgJiYgci5oYXNBdHRyaWJ1dGUoQ3ApKSB7XG4gICAgICBjb25zdCBhID0gdC5jbG9zZXN0KEFwKTtcbiAgICAgIGEgJiYgZC5maW5kKHhwLCBhKS5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbC5zZXRBdHRyaWJ1dGUoRGUsIFwiXCIpXG4gICAgICApLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApO1xuICAgIH1cbiAgICBpICYmIGkoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBVbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3Qgdm4gPSBcInRvYXN0XCIsIElwID0gXCJ0ZS50b2FzdFwiLCBlZSA9IGAuJHtJcH1gLCBEcCA9IGBtb3VzZW92ZXIke2VlfWAsICRwID0gYG1vdXNlb3V0JHtlZX1gLCBMcCA9IGBmb2N1c2luJHtlZX1gLCBNcCA9IGBmb2N1c291dCR7ZWV9YCwgTnAgPSBgaGlkZSR7ZWV9YCwgUnAgPSBgaGlkZGVuJHtlZX1gLCBQcCA9IGBzaG93JHtlZX1gLCBCcCA9IGBzaG93biR7ZWV9YCwgTnIgPSBcImRhdGEtdGUtdG9hc3QtaGlkZVwiLCBUbiA9IFwiZGF0YS10ZS10b2FzdC1zaG93XCIsIFhpID0gXCJkYXRhLXRlLXRvYXN0LXNob3dpbmdcIiwgSHAgPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIFJyID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiA1ZTNcbn0sIFdwID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBWcCA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWGwgZXh0ZW5kcyBFdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdGltZW91dCA9IG51bGwsIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIEhwO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gUnI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB2bjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAoaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFBwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pKTtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoWGkpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQnApLCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTnIpLCBHZSh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoVG4sIFwiXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShYaSwgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ID09PSB2b2lkIDAgfHwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE5wKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChpID0gMzAwLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE5yLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoWGkpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShUbiksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBScCk7XG4gICAgICB9LCBpKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFhpLCBcIlwiKSwgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9lbGVtZW50LmRhdGFzZXQudGVUb2FzdFNob3cgIT09IHZvaWQgMCAmJiB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShUbiksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uUnIsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgTCh2biwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5XcCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTCh2biwgdCwgVnApLCB0O1xuICB9XG4gIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcbiAgICB0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiB8fCAodGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KSkpO1xuICB9XG4gIF9vbkludGVyYWN0aW9uKHQsIGUpIHtcbiAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdGhpcy5fZWxlbWVudCA9PT0gaSB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKGkpIHx8IHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIERwLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITApXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAkcCxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgTHAsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIE1wLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKTtcbiAgfVxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gWGwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4oKCkgPT4ge1xuICB2YXIgcyA9IHsgNDU0OiAoaSwgbiwgbykgPT4ge1xuICAgIG8uZChuLCB7IFo6ICgpID0+IGwgfSk7XG4gICAgdmFyIHIgPSBvKDY0NSksIGEgPSBvLm4ocikoKShmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcFsxXTtcbiAgICB9KTtcbiAgICBhLnB1c2goW2kuaWQsIFwiSU5QVVQ6LXdlYmtpdC1hdXRvZmlsbCxTRUxFQ1Q6LXdlYmtpdC1hdXRvZmlsbCxURVhUQVJFQTotd2Via2l0LWF1dG9maWxse2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxzdGFydH1JTlBVVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFNFTEVDVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFRFWFRBUkVBOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCl7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbGNhbmNlbH1Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxzdGFydHt9QGtleWZyYW1lcyBvbmF1dG9maWxsY2FuY2Vse31cIiwgXCJcIl0pO1xuICAgIGNvbnN0IGwgPSBhO1xuICB9LCA2NDU6IChpKSA9PiB7XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24obikge1xuICAgICAgdmFyIG8gPSBbXTtcbiAgICAgIHJldHVybiBvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdmFyIGEgPSBuKHIpO1xuICAgICAgICAgIHJldHVybiByWzJdID8gXCJAbWVkaWEgXCIuY29uY2F0KHJbMl0sIFwiIHtcIikuY29uY2F0KGEsIFwifVwiKSA6IGE7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9LCBvLmkgPSBmdW5jdGlvbihyLCBhLCBsKSB7XG4gICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgIHZhciBwID0ge307XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgdGhpcy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgdmFyIGYgPSB0aGlzW3VdWzBdO1xuICAgICAgICAgICAgZiAhPSBudWxsICYmIChwW2ZdID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgXyA9IDA7IF8gPCByLmxlbmd0aDsgXysrKSB7XG4gICAgICAgICAgdmFyIG0gPSBbXS5jb25jYXQocltfXSk7XG4gICAgICAgICAgbCAmJiBwW21bMF1dIHx8IChhICYmIChtWzJdID8gbVsyXSA9IFwiXCIuY29uY2F0KGEsIFwiIGFuZCBcIikuY29uY2F0KG1bMl0pIDogbVsyXSA9IGEpLCBvLnB1c2gobSkpO1xuICAgICAgICB9XG4gICAgICB9LCBvO1xuICAgIH07XG4gIH0sIDgxMDogKCkgPT4ge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwidGVzdFwiLCB7IGNhbmNlbGFibGU6ICEwIH0pO1xuICAgICAgICAgIGlmIChpLnByZXZlbnREZWZhdWx0KCksIGkuZGVmYXVsdFByZXZlbnRlZCAhPT0gITApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcHJldmVudCBkZWZhdWx0XCIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHZhciBsLCBwO1xuICAgICAgICAgICAgcmV0dXJuIChhID0gYSB8fCB7fSkuYnViYmxlcyA9ICEhYS5idWJibGVzLCBhLmNhbmNlbGFibGUgPSAhIWEuY2FuY2VsYWJsZSwgKGwgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQociwgYS5idWJibGVzLCBhLmNhbmNlbGFibGUsIGEuZGV0YWlsKSwgcCA9IGwucHJldmVudERlZmF1bHQsIGwucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmV2ZW50ZWRcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbi5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBuO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgfSwgMzc5OiAoaSwgbiwgbykgPT4ge1xuICAgIHZhciByLCBhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgRSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgaWYgKEVbVF0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBBID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihUKTtcbiAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIEEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBBID0gQS5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBBID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBFW1RdID0gQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVtUXTtcbiAgICAgIH07XG4gICAgfSgpLCBsID0gW107XG4gICAgZnVuY3Rpb24gcChFKSB7XG4gICAgICBmb3IgKHZhciBUID0gLTEsIEEgPSAwOyBBIDwgbC5sZW5ndGg7IEErKylcbiAgICAgICAgaWYgKGxbQV0uaWRlbnRpZmllciA9PT0gRSkge1xuICAgICAgICAgIFQgPSBBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdShFLCBUKSB7XG4gICAgICBmb3IgKHZhciBBID0ge30sIHcgPSBbXSwgUyA9IDA7IFMgPCBFLmxlbmd0aDsgUysrKSB7XG4gICAgICAgIHZhciBrID0gRVtTXSwgeCA9IFQuYmFzZSA/IGtbMF0gKyBULmJhc2UgOiBrWzBdLCAkID0gQVt4XSB8fCAwLCBPID0gXCJcIi5jb25jYXQoeCwgXCIgXCIpLmNvbmNhdCgkKTtcbiAgICAgICAgQVt4XSA9ICQgKyAxO1xuICAgICAgICB2YXIgTSA9IHAoTyksIFAgPSB7IGNzczoga1sxXSwgbWVkaWE6IGtbMl0sIHNvdXJjZU1hcDoga1szXSB9O1xuICAgICAgICBNICE9PSAtMSA/IChsW01dLnJlZmVyZW5jZXMrKywgbFtNXS51cGRhdGVyKFApKSA6IGwucHVzaCh7IGlkZW50aWZpZXI6IE8sIHVwZGF0ZXI6IHkoUCwgVCksIHJlZmVyZW5jZXM6IDEgfSksIHcucHVzaChPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKEUpIHtcbiAgICAgIHZhciBUID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLCBBID0gRS5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgaWYgKEEubm9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgdyA9IG8ubmM7XG4gICAgICAgIHcgJiYgKEEubm9uY2UgPSB3KTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhBKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgVC5zZXRBdHRyaWJ1dGUoaywgQVtrXSk7XG4gICAgICB9KSwgdHlwZW9mIEUuaW5zZXJ0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgRS5pbnNlcnQoVCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIFMgPSBhKEUuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCFTKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIFMuYXBwZW5kQ2hpbGQoVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVDtcbiAgICB9XG4gICAgdmFyIF8sIG0gPSAoXyA9IFtdLCBmdW5jdGlvbihFLCBUKSB7XG4gICAgICByZXR1cm4gX1tFXSA9IFQsIF8uZmlsdGVyKEJvb2xlYW4pLmpvaW4oYFxuYCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZyhFLCBULCBBLCB3KSB7XG4gICAgICB2YXIgUyA9IEEgPyBcIlwiIDogdy5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdCh3Lm1lZGlhLCBcIiB7XCIpLmNvbmNhdCh3LmNzcywgXCJ9XCIpIDogdy5jc3M7XG4gICAgICBpZiAoRS5zdHlsZVNoZWV0KVxuICAgICAgICBFLnN0eWxlU2hlZXQuY3NzVGV4dCA9IG0oVCwgUyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGsgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTKSwgeCA9IEUuY2hpbGROb2RlcztcbiAgICAgICAgeFtUXSAmJiBFLnJlbW92ZUNoaWxkKHhbVF0pLCB4Lmxlbmd0aCA/IEUuaW5zZXJ0QmVmb3JlKGssIHhbVF0pIDogRS5hcHBlbmRDaGlsZChrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdihFLCBULCBBKSB7XG4gICAgICB2YXIgdyA9IEEuY3NzLCBTID0gQS5tZWRpYSwgayA9IEEuc291cmNlTWFwO1xuICAgICAgaWYgKFMgPyBFLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFMpIDogRS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKSwgayAmJiB0eXBlb2YgYnRvYSA8IFwidVwiICYmICh3ICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYC5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoaykpKSksIFwiICovXCIpKSwgRS5zdHlsZVNoZWV0KVxuICAgICAgICBFLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHc7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IEUuZmlyc3RDaGlsZDsgKVxuICAgICAgICAgIEUucmVtb3ZlQ2hpbGQoRS5maXJzdENoaWxkKTtcbiAgICAgICAgRS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh3KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBiID0gbnVsbCwgQyA9IDA7XG4gICAgZnVuY3Rpb24geShFLCBUKSB7XG4gICAgICB2YXIgQSwgdywgUztcbiAgICAgIGlmIChULnNpbmdsZXRvbikge1xuICAgICAgICB2YXIgayA9IEMrKztcbiAgICAgICAgQSA9IGIgfHwgKGIgPSBmKFQpKSwgdyA9IGcuYmluZChudWxsLCBBLCBrLCAhMSksIFMgPSBnLmJpbmQobnVsbCwgQSwgaywgITApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEEgPSBmKFQpLCB3ID0gdi5iaW5kKG51bGwsIEEsIFQpLCBTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIGlmICh4LnBhcmVudE5vZGUgPT09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIHgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh4KTtcbiAgICAgICAgICB9KShBKTtcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB3KEUpLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgaWYgKHguY3NzID09PSBFLmNzcyAmJiB4Lm1lZGlhID09PSBFLm1lZGlhICYmIHguc291cmNlTWFwID09PSBFLnNvdXJjZU1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB3KEUgPSB4KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgUygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24oRSwgVCkge1xuICAgICAgKFQgPSBUIHx8IHt9KS5zaW5nbGV0b24gfHwgdHlwZW9mIFQuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChULnNpbmdsZXRvbiA9IChyID09PSB2b2lkIDAgJiYgKHIgPSAhISh3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYikpLCByKSk7XG4gICAgICB2YXIgQSA9IHUoRSA9IEUgfHwgW10sIFQpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgaWYgKHcgPSB3IHx8IFtdLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodykgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgIGZvciAodmFyIFMgPSAwOyBTIDwgQS5sZW5ndGg7IFMrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBwKEFbU10pO1xuICAgICAgICAgICAgbFtrXS5yZWZlcmVuY2VzLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHggPSB1KHcsIFQpLCAkID0gMDsgJCA8IEEubGVuZ3RoOyAkKyspIHtcbiAgICAgICAgICAgIHZhciBPID0gcChBWyRdKTtcbiAgICAgICAgICAgIGxbT10ucmVmZXJlbmNlcyA9PT0gMCAmJiAobFtPXS51cGRhdGVyKCksIGwuc3BsaWNlKE8sIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQSA9IHg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfSB9LCB0ID0ge307XG4gIGZ1bmN0aW9uIGUoaSkge1xuICAgIHZhciBuID0gdFtpXTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG4uZXhwb3J0cztcbiAgICB2YXIgbyA9IHRbaV0gPSB7IGlkOiBpLCBleHBvcnRzOiB7fSB9O1xuICAgIHJldHVybiBzW2ldKG8sIG8uZXhwb3J0cywgZSksIG8uZXhwb3J0cztcbiAgfVxuICBlLm4gPSAoaSkgPT4ge1xuICAgIHZhciBuID0gaSAmJiBpLl9fZXNNb2R1bGUgPyAoKSA9PiBpLmRlZmF1bHQgOiAoKSA9PiBpO1xuICAgIHJldHVybiBlLmQobiwgeyBhOiBuIH0pLCBuO1xuICB9LCBlLmQgPSAoaSwgbikgPT4ge1xuICAgIGZvciAodmFyIG8gaW4gbilcbiAgICAgIGUubyhuLCBvKSAmJiAhZS5vKGksIG8pICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IG5bb10gfSk7XG4gIH0sIGUubyA9IChpLCBuKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgbiksICgoKSA9PiB7XG4gICAgdmFyIGkgPSBlKDM3OSksIG4gPSBlLm4oaSksIG8gPSBlKDQ1NCk7XG4gICAgZnVuY3Rpb24gcihsKSB7XG4gICAgICBpZiAoIWwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSkge1xuICAgICAgICBsLnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiwgXCJcIik7XG4gICAgICAgIHZhciBwID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwLCBkZXRhaWw6IG51bGwgfSk7XG4gICAgICAgIGwuZGlzcGF0Y2hFdmVudChwKSB8fCAobC52YWx1ZSA9IFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhKGwpIHtcbiAgICAgIGwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSAmJiAobC5yZW1vdmVBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpLCBsLmRpc3BhdGNoRXZlbnQobmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICExLCBkZXRhaWw6IG51bGwgfSkpKTtcbiAgICB9XG4gICAgbigpKG8uWiwgeyBpbnNlcnQ6IFwiaGVhZFwiLCBzaW5nbGV0b246ICExIH0pLCBvLloubG9jYWxzLCBlKDgxMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLmFuaW1hdGlvbk5hbWUgPT09IFwib25hdXRvZmlsbHN0YXJ0XCIgPyByKGwudGFyZ2V0KSA6IGEobC50YXJnZXQpO1xuICAgIH0sICEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuaW5wdXRUeXBlICE9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIFwiZGF0YVwiIGluIGwgPyBhKGwudGFyZ2V0KSA6IHIobC50YXJnZXQpO1xuICAgIH0sICEwKTtcbiAgfSkoKTtcbn0pKCk7XG5jb25zdCBFbiA9IFwiaW5wdXRcIiwgR2kgPSBcInRlLmlucHV0XCIsIEdsID0gXCJkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdFwiLCBxbCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZcIiwgWmwgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgUWwgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZlwiLCBGcCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC10cmFpbGluZy1yZWZcIiwgWXAgPSBcImRhdGEtdGUtaW5wdXQtaGVscGVyLXJlZlwiLCBqcCA9IFwiZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVcIiwgRnQgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIFByID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgQnIgPSBcImRhdGEtdGUtaW5wdXQtZm9ybS1jb3VudGVyXCIsIGhlID0gYFske0dsfV0gaW5wdXRgLCBkZSA9IGBbJHtHbH1dIHRleHRhcmVhYCwgd2UgPSBgWyR7cWx9XWAsIEhyID0gYFske1psfV1gLCBXciA9IGBbJHtRbH1dYCwgS3AgPSBgWyR7WXB9XWAsIHpwID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogITFcbn0sIFVwID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogXCIoYm9vbGVhbilcIlxufSwgWHAgPSB7XG4gIG5vdGNoOiBcImdyb3VwIGZsZXggYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtdy1mdWxsIGgtZnVsbCB0ZXh0LWxlZnQgcG9pbnRlci1ldmVudHMtbm9uZVwiLFxuICBub3RjaExlYWRpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGxlZnQtMCB0b3AtMCBoLWZ1bGwgdy0yIGJvcmRlci1yLTAgcm91bmRlZC1sLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItci0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXItMFwiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIG5vdGNoTWlkZGxlOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93LTAgc2hyaW5rLTAgYmFzaXMtYXV0byB3LWF1dG8gbWF4LXctW2NhbGMoMTAwJS0xcmVtKV0gaC1mdWxsIGJvcmRlci1yLTAgYm9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdC10cmFuc3BhcmVudCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10LXRyYW5zcGFyZW50XCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hUcmFpbGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3JvdyBoLWZ1bGwgYm9yZGVyLWwtMCByb3VuZGVkLXItWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItbC0wXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZmZmZmZmLF8wXy0xcHhfMF8wXyNmZmZmZmYsXzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgY291bnRlcjogXCJ0ZXh0LXJpZ2h0IGxlYWRpbmctWzEuNl1cIlxufSwgR3AgPSB7XG4gIG5vdGNoOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBjb3VudGVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgVyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSwgdCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fbGFiZWwgPSBudWxsLCB0aGlzLl9sYWJlbFdpZHRoID0gMCwgdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgdGhpcy5fbm90Y2hMZWFkaW5nID0gbnVsbCwgdGhpcy5fbm90Y2hNaWRkbGUgPSBudWxsLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gbnVsbCwgdGhpcy5faW5pdGlhdGVkID0gITEsIHRoaXMuX2hlbHBlciA9IG51bGwsIHRoaXMuX2NvdW50ZXIgPSAhMSwgdGhpcy5fY291bnRlckVsZW1lbnQgPSBudWxsLCB0aGlzLl9tYXhMZW5ndGggPSAwLCB0aGlzLl9sZWFkaW5nSWNvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBHaSwgdGhpcyksIHRoaXMuaW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRW47XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSB8fCBkLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0aWF0ZWQgfHwgKHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9hcHBseURpdnMoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpLCB0aGlzLl9nZXRFdmVudHMoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fZ2V0Tm90Y2hEYXRhKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKTtcbiAgfVxuICBmb3JjZUFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShGdCwgXCJcIiksIGQuZmluZE9uZSh3ZSwgdGhpcy5pbnB1dC5wYXJlbnROb2RlKS5zZXRBdHRyaWJ1dGUoXG4gICAgICBGdCxcbiAgICAgIFwiXCJcbiAgICApO1xuICB9XG4gIGZvcmNlSW5hY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoRnQpLCBkLmZpbmRPbmUoXG4gICAgICB3ZSxcbiAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICkucmVtb3ZlQXR0cmlidXRlKEZ0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZUJvcmRlcigpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgR2kpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCwgZSkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uenAsXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEwoRW4sIHQsIFVwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlhwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKEVuLCB0LCBHcCksIHQ7XG4gIH1cbiAgX2dldExhYmVsRGF0YSgpIHtcbiAgICB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9sYWJlbCA9PT0gbnVsbCA/IHRoaXMuX3Nob3dQbGFjZWhvbGRlcigpIDogKHRoaXMuX2dldExhYmVsV2lkdGgoKSwgdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKCkpO1xuICB9XG4gIF9nZXRIZWxwZXIoKSB7XG4gICAgdGhpcy5faGVscGVyID0gZC5maW5kT25lKEtwLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0Q291bnRlcigpIHtcbiAgICB0aGlzLl9jb3VudGVyID0gYy5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwiaW5wdXRTaG93Y291bnRlclwiXG4gICAgKSwgdGhpcy5fY291bnRlciAmJiAodGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pbnB1dC5tYXhMZW5ndGgsIHRoaXMuX3Nob3dDb3VudGVyKCkpO1xuICB9XG4gIF9nZXRFdmVudHMoKSB7XG4gICAgaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgaGUsXG4gICAgICBXLmFjdGl2YXRlKG5ldyBXKCkpXG4gICAgKSwgaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgaGUsXG4gICAgICBXLmFjdGl2YXRlKG5ldyBXKCkpXG4gICAgKSwgaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJibHVyXCIsXG4gICAgICBoZSxcbiAgICAgIFcuZGVhY3RpdmF0ZShuZXcgVygpKVxuICAgICksIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIGRlLFxuICAgICAgVy5hY3RpdmF0ZShuZXcgVygpKVxuICAgICksIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIGRlLFxuICAgICAgVy5hY3RpdmF0ZShuZXcgVygpKVxuICAgICksIGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgZGUsXG4gICAgICBXLmRlYWN0aXZhdGUobmV3IFcoKSlcbiAgICApLCBoLm9uKHdpbmRvdywgXCJzaG93bi50ZS5tb2RhbFwiLCAodCkgPT4ge1xuICAgICAgZC5maW5kKGhlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVy5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKGRlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVy5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgaC5vbih3aW5kb3csIFwic2hvd24udGUuZHJvcGRvd25cIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCJcbiAgICAgICk7XG4gICAgICBlICYmIChkLmZpbmQoaGUsIGUpLmZvckVhY2goXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IFcuZ2V0SW5zdGFuY2UoaS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGQuZmluZChkZSwgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVy5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfSksIGgub24od2luZG93LCBcInNob3duLnRlLnRhYlwiLCAodCkgPT4ge1xuICAgICAgbGV0IGU7XG4gICAgICB0LnRhcmdldC5ocmVmID8gZSA9IHQudGFyZ2V0LmhyZWYuc3BsaXQoXCIjXCIpWzFdIDogZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJ0YXJnZXRcIikuc3BsaXQoXG4gICAgICAgIFwiI1wiXG4gICAgICApWzFdO1xuICAgICAgY29uc3QgaSA9IGQuZmluZE9uZShgIyR7ZX1gKTtcbiAgICAgIGQuZmluZChoZSwgaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gVy5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xuICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICB9KSwgZC5maW5kKGRlLCBpKS5mb3JFYWNoKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGNvbnN0IG8gPSBXLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbyAmJiBvLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBoLm9uKHdpbmRvdywgXCJyZXNldFwiLCAodCkgPT4ge1xuICAgICAgZC5maW5kKGhlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVy5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGQuZmluZChkZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFcuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkuZm9yY2VJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBoLm9uKHdpbmRvdywgXCJvbmF1dG9jb21wbGV0ZVwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFcuZ2V0SW5zdGFuY2UodC50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAhZSB8fCAhdC5jYW5jZWxhYmxlIHx8IGUuZm9yY2VBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfc2hvd0NvdW50ZXIoKSB7XG4gICAgaWYgKGQuZmluZChcbiAgICAgIGBbJHtCcn1dYCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY291bnRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBjLmFkZENsYXNzKHRoaXMuX2NvdW50ZXJFbGVtZW50LCB0aGlzLl9jbGFzc2VzLmNvdW50ZXIpLCB0aGlzLl9jb3VudGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoQnIsIFwiXCIpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHtlfSAvICR7dGhpcy5fbWF4TGVuZ3RofWAsIHRoaXMuX2hlbHBlci5hcHBlbmRDaGlsZCh0aGlzLl9jb3VudGVyRWxlbWVudCksIHRoaXMuX2JpbmRDb3VudGVyKCk7XG4gIH1cbiAgX2JpbmRDb3VudGVyKCkge1xuICAgIGgub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHt0fSAvICR7dGhpcy5fbWF4TGVuZ3RofWA7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIodCA9IHRoaXMuaW5wdXQpIHtcbiAgICBpZiAoISh0LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwiZGF0ZVwiKSlcbiAgICAgIHJldHVybjtcbiAgICAhKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHQpICYmICF0LnZhbHVlID8gdC5zdHlsZS5vcGFjaXR5ID0gMCA6IHQuc3R5bGUub3BhY2l0eSA9IDE7XG4gIH1cbiAgX3Nob3dQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShqcCwgXCJcIik7XG4gIH1cbiAgX2dldE5vdGNoRGF0YSgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZSA9IGQuZmluZE9uZShcbiAgICAgIFdyLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGQuZmluZE9uZShcbiAgICAgIEhyLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gIH1cbiAgX2dldExhYmVsV2lkdGgoKSB7XG4gICAgdGhpcy5fbGFiZWxXaWR0aCA9IHRoaXMuX2xhYmVsLmNsaWVudFdpZHRoICogMC44ICsgODtcbiAgfVxuICBfZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpIHtcbiAgICBpZiAodGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS10ZS1pbnB1dC1ncm91cC1yZWZcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQsIGUgPSBkLnByZXYoXG4gICAgICB0LFxuICAgICAgXCJbZGF0YS10ZS1pbnB1dC1ncm91cC10ZXh0LXJlZl1cIlxuICAgIClbMF07XG4gICAgZSA9PT0gdm9pZCAwID8gdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCA6IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IGUub2Zmc2V0V2lkdGggLSAxO1xuICB9XG4gIF9hcHBseURpdnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ05vcm1hbCwgZSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVOb3JtYWwsIGkgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ05vcm1hbCwgbiA9IGQuZmluZCh3ZSwgdGhpcy5fZWxlbWVudCksIG8gPSBEKFwiZGl2XCIpO1xuICAgIGMuYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy5ub3RjaCksIG8uc2V0QXR0cmlidXRlKHFsLCBcIlwiKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gRChcImRpdlwiKSwgYy5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTGVhZGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nfSAke3R9YFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZy5zZXRBdHRyaWJ1dGUoWmwsIFwiXCIpLCB0aGlzLl9ub3RjaE1pZGRsZSA9IEQoXCJkaXZcIiksIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaE1pZGRsZSxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGV9ICR7ZX1gXG4gICAgKSwgdGhpcy5fbm90Y2hNaWRkbGUuc2V0QXR0cmlidXRlKFFsLCBcIlwiKSwgdGhpcy5fbm90Y2hUcmFpbGluZyA9IEQoXCJkaXZcIiksIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaFRyYWlsaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nfSAke2l9YFxuICAgICksIHRoaXMuX25vdGNoVHJhaWxpbmcuc2V0QXR0cmlidXRlKEZwLCBcIlwiKSwgIShuLmxlbmd0aCA+PSAxKSAmJiAoby5hcHBlbmQodGhpcy5fbm90Y2hMZWFkaW5nKSwgby5hcHBlbmQodGhpcy5fbm90Y2hNaWRkbGUpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaFRyYWlsaW5nKSwgdGhpcy5fZWxlbWVudC5hcHBlbmQobykpO1xuICB9XG4gIF9hcHBseU5vdGNoKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxXaWR0aH1weGAsIHRoaXMuX25vdGNoTGVhZGluZy5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdCArIDl9cHhgLCB0aGlzLl9sYWJlbCAhPT0gbnVsbCAmJiAodGhpcy5fbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdH1weGApO1xuICB9XG4gIF9yZW1vdmVCb3JkZXIoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZSh3ZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdCAmJiB0LnJlbW92ZSgpO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgaWwoKCkgPT4ge1xuICAgICAgdGhpcy5fZ2V0RWxlbWVudHModCk7XG4gICAgICBjb25zdCBlID0gdCA/IHQudGFyZ2V0IDogdGhpcy5pbnB1dCwgaSA9IGQuZmluZE9uZShcbiAgICAgICAgd2UsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICB0ICYmIHQudHlwZSA9PT0gXCJmb2N1c1wiICYmIGkuc2V0QXR0cmlidXRlKFByLCBcIlwiKSwgZS52YWx1ZSAhPT0gXCJcIiAmJiAoZS5zZXRBdHRyaWJ1dGUoRnQsIFwiXCIpLCBpLnNldEF0dHJpYnV0ZShGdCwgXCJcIikpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRFbGVtZW50cyh0KSB7XG4gICAgaWYgKHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LnRhcmdldC5wYXJlbnROb2RlLCB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpKSwgdCAmJiB0aGlzLl9sYWJlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XG4gICAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgZSAhPT0gdGhpcy5fbGFiZWxXaWR0aCAmJiAodGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIFdyLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICAgIEhyLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9hcHBseU5vdGNoKCkpO1xuICAgIH1cbiAgfVxuICBfZGVhY3RpdmF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBkLmZpbmRPbmUoXG4gICAgICB3ZSxcbiAgICAgIGUucGFyZW50Tm9kZVxuICAgICk7XG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoUHIpLCBlLnZhbHVlID09PSBcIlwiICYmIChlLnJlbW92ZUF0dHJpYnV0ZShGdCksIGkucmVtb3ZlQXR0cmlidXRlKEZ0KSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gIH1cbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2RlYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBJLmdldERhdGEodGhpcywgR2kpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBXKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIEdpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBWciA9IFwiYW5pbWF0aW9uXCIsIENuID0gXCJ0ZS5hbmltYXRpb25cIiwgcXAgPSB7XG4gIGFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6IFwiYm9vbGVhblwiLFxuICBvblN0YXJ0OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvbkVuZDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25IaWRlOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvblNob3c6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIihzdHJpbmcpXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogXCJudW1iZXJcIixcbiAgYW5pbWF0aW9uT2Zmc2V0OiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25EZWxheTogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmV2ZXJzZTogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbkludGVydmFsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25SZXBlYXQ6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBhbmltYXRpb25SZXNldDogXCJib29sZWFuXCJcbn0sIFpwID0ge1xuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBhbmltYXRpb25TdGFydDogXCJvbkNsaWNrXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6ICEwLFxuICBvblN0YXJ0OiBudWxsLFxuICBvbkVuZDogbnVsbCxcbiAgb25IaWRlOiBudWxsLFxuICBvblNob3c6IG51bGwsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIm9uY2VcIixcbiAgYW5pbWF0aW9uV2luZG93SGVpZ2h0OiAwLFxuICBhbmltYXRpb25PZmZzZXQ6IDAsXG4gIGFuaW1hdGlvbkRlbGF5OiAwLFxuICBhbmltYXRpb25SZXZlcnNlOiAhMSxcbiAgYW5pbWF0aW9uSW50ZXJ2YWw6IDAsXG4gIGFuaW1hdGlvblJlcGVhdDogITEsXG4gIGFuaW1hdGlvblJlc2V0OiAhMVxufTtcbmNsYXNzIEpsIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9hbmltYXRlRWxlbWVudCA9IHRoaXMuX2dldEFuaW1hdGVFbGVtZW50KCksIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gITAsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBDbiwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFZyO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpO1xuICB9XG4gIGNoYW5nZUFuaW1hdGlvblR5cGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uID0gdDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIpLCBoLm9mZih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiksIGgub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgQ24pLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gbnVsbCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgXCJvbkhvdmVyXCI6XG4gICAgICAgIHRoaXMuX2JpbmRIb3ZlckV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkxvYWRcIjpcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgdGhpcy5fYmluZFNjcm9sbEV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIHRoaXMuX2JpbmRDbGlja0V2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVzZXQgJiYgdGhpcy5fYmluZFJlc2V0QW5pbWF0aW9uQWZ0ZXJGaW5pc2goKTtcbiAgfVxuICBfZ2V0QW5pbWF0ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImFuaW1hdGlvbi10YXJnZXRcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPyBkLmZpbmQodClbMF0gOiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2FuaW1hdGVFbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlpwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKFZyLCB0LCBxcCksIHQ7XG4gIH1cbiAgX2FuaW1hdGVPblNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gYy5vZmZzZXQodGhpcy5fYW5pbWF0ZUVsZW1lbnQpLnRvcCwgZSA9IHRoaXMuX2FuaW1hdGVFbGVtZW50Lm9mZnNldEhlaWdodCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbiA9IHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCA8PSBpICYmIHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCArIGUgPj0gMCwgbyA9IHRoaXMuX2FuaW1hdGVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgKG4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiB0aGlzLl9pc0ZpcnN0U2Nyb2xsKTpcbiAgICAgICAgdGhpcy5faXNGaXJzdFNjcm9sbCA9ICExLCB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChuICYmICFvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uT25TY3JvbGwgIT09IFwicmVwZWF0XCIgJiYgKHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICExKSwgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblNob3cpLCB0aGlzLl9zaG93QW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiBvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2hpZGVBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25IaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9hZGRBbmltYXRlZENsYXNzKCkge1xuICAgIGMuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9hbmltYXRlRWxlbWVudCxcbiAgICAgIGBhbmltYXRlLSR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb259YFxuICAgICk7XG4gIH1cbiAgX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWApO1xuICB9XG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uU3RhcnQpLCB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ICYmICF0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsICYmIHRoaXMuX3NldEFuaW1hdGlvblJlcGVhdCgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJldmVyc2UgJiYgdGhpcy5fc2V0QW5pbWF0aW9uUmV2ZXJzZSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICYmIHRoaXMuX3NldEFuaW1hdGlvbkRlbGF5KCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gJiYgdGhpcy5fc2V0QW5pbWF0aW9uRHVyYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25JbnRlcnZhbCgpO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXZlcnNlKCkge1xuICAgIGMuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCA9PT0gITAgPyBcImluZmluaXRlXCIgOiBcIjJcIixcbiAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogXCJhbHRlcm5hdGVcIlxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbn1tc2BcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRGVsYXkoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRGVsYXl9bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvblJlcGVhdCgpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXRcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgaC5vbih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCk7XG4gICAgICB9LCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsKTtcbiAgICB9KTtcbiAgfVxuICBfaGlkZUFuaW1hdGVFbGVtZW50KCkge1xuICAgIGMuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9KTtcbiAgfVxuICBfc2hvd0FuaW1hdGVFbGVtZW50KCkge1xuICAgIGMuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIgfSk7XG4gIH1cbiAgX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCkge1xuICAgIGgub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCkge1xuICAgIGgub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25FbmQpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kU2Nyb2xsRXZlbnRzKCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU2hvd09uTG9hZCB8fCB0aGlzLl9hbmltYXRlT25TY3JvbGwoKSwgaC5vbih3aW5kb3csIFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdGVPblNjcm9sbCgpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kQ2xpY2tFdmVudHMoKSB7XG4gICAgaC5vbih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kSG92ZXJFdmVudHMoKSB7XG4gICAgaC5vbmUodGhpcy5fZWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KSwgaC5vbmUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH1cbiAgX2NhbGxiYWNrKHQpIHtcbiAgICB0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgdCgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXQodCkge1xuICAgIHQuX2luaXQoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICBuZXcgSmwodGhpc1swXSwgdCkuaW5pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBDbik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgQW4gPSBcInJpcHBsZVwiLCBxaSA9IFwidGUucmlwcGxlXCIsIFFwID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIEpwID0gW1wiW2RhdGEtdGUtcmlwcGxlLWluaXRdXCJdLCBaaSA9IFswLCAwLCAwXSwgdF8gPSBbXG4gIHsgbmFtZTogXCJwcmltYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzNCNzFDQVwiIH0sXG4gIHsgbmFtZTogXCJzZWNvbmRhcnlcIiwgZ3JhZGllbnRDb2xvcjogXCIjOUZBNkIyXCIgfSxcbiAgeyBuYW1lOiBcInN1Y2Nlc3NcIiwgZ3JhZGllbnRDb2xvcjogXCIjMTRBNDREXCIgfSxcbiAgeyBuYW1lOiBcImRhbmdlclwiLCBncmFkaWVudENvbG9yOiBcIiNEQzRDNjRcIiB9LFxuICB7IG5hbWU6IFwid2FybmluZ1wiLCBncmFkaWVudENvbG9yOiBcIiNFNEExMUJcIiB9LFxuICB7IG5hbWU6IFwiaW5mb1wiLCBncmFkaWVudENvbG9yOiBcIiM1NEI0RDNcIiB9LFxuICB7IG5hbWU6IFwibGlnaHRcIiwgZ3JhZGllbnRDb2xvcjogXCIjZmJmYmZiXCIgfSxcbiAgeyBuYW1lOiBcImRhcmtcIiwgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCIgfVxuXSwgRnIgPSAwLjUsIGVfID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sIGlfID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCBzXyA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIG5fID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBVZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBxaSwgdGhpcyksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBBbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHFpKSwgaC5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXV0b0luaXQodCkge1xuICAgIEpwLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBkLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5taW5XaWR0aCB8fCAoYy5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBcIm1pbi13aWR0aFwiOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLndpZHRoXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbLi4udGhpcy5fZWxlbWVudC5jbGFzc0xpc3RdLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xuICB9XG4gIF9hZGRDbGlja0V2ZW50KHQpIHtcbiAgICBoLm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgX2NyZWF0ZVJpcHBsZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xuICAgIGNvbnN0IHsgbGF5ZXJYOiBlLCBsYXllclk6IGkgfSA9IHQsIG4gPSB0Lm9mZnNldFggfHwgZSwgbyA9IHQub2Zmc2V0WSB8fCBpLCByID0gdGhpcy5fZWxlbWVudC5vZmZzZXRIZWlnaHQsIGEgPSB0aGlzLl9lbGVtZW50Lm9mZnNldFdpZHRoLCBsID0gdGhpcy5fZHVyYXRpb25Ub01zTnVtYmVyKHRoaXMuX29wdGlvbnMucmlwcGxlRHVyYXRpb24pLCBwID0ge1xuICAgICAgb2Zmc2V0WDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IHIgLyAyIDogbixcbiAgICAgIG9mZnNldFk6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBhIC8gMiA6IG8sXG4gICAgICBoZWlnaHQ6IHIsXG4gICAgICB3aWR0aDogYVxuICAgIH0sIHUgPSB0aGlzLl9nZXREaWFtZXRlcihwKSwgZiA9IHRoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzIHx8IHUgLyAyLCBfID0ge1xuICAgICAgZGVsYXk6IGwgKiBGcixcbiAgICAgIGR1cmF0aW9uOiBsIC0gbCAqIEZyXG4gICAgfSwgbSA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBgJHthIC8gMiAtIGZ9cHhgIDogYCR7biAtIGZ9cHhgLFxuICAgICAgdG9wOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7ciAvIDIgLSBmfXB4YCA6IGAke28gLSBmfXB4YCxcbiAgICAgIGhlaWdodDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IHV9cHhgLFxuICAgICAgd2lkdGg6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHRyYW5zaXRpb25EZWxheTogYDBzLCAke18uZGVsYXl9bXNgLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtsfW1zLCAke18uZHVyYXRpb259bXNgXG4gICAgfSwgZyA9IEQoXCJkaXZcIik7XG4gICAgdGhpcy5fY3JlYXRlSFRNTFJpcHBsZSh7XG4gICAgICB3cmFwcGVyOiB0aGlzLl9lbGVtZW50LFxuICAgICAgcmlwcGxlOiBnLFxuICAgICAgc3R5bGVzOiBtXG4gICAgfSksIHRoaXMuX3JlbW92ZUhUTUxSaXBwbGUoeyByaXBwbGU6IGcsIGR1cmF0aW9uOiBsIH0pO1xuICB9XG4gIF9jcmVhdGVIVE1MUmlwcGxlKHsgd3JhcHBlcjogdCwgcmlwcGxlOiBlLCBzdHlsZXM6IGkgfSkge1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAobikgPT4gZS5zdHlsZVtuXSA9IGlbbl1cbiAgICApLCBjLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMucmlwcGxlV2F2ZSksIGUuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xuICB9XG4gIF9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiB0LCBkdXJhdGlvbjogZSB9KSB7XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkLmZpbmQoXCJbZGF0YS10ZS1yaXBwbGUtcmVmXVwiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSwgdGhpcy5faXNNaW5XaWR0aFNldCAmJiAoYy5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IFwibWluLXdpZHRoXCI6IFwiXCIgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9pbml0aWFsQ2xhc3NlcyA/IHRoaXMuX2FkZGVkTmV3UmlwcGxlQ2xhc3NlcyhcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLnJpcHBsZSxcbiAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3Nlc1xuICAgICAgICApIDogdGhpcy5fY2xhc3Nlcy5yaXBwbGUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIGkpO1xuICAgICAgfVxuICAgIH0sIGUpO1xuICB9XG4gIF9hZGRlZE5ld1JpcHBsZUNsYXNzZXModCwgZSkge1xuICAgIHJldHVybiB0LnNwbGl0KFwiIFwiKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gZS5maW5kSW5kZXgoKG4pID0+IGkgPT09IG4pID09PSAtMVxuICAgICk7XG4gIH1cbiAgX2R1cmF0aW9uVG9Nc051bWJlcih0KSB7XG4gICAgcmV0dXJuIE51bWJlcih0LnJlcGxhY2UoXCJtc1wiLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIjAwMFwiKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmVfLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKEFuLCB0LCBpXyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnNfLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKEFuLCB0LCBuXyksIHQ7XG4gIH1cbiAgX2dldERpYW1ldGVyKHsgb2Zmc2V0WDogdCwgb2Zmc2V0WTogZSwgaGVpZ2h0OiBpLCB3aWR0aDogbiB9KSB7XG4gICAgY29uc3QgbyA9IGUgPD0gaSAvIDIsIHIgPSB0IDw9IG4gLyAyLCBhID0gKF8sIG0pID0+IE1hdGguc3FydChfICoqIDIgKyBtICoqIDIpLCBsID0gZSA9PT0gaSAvIDIgJiYgdCA9PT0gbiAvIDIsIHAgPSB7XG4gICAgICBmaXJzdDogbyA9PT0gITAgJiYgciA9PT0gITEsXG4gICAgICBzZWNvbmQ6IG8gPT09ICEwICYmIHIgPT09ICEwLFxuICAgICAgdGhpcmQ6IG8gPT09ICExICYmIHIgPT09ICEwLFxuICAgICAgZm91cnRoOiBvID09PSAhMSAmJiByID09PSAhMVxuICAgIH0sIHUgPSB7XG4gICAgICB0b3BMZWZ0OiBhKHQsIGUpLFxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxuICAgICAgYm90dG9tTGVmdDogYSh0LCBpIC0gZSksXG4gICAgICBib3R0b21SaWdodDogYShuIC0gdCwgaSAtIGUpXG4gICAgfTtcbiAgICBsZXQgZiA9IDA7XG4gICAgcmV0dXJuIGwgfHwgcC5mb3VydGggPyBmID0gdS50b3BMZWZ0IDogcC50aGlyZCA/IGYgPSB1LnRvcFJpZ2h0IDogcC5zZWNvbmQgPyBmID0gdS5ib3R0b21SaWdodCA6IHAuZmlyc3QgJiYgKGYgPSB1LmJvdHRvbUxlZnQpLCBmICogMjtcbiAgfVxuICBfYXBwZW5kUmlwcGxlKHQsIGUpIHtcbiAgICBlLmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMuYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yaXBwbGVVbmJvdW5kID09PSAhMCA/IGMuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKSA6IGMucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKTtcbiAgfVxuICBfYWRkQ29sb3IodCkge1xuICAgIGxldCBlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvciB8fCBcInJnYigwLDAsMClcIjtcbiAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3JEYXJrIHx8IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IpO1xuICAgIGNvbnN0IGkgPSB0Xy5maW5kKFxuICAgICAgKHIpID0+IHIubmFtZSA9PT0gZS50b0xvd2VyQ2FzZSgpXG4gICAgKSwgbiA9IGkgPyB0aGlzLl9jb2xvclRvUkdCKGkuZ3JhZGllbnRDb2xvcikuam9pbihcIixcIikgOiB0aGlzLl9jb2xvclRvUkdCKGUpLmpvaW4oXCIsXCIpLCBvID0gUXAuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtufWApO1xuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7b30pYDtcbiAgfVxuICBfY29sb3JUb1JHQih0KSB7XG4gICAgZnVuY3Rpb24gZShvKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPCA3ICYmIChvID0gYCMke29bMV19JHtvWzFdfSR7b1syXX0ke29bMl19JHtvWzNdfSR7b1szXX1gKSwgW1xuICAgICAgICBwYXJzZUludChvLnN1YnN0cigxLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cigzLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cig1LCAyKSwgMTYpXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXG4gICAgICApLCBhID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgIHJldHVybiByLnN0eWxlLmNvbG9yID0gYSwgci5zdHlsZS5jb2xvciAhPT0gYSB8fCAoci5zdHlsZS5jb2xvciA9IG8sIHIuc3R5bGUuY29sb3IgPT09IGEgfHwgci5zdHlsZS5jb2xvciA9PT0gXCJcIikgPyBaaSA6IChvID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5jb2xvciwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgcmV0dXJuIG8gPSBvLm1hdGNoKC9bLlxcZF0rL2cpLm1hcCgocikgPT4gK051bWJlcihyKSksIG8ubGVuZ3RoID0gMywgbztcbiAgICB9XG4gICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc3BhcmVudFwiID8gWmkgOiB0WzBdID09PSBcIiNcIiA/IGUodCkgOiAodC5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodCA9IGkodCkpLCB0LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBuKHQpIDogWmkpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXRpYWwodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9hdXRvSW5pdChlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSS5nZXREYXRhKHRoaXMsIHFpKSA/IG51bGwgOiBuZXcgVWUodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIHFpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiBaKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gQ3Mocykge1xuICByZXR1cm4gcy5nZXREYXkoKTtcbn1cbmZ1bmN0aW9uIFkocykge1xuICByZXR1cm4gcy5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gQihzKSB7XG4gIHJldHVybiBzLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBvXyhzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBlLnN0YXJ0RGF5LCBuID0gaSA+IDAgPyA3IC0gaSA6IDAsIHIgPSBuZXcgRGF0ZShzLCB0KS5nZXREYXkoKSArIG47XG4gIHJldHVybiByID49IDcgPyByIC0gNyA6IHI7XG59XG5mdW5jdGlvbiBybyhzKSB7XG4gIHJldHVybiByXyhzKS5nZXREYXRlKCk7XG59XG5mdW5jdGlvbiByXyhzKSB7XG4gIHJldHVybiBNdChzLmdldEZ1bGxZZWFyKCksIHMuZ2V0TW9udGgoKSArIDEsIDApO1xufVxuZnVuY3Rpb24gUmUoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbn1cbmZ1bmN0aW9uIGl0KHMsIHQpIHtcbiAgcmV0dXJuIG50KHMsIHQgKiAxMik7XG59XG5mdW5jdGlvbiBudChzLCB0KSB7XG4gIGNvbnN0IGUgPSBNdChcbiAgICBzLmdldEZ1bGxZZWFyKCksXG4gICAgcy5nZXRNb250aCgpICsgdCxcbiAgICBzLmdldERhdGUoKVxuICApLCBpID0gWihzKSwgbiA9IFooZSk7XG4gIHJldHVybiBpICE9PSBuICYmIGUuc2V0RGF0ZSgwKSwgZTtcbn1cbmZ1bmN0aW9uIHhlKHMsIHQpIHtcbiAgcmV0dXJuIE10KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSArIHQpO1xufVxuZnVuY3Rpb24gTXQocywgdCwgZSkge1xuICBjb25zdCBpID0gbmV3IERhdGUocywgdCwgZSk7XG4gIHJldHVybiBzID49IDAgJiYgcyA8IDEwMCAmJiBpLnNldEZ1bGxZZWFyKGkuZ2V0RnVsbFllYXIoKSAtIDE5MDApLCBpO1xufVxuZnVuY3Rpb24gWXIocykge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi1cIiksIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl07XG4gIHJldHVybiBNdChlLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIGFfKHMpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocy5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24gTWUocywgdCkge1xuICByZXR1cm4gQihzKSAtIEIodCkgfHwgWShzKSAtIFkodCkgfHwgWihzKSAtIFoodCk7XG59XG5mdW5jdGlvbiBfZShzLCB0KSB7XG4gIHJldHVybiBzLnNldEhvdXJzKDAsIDAsIDAsIDApLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBzLmdldFRpbWUoKSA9PT0gdC5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBBcyhzLCB0KSB7XG4gIGNvbnN0IGkgPSBCKHMpIC0gY18oKTtcbiAgcmV0dXJuIGxfKGksIHQpO1xufVxuZnVuY3Rpb24gbF8ocywgdCkge1xuICByZXR1cm4gKHMgJSB0ICsgdCkgJSB0O1xufVxuZnVuY3Rpb24gY18ocywgdCwgZSkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBlID8gaSA9IEIoZSkgLSBzICsgMSA6IHQgJiYgKGkgPSBCKHQpKSwgaTtcbn1cbmZ1bmN0aW9uIFBzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBhID0gdCAmJiBNZShzLCB0KSA8PSAtMSwgbCA9IGUgJiYgTWUocywgZSkgPj0gMSwgcCA9IG4gJiYgTWUocywgcikgPD0gLTEsIHUgPSBvICYmIE1lKHMsIHIpID49IDEsIGYgPSBpICYmIGkocykgPT09ICExO1xuICByZXR1cm4gYSB8fCBsIHx8IGYgfHwgcCB8fCB1O1xufVxuZnVuY3Rpb24gdGMocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGEgPSBpICYmIEIoaSksIGwgPSBpICYmIFkoaSksIHAgPSBlICYmIEIoZSksIHUgPSBlICYmIFkoZSksIGYgPSBCKHIpLCBfID0gWShyKSwgbSA9IGwgJiYgYSAmJiAodCA+IGEgfHwgdCA9PT0gYSAmJiBzID4gbCksIGcgPSB1ICYmIHAgJiYgKHQgPCBwIHx8IHQgPT09IHAgJiYgcyA8IHUpLCB2ID0gbiAmJiAodCA8IGYgfHwgdCA9PT0gZiAmJiBzIDwgXyksIGIgPSBvICYmICh0ID4gZiB8fCB0ID09PSBmICYmIHMgPiBfKTtcbiAgcmV0dXJuIG0gfHwgZyB8fCB2IHx8IGI7XG59XG5mdW5jdGlvbiBhbyhzLCB0LCBlLCBpLCBuKSB7XG4gIGNvbnN0IG8gPSB0ICYmIEIodCksIHIgPSBlICYmIEIoZSksIGEgPSBCKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSwgbCA9IHIgJiYgcyA+IHIsIHAgPSBvICYmIHMgPCBvLCB1ID0gaSAmJiBzIDwgYSwgZiA9IG4gJiYgcyA+IGE7XG4gIHJldHVybiBsIHx8IHAgfHwgdSB8fCBmO1xufVxuZnVuY3Rpb24gaF8ocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBvICYmIE1lKG8sIGwpIDwgMCB8fCBzKSAmJiAobyA9IGwpLCBvICYmIEFpKFxuICAgIHQsXG4gICAgbyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gZF8ocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBuICYmIE1lKG4sIGwpIDwgMCB8fCBzKSAmJiAobiA9IGwpLCBuICYmIEFpKFxuICAgIHQsXG4gICAgbixcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gQWkocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICByZXR1cm4gZSA9PT0gXCJkYXlzXCIgPyBCKHMpID09PSBCKHQpICYmIFkocykgPT09IFkodCkgOiBlID09PSBcIm1vbnRoc1wiID8gQihzKSA9PT0gQih0KSA6IGUgPT09IFwieWVhcnNcIiA/IEIodCkgPj0gYSAmJiBCKHQpIDw9IHIgOiAhMTtcbn1cbmNvbnN0IHVfID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCBwXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgX18gPSBcImRhdGEtdGUtZHJvcGRvd24tYmFja2Ryb3AtcmVmXCIsIGZfID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZlwiLCBqciA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXCIsIG1fID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItcHJldmlvdXMtYnV0dG9uLXJlZlwiLCBnXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZlwiLCBiXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZcIiwgdl8gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jYW5jZWwtYnV0dG9uLXJlZlwiLCBUXyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZcIiwgRV8gPSBcImRhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXCI7XG5mdW5jdGlvbiBDXyhzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwKSB7XG4gIGNvbnN0IHUgPSBZKHMpLCBmID0gQihzKSwgXyA9IFoocyksIG0gPSBDcyhzKSwgZyA9IEQoXCJkaXZcIiksIHYgPSBgXG4gICAgICAgICR7S3IoXG4gICAgcyxcbiAgICB1LFxuICAgIGYsXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBwXG4gICl9XG4gICAgYCwgYiA9IGBcbiAgICAgICR7eV8oXywgbSwgdSwgbiwgcCl9XG4gICAgICAke0tyKFxuICAgIHMsXG4gICAgdSxcbiAgICBmLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGA7XG4gIHJldHVybiBuLmlubGluZSA/IChjLmFkZENsYXNzKGcsIHAuZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyKSwgZy5zZXRBdHRyaWJ1dGUocF8sIGwpLCBnLmlubmVySFRNTCA9IHYpIDogKGMuYWRkQ2xhc3MoZywgcC5tb2RhbENvbnRhaW5lciksIGcuc2V0QXR0cmlidXRlKHVfLCBsKSwgZy5pbm5lckhUTUwgPSBiKSwgZztcbn1cbmZ1bmN0aW9uIEFfKHMpIHtcbiAgY29uc3QgdCA9IEQoXCJkaXZcIik7XG4gIHJldHVybiBjLmFkZENsYXNzKHQsIHMpLCB0LnNldEF0dHJpYnV0ZShfXywgXCJcIiksIHQ7XG59XG5mdW5jdGlvbiB5XyhzLCB0LCBlLCBpLCBuKSB7XG4gIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJIZWFkZXJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlfVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJUaXRsZVRleHR9XCI+JHtpLnRpdGxlfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGVUZXh0fVwiICR7Zl99ID4ke2kud2Vla2RheXNTaG9ydFt0XX0sICR7aS5tb250aHNTaG9ydFtlXX0gJHtzfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xufVxuZnVuY3Rpb24gS3IocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCwgdSkge1xuICBsZXQgZjtcbiAgcmV0dXJuIHIuaW5saW5lID8gZiA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJNYWlufVwiPlxuICAgICAgJHtVcih0LCBlLCByLCB1KX1cbiAgICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlclZpZXd9XCIgJHtqcn0gdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgICR7enIoXG4gICAgcyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsLFxuICAgIHAsXG4gICAgdVxuICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAgOiBmID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAke1VyKHQsIGUsIHIsIHUpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyVmlld31cIiAke2pyfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHt6cihcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgcCxcbiAgICB1XG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICAgICR7d18ociwgdSl9XG4gICAgPC9kaXY+XG4gIGAsIGY7XG59XG5mdW5jdGlvbiB6cihzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwKSB7XG4gIGxldCB1O1xuICByZXR1cm4gby52aWV3ID09PSBcImRheXNcIiA/IHUgPSB5cyhzLCBlLCBvLCBwKSA6IG8udmlldyA9PT0gXCJtb250aHNcIiA/IHUgPSB3cyhcbiAgICB0LFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgcFxuICApIDogdSA9IHhzKFxuICAgIHMsXG4gICAgaSxcbiAgICBvLFxuICAgIGEsXG4gICAgbCxcbiAgICBwXG4gICksIHU7XG59XG5mdW5jdGlvbiBVcihzLCB0LCBlLCBpKSB7XG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF0ZUNvbnRyb2xzfVwiPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsfVwiICR7RV99PlxuICAgICAgICAke2UubW9udGhzRnVsbFtzXX0gJHt0fSAke0R0KFxuICAgIGUsXG4gICAgaVxuICApfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzfVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJQcmV2aW91c0J1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnByZXZNb250aExhYmVsfVwiICR7bV99PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyTmV4dEJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLm5leHRNb250aExhYmVsfVwiICR7Z199PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBEdChzLCB0KSB7XG4gIHJldHVybiBgXG4gIDxzcGFuIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbn1cIj5cbiAgJHtzLnZpZXdDaGFuZ2VJY29uVGVtcGxhdGV9XG4gIDwvc3Bhbj5cbiAgYDtcbn1cbmZ1bmN0aW9uIHdfKHMsIHQpIHtcbiAgY29uc3QgZSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5va0J0bkxhYmVsfVwiICR7Yl99PiR7cy5va0J0blRleHR9PC9idXR0b24+YCwgaSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5jYW5jZWxCdG5MYWJlbH1cIiAke3ZffT4ke3MuY2FuY2VsQnRuVGV4dH08L2J1dHRvbj5gLCBuID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn0gJHt0LmRhdGVwaWNrZXJDbGVhckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNsZWFyQnRuTGFiZWx9XCIgJHtUX30+JHtzLmNsZWFyQnRuVGV4dH08L2J1dHRvbj5gO1xuICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICAgXG4gICAgICAgICR7cy5yZW1vdmVDbGVhckJ0biA/IFwiXCIgOiBufVxuICAgICAgICAke3MucmVtb3ZlQ2FuY2VsQnRuID8gXCJcIiA6IGl9XG4gICAgICAgICR7cy5yZW1vdmVPa0J0biA/IFwiXCIgOiBlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIGA7XG59XG5mdW5jdGlvbiB5cyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSB4XyhzLCB0LCBlKSwgciA9IGBcbiAgICAgIDx0cj5cbiAgICAgICAgJHtlLndlZWtkYXlzTmFycm93Lm1hcCgobCwgcCkgPT4gYDx0aCBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF5SGVhZGluZ31cIiBzY29wZT1cImNvbFwiIGFyaWEtbGFiZWw9XCIke2Uud2Vla2RheXNGdWxsW3BdfVwiPiR7bH08L3RoPmApLmpvaW4oXCJcIil9XG4gICAgICA8L3RyPlxuICAgIGAsIGEgPSBuLm1hcCgobCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtsLm1hcCgocCkgPT4gYFxuICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckNlbGx9ICR7aS5kYXRlcGlja2VyQ2VsbFNtYWxsfVwiXG4gICAgICAgICAgICAgIGRhdGEtdGUtZGF0ZT1cIiR7QihwLmRhdGUpfS0ke1koXG4gICAgcC5kYXRlXG4gICl9LSR7WihwLmRhdGUpfVwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCIke3AuZGF0ZX1cIlxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiJHtwLmlzU2VsZWN0ZWR9XCJcbiAgICAgICAgICAgICAgJHtwLmlzU2VsZWN0ZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAkeyFwLmN1cnJlbnRNb250aCB8fCBwLmRpc2FibGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtwLmlzVG9kYXkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbH1cIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke3AuY3VycmVudE1vbnRoID8gXCJkaXNwbGF5OiBibG9ja1wiIDogXCJkaXNwbGF5OiBub25lXCJ9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICR7cC5kYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICR7cn1cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHthfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24geF8ocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBZKHMpLCBvID0gWShudChzLCAtMSkpLCByID0gWShudChzLCAxKSksIGEgPSBCKHMpLCBsID0gb18oYSwgbiwgZSksIHAgPSBybyhzKSwgdSA9IHJvKG50KHMsIC0xKSksIGYgPSA3O1xuICBsZXQgXyA9IDEsIG0gPSAhMTtcbiAgZm9yIChsZXQgZyA9IDE7IGcgPCBmOyBnKyspIHtcbiAgICBjb25zdCB2ID0gW107XG4gICAgaWYgKGcgPT09IDEpIHtcbiAgICAgIGNvbnN0IGIgPSB1IC0gbCArIDE7XG4gICAgICBmb3IgKGxldCB5ID0gYjsgeSA8PSB1OyB5KyspIHtcbiAgICAgICAgY29uc3QgRSA9IE10KGEsIG8sIHkpO1xuICAgICAgICB2LnB1c2goe1xuICAgICAgICAgIGRhdGU6IEUsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBtLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgX2UoRSwgdCksXG4gICAgICAgICAgaXNUb2RheTogX2UoRSwgUmUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBaKEUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbSA9ICEwO1xuICAgICAgY29uc3QgQyA9IGYgLSB2Lmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgQzsgeSsrKSB7XG4gICAgICAgIGNvbnN0IEUgPSBNdChhLCBuLCBfKTtcbiAgICAgICAgdi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBFLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogbSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIF9lKEUsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IF9lKEUsIFJlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogWihFKSxcbiAgICAgICAgICBkaXNhYmxlZDogUHMoXG4gICAgICAgICAgICBFLFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIF8rKztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAobGV0IGIgPSAxOyBiIDwgODsgYisrKSB7XG4gICAgICAgIF8gPiBwICYmIChfID0gMSwgbSA9ICExKTtcbiAgICAgICAgY29uc3QgQyA9IE10KFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbSA/IG4gOiByLFxuICAgICAgICAgIF9cbiAgICAgICAgKTtcbiAgICAgICAgdi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBDLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogbSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIF9lKEMsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IF9lKEMsIFJlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogWihDKSxcbiAgICAgICAgICBkaXNhYmxlZDogUHMoXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIF8rKztcbiAgICAgIH1cbiAgICBpLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB3cyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBrXyhpLCBuKSwgYSA9IFkoUmUoKSksIGwgPSBCKFJlKCkpLCBwID0gYFxuICAgICAgJHtyLm1hcCgodSkgPT4gYFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICR7dS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCBfID0gaS5tb250aHNTaG9ydC5pbmRleE9mKGYpO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIlxuICAgICAgICAgICAgICAgICR7dGMoXG4gICAgICBfLFxuICAgICAgcyxcbiAgICAgIGkubWluLFxuICAgICAgaS5tYXgsXG4gICAgICBpLmRpc2FibGVQYXN0LFxuICAgICAgaS5kaXNhYmxlRnV0dXJlXG4gICAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS10ZS1tb250aD1cIiR7X31cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7Zn0sICR7c31cIlxuICAgICAgICAgICAgICAgICR7XyA9PT0gZSAmJiBzID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAke18gPT09IGEgJiYgcyA9PT0gbCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cIiBkYXRhLXRlLW1vbnRoPVwiJHtffVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtmfSwgJHtzfVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke2Z9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgYDtcbiAgfSkuam9pbihcIlwiKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke3B9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBrXyhzLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLm1vbnRoc1Nob3J0Lmxlbmd0aDsgbisrKVxuICAgIGlmIChpLnB1c2gocy5tb250aHNTaG9ydFtuXSksIGkubGVuZ3RoID09PSB0KSB7XG4gICAgICBjb25zdCBvID0gaTtcbiAgICAgIGUucHVzaChvKSwgaSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB4cyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBPXyhzLCBpLCBuKSwgYSA9IEIoUmUoKSksIGwgPSBgXG4gICAgJHtyLm1hcCgocCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtwLm1hcCgodSkgPT4gYFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiICBhcmlhLWxhYmVsPVwiJHt1fVwiIGRhdGEtdGUteWVhcj1cIiR7dX1cIlxuICAgICAgICAgICAgICAke2FvKFxuICAgIHUsXG4gICAgZS5taW4sXG4gICAgZS5tYXgsXG4gICAgZS5kaXNhYmxlUGFzdCxcbiAgICBlLmRpc2FibGVGdXR1cmVcbiAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gYSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHt1fTwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIil9XG4gIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICR7bH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIE9fKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gQihzKSwgbyA9IEFzKHMsIHQpLCByID0gbiAtIG87XG4gIGxldCBhID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgdDsgbCsrKVxuICAgIGlmIChhLnB1c2gociArIGwpLCBhLmxlbmd0aCA9PT0gZSkge1xuICAgICAgY29uc3QgcCA9IGE7XG4gICAgICBpLnB1c2gocCksIGEgPSBbXTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gU18ocywgdCkge1xuICByZXR1cm4gYFxuICAgIDxidXR0b24gaWQ9XCIke3N9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0fVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz4gIFxuICAgIDwvYnV0dG9uPlxuICBgO1xufVxuY29uc3QgUGUgPSAzNywgcnQgPSAzOCwgQmUgPSAzOSwgeiA9IDQwLCBIZSA9IDM2LCBXZSA9IDM1LCB5biA9IDMzLCB3biA9IDM0LCBsdCA9IDEzLCBrcyA9IDMyLCBMaSA9IDI3LCBPaSA9IDksIElfID0gOCwgRF8gPSA0NiwgZ3QgPSAyNCwgUWkgPSA0LCBKaSA9IDQsIHhuID0gXCJkYXRlcGlja2VyXCIsIE9zID0gXCJ0ZS5kYXRlcGlja2VyXCIsIFlzID0gYC4ke09zfWAsICRfID0gXCIuZGF0YS1hcGlcIiwgTF8gPSBgY2xvc2Uke1lzfWAsIE1fID0gYG9wZW4ke1lzfWAsIE5fID0gYGRhdGVDaGFuZ2Uke1lzfWAsIHRzID0gYGNsaWNrJHtZc30keyRffWAsIGVjID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCBpYyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgZXMgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZl1cIiwgUl8gPSBgWyR7ZWN9XWAsIFBfID0gYFske2ljfV1gLCBCXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXVwiLCBIXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXVwiLCBXXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1uZXh0LWJ1dHRvbi1yZWZdXCIsIFZfID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZdXCIsIEZfID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXVwiLCBZXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jbGVhci1idXR0b24tcmVmXVwiLCBqXyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LXJlZl1cIiwgS18gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWZdXCIsIHpfID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWRhdGUtdGV4dC1yZWZdXCIsIFVfID0gXCJbZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZdXCIsIFhfID0gXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIEdfID0gXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBxXyA9IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjE1c19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgWl8gPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBRXyA9IFwiZmxleCBmbGV4LWNvbCBmaXhlZCB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB3LVszMjhweF0gaC1bNTEycHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gc2hhZG93LWxnIHotWzEwNjZdIHhzOm1heC1tZDpsYW5kc2NhcGU6dy1bNDc1cHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6aC1bMzYwcHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6ZmxleC1yb3cgZGFyazpiZy16aW5jLTcwMFwiLCBKXyA9IFwidy1mdWxsIGgtZnVsbCBmaXhlZCB0b3AtMCByaWdodC0wIGxlZnQtMCBib3R0b20tMCBiZy1ibGFjay80MCB6LVsxMDY1XVwiLCB0ZiA9IFwicmVsYXRpdmUgaC1mdWxsXCIsIGVmID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOmgtZnVsbCBoLVsxMjBweF0gcHgtNiBiZy1wcmltYXJ5IGZsZXggZmxleC1jb2wgcm91bmRlZC10LWxnIGRhcms6YmctemluYy04MDBcIiwgc2YgPSBcImgtOCBmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kXCIsIG5mID0gXCJ0ZXh0LVsxMHB4XSBmb250LW5vcm1hbCB1cHBlcmNhc2UgdHJhY2tpbmctWzEuN3B4XSB0ZXh0LXdoaXRlXCIsIG9mID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOm10LTI0IGgtWzcycHhdIGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgcmYgPSBcInRleHQtWzM0cHhdIGZvbnQtbm9ybWFsIHRleHQtd2hpdGVcIiwgYWYgPSBcIm91dGxpbmUtbm9uZSBweC0zXCIsIGxmID0gXCJweC0zIHB0LTIuNSBwYi0wIGZsZXgganVzdGlmeS1iZXR3ZWVuIHRleHQtYmxhY2svWzY0XVwiLCBjZiA9IFwiZmxleCBpdGVtcy1jZW50ZXIgb3V0bGluZS1ub25lIHAtMi41IHRleHQtbmV1dHJhbC01MDAgZm9udC1tZWRpdW0gdGV4dC1bMC45cmVtXSByb3VuZGVkLXhsIHNoYWRvdy1ub25lIGJnLXRyYW5zcGFyZW50IG0tMCBib3JkZXItbm9uZSBob3ZlcjpiZy1uZXV0cmFsLTIwMCBmb2N1czpiZy1uZXV0cmFsLTIwMCAgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCBoZiA9IFwibXQtMi41XCIsIGRmID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IG1yLTYgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpteC1hdXRvXCIsIHVmID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGhvdmVyOnJvdW5kZWQtWzUwJV0gZm9jdXM6YmctbmV1dHJhbC0yMDAgZm9jdXM6cm91bmRlZC1bNTAlXSBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwIFsmPnN2Z106dy00IFsmPnN2Z106aC00IFsmPnN2Z106cm90YXRlLTE4MCBbJj5zdmddOm14LWF1dG9cIiwgcGYgPSBcImgtMTQgZmxleCBhYnNvbHV0ZSB3LWZ1bGwgYm90dG9tLTAganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHB4LTNcIiwgX2YgPSBcIm91dGxpbmUtbm9uZSBiZy13aGl0ZSB0ZXh0LXByaW1hcnkgYm9yZGVyLW5vbmUgY3Vyc29yLXBvaW50ZXIgcHktMCBweC0yLjUgdXBwZXJjYXNlIHRleHQtWzAuOHJlbV0gbGVhZGluZy0xMCBmb250LW1lZGl1bSBoLTEwIHRyYWNraW5nLVsuMXJlbV0gcm91bmRlZC1bMTBweF0gbWItMi41IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGRhcms6YmctdHJhbnNwYXJlbnQgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCBmZiA9IFwibXItYXV0b1wiLCBtZiA9IFwidy0xMCBoLTEwIHRleHQtY2VudGVyIHRleHQtWzEycHhdIGZvbnQtbm9ybWFsIGRhcms6dGV4dC13aGl0ZVwiLCBnZiA9IFwidGV4dC1jZW50ZXIgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTp0ZXh0LW5ldXRyYWwtMzAwIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpwb2ludGVyLWV2ZW50cy1ub25lIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06aG92ZXI6Y3Vyc29yLWRlZmF1bHQgaG92ZXI6Y3Vyc29yLXBvaW50ZXIgZ3JvdXBcIiwgYmYgPSBcInctMTAgaC0xMCB4czptYXgtbWQ6bGFuZHNjYXBlOnctOCB4czptYXgtbWQ6bGFuZHNjYXBlOmgtOFwiLCB2ZiA9IFwidy1bNzZweF0gaC1bNDJweF1cIiwgVGYgPSBcIm14LWF1dG8gZ3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy1uZXV0cmFsLTMwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06YmctcHJpbWFyeSBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06dGV4dC13aGl0ZSBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06YmctbmV1dHJhbC0xMDAgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06ZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1zb2xpZCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXItYmxhY2sgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyIGRhcms6Z3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci13aGl0ZSBkYXJrOnRleHQtd2hpdGUgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06Ymctd2hpdGUvMTAgZGFyazpncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXV06dGV4dC1uZXV0cmFsLTUwMFwiLCBFZiA9IFwidy05IGgtOSBsZWFkaW5nLTkgcm91bmRlZC1bNTAlXSB0ZXh0LVsxM3B4XVwiLCBDZiA9IFwidy1bNzJweF0gaC0xMCBsZWFkaW5nLTEwIHB5LVsxcHhdIHB4LTAuNSByb3VuZGVkLVs5OTlweF1cIiwgQWYgPSBcIm14LWF1dG8gdy1bMzA0cHhdXCIsIHlmID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIFsmPnN2Z106dy01IFsmPnN2Z106aC01IGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0wLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgaG92ZXI6dGV4dC1wcmltYXJ5IGZvY3VzOnRleHQtcHJpbWFyeSBkYXJrOmhvdmVyOnRleHQtcHJpbWFyeS00MDAgZGFyazpmb2N1czp0ZXh0LXByaW1hcnktNDAwIGRhcms6dGV4dC1uZXV0cmFsLTIwMFwiLCB3ZiA9IFwiaW5saW5lLWJsb2NrIHBvaW50ZXItZXZlbnRzLW5vbmUgbWwtWzNweF0gWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpmaWxsLW5ldXRyYWwtNTAwIGRhcms6WyY+c3ZnXTpmaWxsLXdoaXRlXCIsIHhmID0gXCJ3LVszMjhweF0gaC1bMzgwcHhdIGJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93LVswcHhfMnB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLC4wNyksXzBweF8xMHB4XzIwcHhfLTJweF9yZ2JhKDAsMCwwLC4wNCldIHotWzEwNjZdIGRhcms6YmctemluYy03MDBcIiwga2YgPSB7XG4gIHRpdGxlOiBcIlNlbGVjdCBkYXRlXCIsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIG1vbnRoc0Z1bGw6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiXG4gIF0sXG4gIG1vbnRoc1Nob3J0OiBbXG4gICAgXCJKYW5cIixcbiAgICBcIkZlYlwiLFxuICAgIFwiTWFyXCIsXG4gICAgXCJBcHJcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuXCIsXG4gICAgXCJKdWxcIixcbiAgICBcIkF1Z1wiLFxuICAgIFwiU2VwXCIsXG4gICAgXCJPY3RcIixcbiAgICBcIk5vdlwiLFxuICAgIFwiRGVjXCJcbiAgXSxcbiAgd2Vla2RheXNGdWxsOiBbXG4gICAgXCJTdW5kYXlcIixcbiAgICBcIk1vbmRheVwiLFxuICAgIFwiVHVlc2RheVwiLFxuICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgXCJUaHVyc2RheVwiLFxuICAgIFwiRnJpZGF5XCIsXG4gICAgXCJTYXR1cmRheVwiXG4gIF0sXG4gIHdlZWtkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgd2Vla2RheXNOYXJyb3c6IFtcIlNcIiwgXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIl0sXG4gIG9rQnRuVGV4dDogXCJPa1wiLFxuICBjbGVhckJ0blRleHQ6IFwiQ2xlYXJcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJDYW5jZWxcIixcbiAgb2tCdG5MYWJlbDogXCJDb25maXJtIHNlbGVjdGlvblwiLFxuICBjbGVhckJ0bkxhYmVsOiBcIkNsZWFyIHNlbGVjdGlvblwiLFxuICBjYW5jZWxCdG5MYWJlbDogXCJDYW5jZWwgc2VsZWN0aW9uXCIsXG4gIG5leHRNb250aExhYmVsOiBcIk5leHQgbW9udGhcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwiUHJldmlvdXMgbW9udGhcIixcbiAgbmV4dFllYXJMYWJlbDogXCJOZXh0IHllYXJcIixcbiAgcHJldlllYXJMYWJlbDogXCJQcmV2aW91cyB5ZWFyXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE1Ljc1IDE5LjVMOC4yNSAxMmw3LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJOZXh0IDI0IHllYXJzXCIsXG4gIHByZXZNdWx0aVllYXJMYWJlbDogXCJQcmV2aW91cyAyNCB5ZWFyc1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJDaG9vc2UgeWVhciBhbmQgbW9udGhcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzd2l0Y2hUb0RheVZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzdGFydERhdGU6IG51bGwsXG4gIHN0YXJ0RGF5OiAwLFxuICBmb3JtYXQ6IFwiZGQvbW0veXl5eVwiLFxuICB2aWV3OiBcImRheXNcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBtaW46IG51bGwsXG4gIG1heDogbnVsbCxcbiAgZmlsdGVyOiBudWxsLFxuICBpbmxpbmU6ICExLFxuICB0b2dnbGVCdXR0b246ICEwLFxuICBkaXNhYmxlVG9nZ2xlQnV0dG9uOiAhMSxcbiAgZGlzYWJsZUlucHV0OiAhMSxcbiAgYW5pbWF0aW9uczogITAsXG4gIGNvbmZpcm1EYXRlT25TZWxlY3Q6ICExLFxuICByZW1vdmVPa0J0bjogITEsXG4gIHJlbW92ZUNhbmNlbEJ0bjogITEsXG4gIHJlbW92ZUNsZWFyQnRuOiAhMVxufSwgT2YgPSB7XG4gIHRpdGxlOiBcInN0cmluZ1wiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIG1vbnRoc0Z1bGw6IFwiYXJyYXlcIixcbiAgbW9udGhzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNGdWxsOiBcImFycmF5XCIsXG4gIHdlZWtkYXlzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNOYXJyb3c6IFwiYXJyYXlcIixcbiAgb2tCdG5UZXh0OiBcInN0cmluZ1wiLFxuICBjbGVhckJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIG9rQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcInN0cmluZ1wiLFxuICBuZXh0TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIHByZXZZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjaGFuZ2VNb250aEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvTW9udGhWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcInN0cmluZ1wiLFxuICBzdGFydERhdGU6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIHN0YXJ0RGF5OiBcIm51bWJlclwiLFxuICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gIHZpZXc6IFwic3RyaW5nXCIsXG4gIHZpZXdDaGFuZ2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIG1pbjogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgbWF4OiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBmaWx0ZXI6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIHRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlSW5wdXQ6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIixcbiAgY29uZmlybURhdGVPblNlbGVjdDogXCJib29sZWFuXCIsXG4gIHJlbW92ZU9rQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2FuY2VsQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2xlYXJCdG46IFwiYm9vbGVhblwiXG59LCBTZiA9IHtcbiAgZmFkZUluOiBYXyxcbiAgZmFkZU91dDogR18sXG4gIGZhZGVJblNob3J0OiBxXyxcbiAgZmFkZU91dFNob3J0OiBaXyxcbiAgbW9kYWxDb250YWluZXI6IFFfLFxuICBkYXRlcGlja2VyQmFja2Ryb3A6IEpfLFxuICBkYXRlcGlja2VyTWFpbjogdGYsXG4gIGRhdGVwaWNrZXJIZWFkZXI6IGVmLFxuICBkYXRlcGlja2VyVGl0bGU6IHNmLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBuZixcbiAgZGF0ZXBpY2tlckRhdGU6IG9mLFxuICBkYXRlcGlja2VyRGF0ZVRleHQ6IHJmLFxuICBkYXRlcGlja2VyVmlldzogYWYsXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IGxmLFxuICBkYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbjogY2YsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbjogd2YsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBoZixcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBkZixcbiAgZGF0ZXBpY2tlck5leHRCdXR0b246IHVmLFxuICBkYXRlcGlja2VyRm9vdGVyOiBwZixcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogX2YsXG4gIGRhdGVwaWNrZXJDbGVhckJ0bjogZmYsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBtZixcbiAgZGF0ZXBpY2tlckNlbGw6IGdmLFxuICBkYXRlcGlja2VyQ2VsbFNtYWxsOiBiZixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogdmYsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogVGYsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsOiBFZixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IENmLFxuICBkYXRlcGlja2VyVGFibGU6IEFmLFxuICBkYXRlcGlja2VyVG9nZ2xlQnV0dG9uOiB5ZixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiB4ZlxufSwgSWYgPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIixcbiAgZmFkZUluU2hvcnQ6IFwic3RyaW5nXCIsXG4gIGZhZGVPdXRTaG9ydDogXCJzdHJpbmdcIixcbiAgbW9kYWxDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlck1haW46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJIZWFkZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUaXRsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXc6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQXJyb3dDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF5SGVhZGluZzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsTGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGFibGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEYwIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSB0aGlzLl9vcHRpb25zLnZpZXcsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IGJ0KFwiZGF0ZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBraSgpLCB0aGlzLl9lbGVtZW50ICYmIEkuc2V0RGF0YSh0LCBPcywgdGhpcyksIHRoaXMuX2luaXQoKSwgdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy5kaXNhYmxlVG9nZ2xlICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5kaXNhYmxlZCA9IFwidHJ1ZVwiKSwgdGhpcy5fb3B0aW9ucy5kaXNhYmxlSW5wdXQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB4bjtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBgWyR7ZWN9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICkgfHwgZC5maW5kT25lKFxuICAgICAgYFske2ljfT0nJHt0aGlzLl90b2dnbGVCdXR0b25JZH0nXWBcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIGdldCBhY3RpdmVDZWxsKCkge1xuICAgIGxldCB0O1xuICAgIHJldHVybiB0aGlzLl92aWV3ID09PSBcImRheXNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZURheUNlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIgJiYgKHQgPSB0aGlzLl9nZXRBY3RpdmVNb250aENlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZVllYXJDZWxsKCkpLCB0O1xuICB9XG4gIGdldCBhY3RpdmVEYXkoKSB7XG4gICAgcmV0dXJuIFoodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZU1vbnRoKCkge1xuICAgIHJldHVybiBZKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVZZWFyKCkge1xuICAgIHJldHVybiBCKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBmaXJzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlWWVhciAtIEFzKHRoaXMuX2FjdGl2ZURhdGUsIGd0KTtcbiAgfVxuICBnZXQgbGFzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RZZWFySW5WaWV3ICsgZ3QgLSAxO1xuICB9XG4gIGdldCB2aWV3Q2hhbmdlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoQl8sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShIXywgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoV18sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgb2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShWXywgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShGXywgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFlfLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGRhdGVzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoal8sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoS18sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLmtmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHhuLCB0LCBPZiksIHQubWF4ICYmIHR5cGVvZiB0Lm1heCA9PSBcInN0cmluZ1wiICYmICh0Lm1heCA9IG5ldyBEYXRlKHQubWF4KSksIHQubWluICYmIHR5cGVvZiB0Lm1pbiA9PSBcInN0cmluZ1wiICYmICh0Lm1pbiA9IG5ldyBEYXRlKHQubWluKSksIHQuc3RhcnREYXkgJiYgdC5zdGFydERheSAhPT0gMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE5ld0RheXNPcmRlckFycmF5KHQpO1xuICAgICAgdC53ZWVrZGF5c05hcnJvdyA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uU2YsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoeG4sIHQsIElmKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXROZXdEYXlzT3JkZXJBcnJheSh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhcnREYXksIGkgPSB0LndlZWtkYXlzTmFycm93O1xuICAgIHJldHVybiBpLnNsaWNlKGUpLmNvbmNhdChpLnNsaWNlKDAsIGUpKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICAhdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBTXyhcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyVG9nZ2xlQnV0dG9uXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE1fKTtcbiAgICBpZiAodGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSBBXyh0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJCYWNrZHJvcCksIGkgPSBDXyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEppLFxuICAgICAgZ3QsXG4gICAgICBRaSxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9vcGVuRHJvcGRvd24oaSkgOiAodGhpcy5fb3Blbk1vZGFsKGUsIGkpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiAoYy5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBjLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuZmFkZUluU2hvcnQpKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKHRoaXMuY29udGFpbmVyKSwgdGhpcy5fbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCksIHRoaXMuX2FkZENvbnRyb2xzTGlzdGVuZXJzKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpLCB0aGlzLl9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0aGlzLl92aWV3KSwgdGhpcy5faXNPcGVuID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBFZSh0aGlzLl9pbnB1dCwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgfSksIHRoaXMuX2dldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9vcGVuTW9kYWwodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLmFwcGVuZENoaWxkKHQpLCBpLmFwcGVuZENoaWxkKGUpO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAodCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyAkaSh0LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246IChlKSA9PiBlLmtleSA9PT0gXCJUYWJcIlxuICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICB9XG4gIF9saXN0ZW5Ub1VzZXJJbnB1dCgpIHtcbiAgICBoLm9uKHRoaXMuX2lucHV0LCBcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVVc2VySW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdHMsXG4gICAgICBlcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBlcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgIXRoaXMuX2lzT3BlbiAmJiB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSB7XG4gICAgaC5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQgOiB0LnRhcmdldC5kYXRhc2V0LCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlIDogdC50YXJnZXQ7XG4gICAgaWYgKGUudGVEYXRlICYmIHRoaXMuX3BpY2tEYXkoZS50ZURhdGUsIGkpLCBlLnRlTW9udGggJiYgZS50ZVllYXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlTW9udGgsIDEwKSwgbyA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrTW9udGgobiwgbyk7XG4gICAgfVxuICAgIGlmIChlLnRlWWVhciAmJiAhZS50ZU1vbnRoKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tZZWFyKG4pO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF91cGRhdGVIZWFkZXJEYXRlKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgel8sXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICksIG8gPSBZKHQpLCByID0gWih0KSwgYSA9IENzKHQpO1xuICAgIG4uaW5uZXJIVE1MID0gYCR7aVthXX0sICR7ZVtvXX0gJHtyfWA7XG4gIH1cbiAgX2FkZENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIGgub24odGhpcy5uZXh0QnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5uZXh0TW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMubmV4dFllYXJzKCkgOiB0aGlzLm5leHRZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCBoLm9uKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLnByZXZpb3VzTW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMucHJldmlvdXNZZWFycygpIDogdGhpcy5wcmV2aW91c1llYXIoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gICAgfSksIGgub24odGhpcy52aWV3Q2hhbmdlQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5fY2hhbmdlVmlldyhcInllYXJzXCIpIDogKHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiB8fCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiKSAmJiB0aGlzLl9jaGFuZ2VWaWV3KFwiZGF5c1wiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKTtcbiAgfVxuICBfbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKSB7XG4gICAgaC5vbih0aGlzLm9rQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlT2soKSksIGgub24odGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDYW5jZWwoKSksIGgub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZUNsZWFyKCkpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICBoLm9uKGRvY3VtZW50LCB0cywgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIsIGkgPSB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgICAhZSAmJiAhaSAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlQ2xpY2soKSB7XG4gICAgaC5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0LmtleUNvZGUgPT09IExpICYmIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCkge1xuICAgIGgub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVLZXlkb3duKHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyRm9jdXMoKSB7XG4gICAgaC5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpIHtcbiAgICBoLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgJiYgdGhpcy5faGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiICYmIHRoaXMuX2hhbmRsZU1vbnRoc1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgJiYgdGhpcy5faGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KTtcbiAgfVxuICBfaGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBQZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBydDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIC03KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZSh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gWih0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZShcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIHJvKHRoaXMuX2FjdGl2ZURhdGUpIC0gWih0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeW46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICBjYXNlIGtzOlxuICAgICAgICB0aGlzLl9zZWxlY3REYXRlKHRoaXMuX2FjdGl2ZURhdGUpLCB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQWkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBndCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfYXN5bmNGb2N1c0RhdGVzQ29udGFpbmVyKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIF9mb2N1c0FjdGl2ZUNlbGwodCkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIsIFwiXCIpO1xuICB9XG4gIF9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIik7XG4gIH1cbiAgX2dldEFjdGl2ZURheUNlbGwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBZcihpLmRhdGFzZXQudGVEYXRlKTtcbiAgICAgIHJldHVybiBfZShuLCB0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlTW9udGhzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIFBlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDExIC0gdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHduOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsdDpcbiAgICAgIGNhc2Uga3M6XG4gICAgICAgIHRoaXMuX3NlbGVjdE1vbnRoKHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIEFpKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgZ3QsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4XG4gICAgKSB8fCB0aGlzLl9jaGFuZ2VWaWV3KFwibW9udGhzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfZ2V0QWN0aXZlTW9udGhDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlWWVhciwgMTApLCBvID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlTW9udGgsIDEwKTtcbiAgICAgIHJldHVybiBuID09PSB0aGlzLmFjdGl2ZVllYXIgJiYgbyA9PT0gdGhpcy5hY3RpdmVNb250aDtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGwsIG4gPSA0LCBvID0gMjQ7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgUGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgLUFzKHRoaXMuX2FjdGl2ZURhdGUsIG8pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgbyAtIEFzKHRoaXMuX2FjdGl2ZURhdGUsIG8pIC0gMVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeW46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICBjYXNlIGtzOlxuICAgICAgICB0aGlzLl9zZWxlY3RZZWFyKHRoaXMuYWN0aXZlWWVhcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQWkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBndCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZVllYXJDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCkgPT09IHRoaXMuYWN0aXZlWWVhcik7XG4gIH1cbiAgX3NldEluaXRpYWxEYXRlKCkge1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID8gdGhpcy5faGFuZGxlVXNlcklucHV0KHRoaXMuX2lucHV0LnZhbHVlKSA6IHRoaXMuX29wdGlvbnMuc3RhcnREYXRlID8gdGhpcy5fYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSA6IHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIExfKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpLCB0aGlzLl9hbmltYXRpb25zICYmIGMuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fY2xvc2VEcm9wZG93bigpIDogdGhpcy5fY2xvc2VNb2RhbCgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy50b2dnbGVCdXR0b24gPyB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpIDogdGhpcy5faW5wdXQuZm9jdXMoKSk7XG4gIH1cbiAgX2Nsb3NlRHJvcGRvd24oKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShQXyksIGUgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgKHQgJiYgZS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCkpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdCAmJiBlLnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fcmVtb3ZlRm9jdXNUcmFwKCk7XG4gIH1cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShVXyksIGUgPSBkLmZpbmRPbmUoUl8pO1xuICAgICFlIHx8ICF0IHx8ICh0aGlzLl9hbmltYXRpb25zID8gKGMuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0U2hvcnQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KSkgOiAodGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSkpO1xuICB9XG4gIF9yZW1vdmVQaWNrZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLnJlbW92ZUNoaWxkKHQpLCBpLnJlbW92ZUNoaWxkKGUpO1xuICB9XG4gIF9yZW1vdmVGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwICYmICh0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpIHtcbiAgICBoLm9mZih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiKSwgaC5vZmYodGhpcy5va0J1dHRvbiwgXCJjbGlja1wiKSwgaC5vZmYodGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiKSwgaC5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiKSwgaC5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIpLCBoLm9mZihkb2N1bWVudCwgdHMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYCMke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfWBcbiAgICApO1xuICAgIHQgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0KSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIE9zKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2FjdGl2ZURhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpIHtcbiAgICBoLm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKSwgaC5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdHMsXG4gICAgICBlc1xuICAgICksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93blwiLCBlcyk7XG4gIH1cbiAgaGFuZGxlT2soKSB7XG4gICAgdGhpcy5fY29uZmlybVNlbGVjdGlvbih0aGlzLl9oZWFkZXJEYXRlKSwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZWxlY3REYXRlKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBmaWx0ZXI6IG8sIGRpc2FibGVQYXN0OiByLCBkaXNhYmxlRnV0dXJlOiBhIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIFBzKHQsIGksIG4sIG8sIHIsIGEpIHx8ICh0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gdCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQih0KSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkodCksIHRoaXMuX2hlYWRlckRhdGUgPSB0LCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5vcHRpb25zLmNvbmZpcm1EYXRlT25TZWxlY3QpICYmICh0aGlzLl9jb25maXJtU2VsZWN0aW9uKHQpLCB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBfc2VsZWN0WWVhcih0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlclllYXIgPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJtb250aHNcIik7XG4gIH1cbiAgX3NlbGVjdE1vbnRoKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyTW9udGggPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICB9XG4gIF9yZW1vdmVTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9hZGRTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIsIFwiXCIpO1xuICB9XG4gIF9jb25maXJtU2VsZWN0aW9uKHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZm9ybWF0RGF0ZSh0KTtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gZSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE5fLCB7IGRhdGU6IHQgfSksIGgudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgaGFuZGxlQ2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fc2V0SW5pdGlhbERhdGUoKSwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIGZvcm1hdERhdGUodCkge1xuICAgIGNvbnN0IGUgPSBaKHQpLCBpID0gdGhpcy5fYWRkTGVhZGluZ1plcm8oWih0KSksIG4gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRbQ3ModCldLCBvID0gdGhpcy5fb3B0aW9ucy53ZWVrZGF5c0Z1bGxbQ3ModCldLCByID0gWSh0KSArIDEsIGEgPSB0aGlzLl9hZGRMZWFkaW5nWmVybyhZKHQpICsgMSksIGwgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0W1kodCldLCBwID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW1kodCldLCB1ID0gQih0KS50b1N0cmluZygpLmxlbmd0aCA9PT0gMiA/IEIodCkgOiBCKHQpLnRvU3RyaW5nKCkuc2xpY2UoMiwgNCksIGYgPSBCKHQpLCBfID0gdGhpcy5fb3B0aW9ucy5mb3JtYXQuc3BsaXQoXG4gICAgICAvKGR7MSw0fXxtezEsNH18eXs0fXx5eXwhLikvZ1xuICAgICk7XG4gICAgbGV0IG0gPSBcIlwiO1xuICAgIHJldHVybiBfLmZvckVhY2goKGcpID0+IHtcbiAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICBjYXNlIFwiZGRkZFwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgbyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbW1tXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIHUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbSArPSBnO1xuICAgIH0pLCBtO1xuICB9XG4gIF9hZGRMZWFkaW5nWmVybyh0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHQsIDEwKSA8IDEwID8gYDAke3R9YCA6IHQ7XG4gIH1cbiAgX3BpY2tEYXkodCwgZSkge1xuICAgIGNvbnN0IGkgPSBZcih0KSwgeyBtaW46IG4sIG1heDogbywgZmlsdGVyOiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBQcyhpLCBuLCBvLCByLCBhLCBsKSB8fCAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdERhdGUoaSwgZSkpO1xuICB9XG4gIF9waWNrWWVhcih0KSB7XG4gICAgY29uc3QgeyBtaW46IGUsIG1heDogaSwgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKGFvKHQsIGUsIGksIG4sIG8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBNdCh0LCB0aGlzLmFjdGl2ZU1vbnRoLCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdFllYXIodCk7XG4gIH1cbiAgX3BpY2tNb250aCh0LCBlKSB7XG4gICAgY29uc3QgeyBtaW46IGksIG1heDogbiwgZGlzYWJsZVBhc3Q6IG8sIGRpc2FibGVGdXR1cmU6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKHRjKHQsIGUsIGksIG4sIG8sIHIpIHx8IGFvKGUsIGksIG4sIG8sIHIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBNdChlLCB0LCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGEsIHRoaXMuX3NlbGVjdE1vbnRoKHQpO1xuICB9XG4gIG5leHRNb250aCgpIHtcbiAgICBjb25zdCB0ID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMSksIGUgPSB5cyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gRHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c01vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHlzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IER0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXIoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gd3MoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEppLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzWWVhcigpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gd3MoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEppLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIG5leHRZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSB4cyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgZ3QsXG4gICAgICBRaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IER0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTI0KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0geHMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGd0LFxuICAgICAgUWksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIF9hc3luY0NoYW5nZVZpZXcodCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2hhbmdlVmlldyh0KTtcbiAgICB9LCAwKTtcbiAgfVxuICBfY2hhbmdlVmlldyh0KSB7XG4gICAgdGhpcy5fdmlldyA9IHQsIHRoaXMuZGF0ZXNDb250YWluZXIuYmx1cigpLCB0ID09PSBcImRheXNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSB5cyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJtb250aHNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSB3cyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgSmksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHQgPT09IFwieWVhcnNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSB4cyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgZ3QsXG4gICAgICBRaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpLCB0aGlzLl91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgfVxuICBfdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0KSB7XG4gICAgdCA9PT0gXCJkYXlzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZNb250aExhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fb3B0aW9ucy5uZXh0TW9udGhMYWJlbCkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb0RheVZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRZZWFyTGFiZWwpKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBEdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb01vbnRoVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk11bHRpWWVhckxhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5uZXh0TXVsdGlZZWFyTGFiZWxcbiAgICApKTtcbiAgfVxuICBfdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCkge1xuICAgIGhfKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBndCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5uZXh0QnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMSwgZF8oXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0LFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBndCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICEwIDogdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICExO1xuICB9XG4gIF9oYW5kbGVVc2VySW5wdXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREZWxpbWV0ZXJzKHRoaXMuX29wdGlvbnMuZm9ybWF0KSwgaSA9IHRoaXMuX3BhcnNlRGF0ZSh0LCB0aGlzLl9vcHRpb25zLmZvcm1hdCwgZSk7XG4gICAgYV8oaSkgPyAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkWWVhciA9IEIoaSksIHRoaXMuX3NlbGVjdGVkTW9udGggPSBZKGkpLCB0aGlzLl9oZWFkZXJEYXRlID0gaSkgOiAodGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwpO1xuICB9XG4gIF9nZXREZWxpbWV0ZXJzKHQpIHtcbiAgICByZXR1cm4gdC5tYXRjaCgvW14oZG15KV17MSx9L2cpO1xuICB9XG4gIF9wYXJzZURhdGUodCwgZSwgaSkge1xuICAgIGxldCBuO1xuICAgIGlbMF0gIT09IGlbMV0gPyBuID0gaVswXSArIGlbMV0gOiBuID0gaVswXTtcbiAgICBjb25zdCBvID0gbmV3IFJlZ0V4cChgWyR7bn1dYCksIHIgPSB0LnNwbGl0KG8pLCBhID0gZS5zcGxpdChvKSwgbCA9IGUuaW5kZXhPZihcIm1tbVwiKSAhPT0gLTEsIHAgPSBbXTtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IGEubGVuZ3RoOyB2KyspXG4gICAgICBhW3ZdLmluZGV4T2YoXCJ5eVwiKSAhPT0gLTEgJiYgKHBbMF0gPSB7IHZhbHVlOiByW3ZdLCBmb3JtYXQ6IGFbdl0gfSksIGFbdl0uaW5kZXhPZihcIm1cIikgIT09IC0xICYmIChwWzFdID0geyB2YWx1ZTogclt2XSwgZm9ybWF0OiBhW3ZdIH0pLCBhW3ZdLmluZGV4T2YoXCJkXCIpICE9PSAtMSAmJiBhW3ZdLmxlbmd0aCA8PSAyICYmIChwWzJdID0geyB2YWx1ZTogclt2XSwgZm9ybWF0OiBhW3ZdIH0pO1xuICAgIGxldCB1O1xuICAgIGUuaW5kZXhPZihcIm1tbW1cIikgIT09IC0xID8gdSA9IHRoaXMuX29wdGlvbnMubW9udGhzRnVsbCA6IHUgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0O1xuICAgIGNvbnN0IGYgPSBOdW1iZXIocFswXS52YWx1ZSksIF8gPSBsID8gdGhpcy5nZXRNb250aE51bWJlckJ5TW9udGhOYW1lKHBbMV0udmFsdWUsIHUpIDogTnVtYmVyKHBbMV0udmFsdWUpIC0gMSwgbSA9IE51bWJlcihwWzJdLnZhbHVlKTtcbiAgICByZXR1cm4gTXQoZiwgXywgbSk7XG4gIH1cbiAgZ2V0TW9udGhOdW1iZXJCeU1vbnRoTmFtZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUuZmluZEluZGV4KChpKSA9PiBpID09PSB0KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgT3MpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IERmID0gKHtcbiAgZm9ybWF0MjQ6IHMsXG4gIG9rTGFiZWw6IHQsXG4gIGNhbmNlbExhYmVsOiBlLFxuICBoZWFkSUQ6IGksXG4gIGZvb3RlcklEOiBuLFxuICBib2R5SUQ6IG8sXG4gIHBpY2tlcklEOiByLFxuICBjbGVhckxhYmVsOiBhLFxuICBpbmxpbmU6IGwsXG4gIHNob3dDbGVhckJ0bjogcCxcbiAgYW1MYWJlbDogdSxcbiAgcG1MYWJlbDogZlxufSwgXykgPT4ge1xuICBjb25zdCBtID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke18udGltZXBpY2tlcldyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlckNvbnRhaW5lcn1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyRWxlbWVudHN9XCI+XG4gICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke18udGltZXBpY2tlckhlYWR9JyBzdHlsZT0ncGFkZGluZy1yaWdodDoke3MgPyA1MCA6IDEwfXB4Jz5cbiAgICAgICAgPGRpdiBjbGFzcz0nJHtfLnRpbWVwaWNrZXJIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VyQ3VycmVudEJ1dHRvbn0nIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hY3RpdmUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJEb3R9JyBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLW1pbnV0ZSBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke18udGltZXBpY2tlck1vZGVBbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCIke18udGltZXBpY2tlck1vZGVQbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItcG0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7Zn08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgJHtsID8gXCJcIiA6IGA8ZGl2IGlkPScke299JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJDbG9ja1dyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2std3JhcHBlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Xy50aW1lcGlja2VyQ2xvY2t9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2s+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPScke18udGltZXBpY2tlck1pZGRsZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1taWRkbGUtZG90Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtfLnRpbWVwaWNrZXJIYW5kUG9pbnRlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1oYW5kLXBvaW50ZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtfLnRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlfScgZGF0YS10ZS10aW1lcGlja2VyLWNpcmNsZT48L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/ICc8ZGl2IGNsYXNzPVwiJyArIF8udGltZXBpY2tlckNsb2NrSW5uZXIgKyAnXCIgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLWlubmVyPjwvZGl2PicgOiBcIlwifVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+YH1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPScke259JyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJGb290ZXJXcmFwcGVyfSc+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICR7cCA/IGA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNsZWFyIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHthfTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Xy50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNhbmNlbCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke18udGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gLCBnID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke18udGltZXBpY2tlcklubGluZVdyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lQ29udGFpbmVyfVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUVsZW1lbnRzfVwiPlxuICAgICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke18udGltZXBpY2tlcklubGluZUhlYWR9J1xuICAgICAgICAgIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OjEwcHgnPlxuICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Xy50aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnR9Jz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pbmxpbmUtaG91ci1pY29ucz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uVXB9XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tdXAgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLWhvdXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+ICAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uRG93bn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gIFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVEb3R9JyBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgZGlzYWJsZWQ+OjwvYnV0dG9uPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtbWludXRlPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxNS43NWw3LjUtNy41IDcuNSA3LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke18udGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke18udGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWljb24tZG93bj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPiBcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPVwiJHtfLnRpbWVwaWNrZXJJbmxpbmVNb2RlQW19XCIgZGF0YS10ZS10aW1lcGlja2VyLWFtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3V9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Xy50aW1lcGlja2VySW5saW5lTW9kZVBtfVwiIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS10aW1lcGlja2VyLXBtIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtmfTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICAgICAgICAke3MgPyBgPGJ1dHRvbiBjbGFzcz0nJHtfLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+YDtcbiAgcmV0dXJuIGwgPyBnIDogbTtcbn0sICRmID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgeyBpY29uU1ZHOiBpIH0gPSBzO1xuICByZXR1cm4gYFxuICA8YnV0dG9uIGlkPVwiJHt0fVwiIHRhYmluZGV4PVwiMFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7ZS50aW1lcGlja2VyVG9nZ2xlQnV0dG9ufVwiIGRhdGEtdGUtdG9nZ2xlPVwidGltZXBpY2tlclwiIGRhdGEtdGUtdGltZXBpY2tlci10b2dnbGUtYnV0dG9uIGRhdGEtdGUtdGltZXBpY2tlci1pY29uPlxuICAgICR7aX1cbiAgPC9idXR0b24+XG5gO1xufSwganMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1kaXNhYmxlZFwiLCBpcyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZVwiLCBiZSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGUsIGksIG47XG4gIHJldHVybiBzYyhzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBuID0gdCwgZSA9IHMuZ2V0TWludXRlcygpLCB0ICU9IDEyLCBuID09PSAwICYmIHQgPT09IDAgJiYgKGkgPSBcIkFNXCIpLCB0ID0gdCB8fCAxMiwgaSA9PT0gdm9pZCAwICYmIChpID0gTnVtYmVyKG4pID49IDEyID8gXCJQTVwiIDogXCJBTVwiKSwgZSA9IGUgPCAxMCA/IGAwJHtlfWAgOiBlKSA6IChbdCwgZSwgaV0gPSBSKHMsICExKSwgbiA9IHQsIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpKSwge1xuICAgIGhvdXJzOiB0LFxuICAgIG1pbnV0ZXM6IGUsXG4gICAgYW1PclBtOiBpXG4gIH07XG59LCBzYyA9IChzKSA9PiBzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIU51bWJlci5pc05hTihzKSwgWHIgPSAocykgPT4ge1xuICBpZiAocyA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCB0LCBlO1xuICByZXR1cm4gc2MocykgPyAodCA9IHMuZ2V0SG91cnMoKSwgZSA9IHMuZ2V0TWludXRlcygpKSA6IFt0LCBlXSA9IFIocywgITEpLCBlID0gTnVtYmVyKGUpIDwgMTAgPyBgMCR7TnVtYmVyKGUpfWAgOiBlLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZVxuICB9O1xufSwgTGYgPSAocywgdCwgZSkgPT4gaC5vbihkb2N1bWVudCwgcywgdCwgKHsgdGFyZ2V0OiBpIH0pID0+IHtcbiAgaWYgKGkuaGFzQXR0cmlidXRlKGlzKSlcbiAgICByZXR1cm47XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCkuZm9yRWFjaCgobykgPT4ge1xuICAgIG8uaGFzQXR0cmlidXRlKGlzKSAmJiAoYy5yZW1vdmVDbGFzcyhvLCBlLm9wYWNpdHkpLCBvLnJlbW92ZUF0dHJpYnV0ZShpcykpO1xuICB9KSwgYy5hZGRDbGFzcyhpLCBlLm9wYWNpdHkpLCBpLnNldEF0dHJpYnV0ZShpcywgXCJcIik7XG59KSwgR3IgPSAoeyBjbGllbnRYOiBzLCBjbGllbnRZOiB0LCB0b3VjaGVzOiBlIH0sIGksIG4gPSAhMSkgPT4ge1xuICBjb25zdCB7IGxlZnQ6IG8sIHRvcDogciB9ID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IGEgPSB7fTtcbiAgcmV0dXJuICFuIHx8ICFlID8gYSA9IHtcbiAgICB4OiBzIC0gbyxcbiAgICB5OiB0IC0gclxuICB9IDogbiAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPiAwICYmIChhID0ge1xuICAgIHg6IGVbMF0uY2xpZW50WCAtIG8sXG4gICAgeTogZVswXS5jbGllbnRZIC0gclxuICB9KSwgYTtcbn0sIHNzID0gKCkgPT4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIgJiYgL01hY0ludGVsLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KFxuICBuYXZpZ2F0b3IudXNlckFnZW50XG4pLCBSID0gKHMsIHQgPSAhMCkgPT4gdCA/IHMudmFsdWUucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSA6IHMucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSwgbmMgPSAocywgdCkgPT4ge1xuICBjb25zdCBbZSwgaSwgbl0gPSBSKHMsICExKSwgW28sIHIsIGFdID0gUih0LCAhMSk7XG4gIHJldHVybiBuID09PSBcIlBNXCIgJiYgYSA9PT0gXCJBTVwiIHx8IG4gPT09IGEgJiYgZSA+IG8gfHwgaSA+IHI7XG59LCBvYyA9ICgpID0+IHtcbiAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCk7XG4gIHJldHVybiBgJHt0fToke2UgPCAxMCA/IGAwJHtlfWAgOiBlfWA7XG59LCBYdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSBvYygpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke2JlKGkpLmhvdXJzfToke2JlKGkpLm1pbnV0ZXN9ICR7YmUoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiBuYyhpLCBzKSB8fCBzID09PSBcIlwiKSAmJiAocyA9IGkpLCBzO1xufSwgR3QgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGxldCBpID0gb2MoKTtcbiAgcmV0dXJuIGUgJiYgKGkgPSBgJHtiZShpKS5ob3Vyc306JHtiZShpKS5taW51dGVzfSAke2JlKGkpLmFtT3JQbX1gKSwgKHMgIT09IFwiXCIgJiYgIW5jKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBNZiA9ICh7IGZvcm1hdDEyOiBzLCBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlLCBkaXNhYmxlUGFzdDogaSwgZGlzYWJsZUZ1dHVyZTogbiB9LCBvLCByKSA9PiB7XG4gIGNvbnN0IGEgPSBSKG8pWzFdO1xuICBlID0gWHQoZSwgaSwgcyksIHQgPSBHdCh0LCBuLCBzKTtcbiAgY29uc3QgW2wsIHAsIHVdID0gUih0LCAhMSksIFtmLCBfLCBtXSA9IFIoZSwgITEpO1xuICBpZiAodSAhPT0gdm9pZCAwIHx8IG0gIT09IHZvaWQgMClcbiAgICByZXR1cm4gW3IsIGFdO1xuICBpZiAoIShsICE9PSBcIlwiICYmIGYgPT09IFwiXCIgJiYgTnVtYmVyKHIpID4gTnVtYmVyKGwpKSAmJiAhKGwgPT09IFwiXCIgJiYgZiAhPT0gXCJcIiAmJiBwID09PSB2b2lkIDAgJiYgXyAhPT0gXCJcIiAmJiBOdW1iZXIocikgPCBOdW1iZXIoZikpKVxuICAgIHJldHVybiBbciwgYV07XG59LCBxciA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQgPSB0ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogdCwgKG4udGV4dENvbnRlbnQgPT09IFwiMDBcIiB8fCBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpID4gdCkgJiYgKGMuYWRkQ2xhc3MobiwgZS50aXBzRGlzYWJsZWQpLCBuLnNldEF0dHJpYnV0ZShqcywgXCJcIikpO1xuICB9KTtcbn0sIFpyID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCBuLnRleHRDb250ZW50ICE9PSBcIjAwXCIgJiYgTnVtYmVyKG4udGV4dENvbnRlbnQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiBuLnRleHRDb250ZW50KSA8IE51bWJlcih0KSAmJiAoYy5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKGpzLCBcIlwiKSk7XG4gIH0pO1xufSwgcmMgPSAocywgdCwgZSwgaSkgPT4ge1xuICBpZiAodCA9PT0gXCIxMlwiIHx8IHQgPT09IFwiMjRcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBlID8gMTIgOiAyNDtcbiAgcmV0dXJuIGkgPT09IFwibWF4XCIgPyAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPiBOdW1iZXIodCkgOiAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPCBOdW1iZXIodCk7XG59LCBOZiA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChyYyhpLCBlLCBvLCBcIm1heFwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPiB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAoYy5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKGpzLCBcIlwiKSk7XG4gIH0pO1xufSwgUmYgPSAocywgdCwgZSwgaSwgbiwgbykgPT4ge1xuICBzLmZvckVhY2goKHIpID0+IHtcbiAgICAocmMoaSwgZSwgbywgXCJtaW5cIikgfHwgTnVtYmVyKHIudGV4dENvbnRlbnQpIDwgdCAmJiBOdW1iZXIoaSkgPT09IE51bWJlcihlKSkgJiYgKGMuYWRkQ2xhc3Mociwgbi50aXBzRGlzYWJsZWQpLCByLnNldEF0dHJpYnV0ZShqcywgXCJcIikpO1xuICB9KTtcbn0sIFBmID0gKHMpID0+IHMuc3RhcnRzV2l0aChcIjBcIikgPyBOdW1iZXIocy5zbGljZSgxKSkgOiBOdW1iZXIocyksIHlpID0gXCJ0aW1lcGlja2VyXCIsIE4gPSBgZGF0YS10ZS0ke3lpfWAsIFFyID0gXCJbZGF0YS10ZS10b2dnbGVdXCIsIFNzID0gYHRlLiR7eWl9YCwgUnQgPSBgLiR7U3N9YCwgUHQgPSBcIi5kYXRhLWFwaVwiLCBKciA9IGBjbGljayR7UnR9JHtQdH1gLCBucyA9IGBrZXlkb3duJHtSdH0ke1B0fWAsIHRhID0gYG1vdXNlZG93biR7UnR9JHtQdH1gLCBlYSA9IGBtb3VzZXVwJHtSdH0ke1B0fWAsIGlhID0gYG1vdXNlbW92ZSR7UnR9JHtQdH1gLCBzYSA9IGBtb3VzZWxlYXZlJHtSdH0ke1B0fWAsIG5hID0gYG1vdXNlb3ZlciR7UnR9JHtQdH1gLCBvYSA9IGB0b3VjaG1vdmUke1J0fSR7UHR9YCwgcmEgPSBgdG91Y2hlbmQke1J0fSR7UHR9YCwgYWEgPSBgdG91Y2hzdGFydCR7UnR9JHtQdH1gLCBCZiA9IGBbJHtOfS1hbV1gLCBIZiA9IGBbJHtOfS1wbV1gLCBXZiA9IGBbJHtOfS1mb3JtYXQyNF1gLCBvcyA9IGBbJHtOfS1jdXJyZW50XWAsIHJzID0gYFske059LWhvdXItbW9kZV1gLCBWZiA9IGBbJHtOfS10b2dnbGUtYnV0dG9uXWAsIGtuID0gYCR7Tn0tY2FuY2VsYCwgbGEgPSBgJHtOfS1jbGVhcmAsIE9uID0gYCR7Tn0tc3VibWl0YCwgRmYgPSBgJHtOfS1pY29uYCwgU24gPSBgJHtOfS1pY29uLXVwYCwgSW4gPSBgJHtOfS1pY29uLWRvd25gLCBZZiA9IGAke059LWljb24taW5saW5lLWhvdXJgLCBqZiA9IGAke059LWljb24taW5saW5lLW1pbnV0ZWAsIGNhID0gYCR7Tn0taW5saW5lLWhvdXItaWNvbnNgLCBLZiA9IGAke059LWN1cnJlbnQtaW5saW5lYCwgemYgPSBcInJlYWRvbmx5XCIsIGhhID0gYCR7Tn0taW52YWxpZC1mZWVkYmFja2AsIERuID0gYCR7Tn0taXMtaW52YWxpZGAsIFl0ID0gYCR7Tn0tZGlzYWJsZWRgLCBIID0gYCR7Tn0tYWN0aXZlYCwgVWYgPSBgJHtOfS1pbnB1dGAsIHVlID0gYCR7Tn0tY2xvY2tgLCBhaSA9IGAke059LWNsb2NrLWlubmVyYCwgJG4gPSBgJHtOfS13cmFwcGVyYCwgZGEgPSBgJHtOfS1jbG9jay13cmFwcGVyYCwgYXMgPSBgJHtOfS1ob3VyYCwgTG4gPSBgJHtOfS1taW51dGVgLCBscyA9IGAke059LXRpcHMtZWxlbWVudGAsIEsgPSBgJHtOfS10aXBzLWhvdXJzYCwgWCA9IGAke059LXRpcHMtbWludXRlc2AsIGF0ID0gYCR7Tn0tdGlwcy1pbm5lcmAsIGNzID0gYCR7Tn0tdGlwcy1pbm5lci1lbGVtZW50YCwgdWEgPSBgJHtOfS1taWRkbGUtZG90YCwgTW4gPSBgJHtOfS1oYW5kLXBvaW50ZXJgLCBObiA9IGAke059LWNpcmNsZWAsIHBhID0gYCR7Tn0tbW9kYWxgLCBYZiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xMiA2djZoNC41bTQuNSAwYTkgOSAwIDExLTE4IDAgOSA5IDAgMDExOCAwelwiIC8+XG48L3N2Zz5gLCBHZiA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86ICEwLFxuICBib2R5SUQ6IFwiXCIsXG4gIGNhbmNlbExhYmVsOiBcIkNhbmNlbFwiLFxuICBjbGVhckxhYmVsOiBcIkNsZWFyXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6ICEwLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6ICExLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBkZWZhdWx0VGltZTogXCJcIixcbiAgZGlzYWJsZWQ6ICExLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBlbmFibGVWYWxpZGF0aW9uOiAhMCxcbiAgZm9jdXNJbnB1dEFmdGVyQXBwcm92ZTogITEsXG4gIGZvb3RlcklEOiBcIlwiLFxuICBmb3JtYXQxMjogITAsXG4gIGZvcm1hdDI0OiAhMSxcbiAgaGVhZElEOiBcIlwiLFxuICBpbmNyZW1lbnQ6ICExLFxuICBpbmxpbmU6ICExLFxuICBpbnZhbGlkTGFiZWw6IFwiSW52YWxpZCBUaW1lIEZvcm1hdFwiLFxuICBtYXhUaW1lOiBcIlwiLFxuICBtaW5UaW1lOiBcIlwiLFxuICBtb2RhbElEOiBcIlwiLFxuICBva0xhYmVsOiBcIk9rXCIsXG4gIG92ZXJmbG93SGlkZGVuOiAhMCxcbiAgcGlja2VySUQ6IFwiXCIsXG4gIHJlYWRPbmx5OiAhMSxcbiAgc2hvd0NsZWFyQnRuOiAhMCxcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiAhMCxcbiAgaWNvblNWRzogWGYsXG4gIHdpdGhJY29uOiAhMCxcbiAgcG1MYWJlbDogXCJQTVwiLFxuICBhbUxhYmVsOiBcIkFNXCIsXG4gIGFuaW1hdGlvbnM6ICEwXG59LCBxZiA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86IFwiYm9vbGVhblwiLFxuICBib2R5SUQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcInN0cmluZ1wiLFxuICBjbGVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiBcImJvb2xlYW5cIixcbiAgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBcImJvb2xlYW5cIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIGVuYWJsZVZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBmb290ZXJJRDogXCJzdHJpbmdcIixcbiAgZm9ybWF0MTI6IFwiYm9vbGVhblwiLFxuICBmb3JtYXQyNDogXCJib29sZWFuXCIsXG4gIGhlYWRJRDogXCJzdHJpbmdcIixcbiAgaW5jcmVtZW50OiBcImJvb2xlYW5cIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgaW52YWxpZExhYmVsOiBcInN0cmluZ1wiLFxuICBtb2RhbElEOiBcInN0cmluZ1wiLFxuICBva0xhYmVsOiBcInN0cmluZ1wiLFxuICBvdmVyZmxvd0hpZGRlbjogXCJib29sZWFuXCIsXG4gIHBpY2tlcklEOiBcInN0cmluZ1wiLFxuICByZWFkT25seTogXCJib29sZWFuXCIsXG4gIHNob3dDbGVhckJ0bjogXCJib29sZWFuXCIsXG4gIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRUaW1lOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIGljb25TVkc6IFwic3RyaW5nXCIsXG4gIHdpdGhJY29uOiBcImJvb2xlYW5cIixcbiAgcG1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uczogXCJib29sZWFuXCJcbn0sIFpmID0ge1xuICB0aXBzOiBcImFic29sdXRlIHJvdW5kZWQtWzEwMCVdIHctWzMycHhdIGgtWzMycHhdIHRleHQtY2VudGVyIGN1cnNvci1wb2ludGVyIHRleHQtWzEuMXJlbV0gcm91bmRlZC1bMTAwJV0gYmctdHJhbnNwYXJlbnQgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgZm9udC1saWdodCBmb2N1czpvdXRsaW5lLW5vbmUgc2VsZWN0aW9uOmJnLXRyYW5zcGFyZW50XCIsXG4gIHRpcHNBY3RpdmU6IFwidGV4dC13aGl0ZSBiZy1bIzNiNzFjYV0gZm9udC1ub3JtYWxcIixcbiAgdGlwc0Rpc2FibGVkOiBcInRleHQtWyNiM2FmYWZdIHBvaW50ZXItZXZlbnRzLW5vbmUgYmctdHJhbnNwYXJlbnRcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zaXRpb24tW3RyYW5zZm9ybSxoZWlnaHRdIGVhc2UtaW4tb3V0IGR1cmF0aW9uLVs0MDBtc11cIixcbiAgbW9kYWw6IFwiei1bMTA2NV1cIixcbiAgY2xvY2tBbmltYXRpb246IFwiYW5pbWF0ZS1bc2hvdy11cC1jbG9ja18zNTBtc19saW5lYXJdXCIsXG4gIG9wYWNpdHk6IFwiIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJXcmFwcGVyOiBcInRvdWNoLW5vbmUgb3BhY2l0eS0xMDAgei1bMTA2NV0gaW5zZXQtMCBiZy1bIzAwMDAwMDY2XSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgZml4ZWRcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLXctWzMxMHB4XSBtaW4taC1bMzI1cHhdIGJnLXdoaXRlIHJvdW5kZWQtdC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6b3ZlcmZsb3cteS1hdXRvIGp1c3RpZnktYXJvdW5kXCIsXG4gIHRpbWVwaWNrZXJIZWFkOiBcImJnLVsjM2I3MWNhXSBkYXJrOmJnLXppbmMtNzAwIGgtWzEwMHB4XSByb3VuZGVkLXQtbGcgcHItWzI0cHhdIHBsLVs1MHB4XSBweS1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtdHItbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cHItWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpoLWF1dG8gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVszMDVweF0gZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seVwiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwiW2RpcmVjdGlvbjpsdHJdIHJ0bDpbZGlyZWN0aW9uOnJ0bF1cIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbjogXCJ0ZXh0LVszLjc1cmVtXSBmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtNXhsIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIFwiLFxuICB0aW1lcGlja2VyRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC1bMy43NXJlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHRleHQtWzE4cHhdIHRleHQtWyNmZmZmZmY4YV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFqdXN0aWZ5LWFyb3VuZCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93XCIsXG4gIHRpbWVwaWNrZXJNb2RlQW06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJNb2RlUG06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJDbG9ja1dyYXBwZXI6IFwibWluLXctWzMxMHB4XSBtYXgtdy1bMzI1cHhdIG1pbi1oLVszMDVweF0gb3ZlcmZsb3cteC1oaWRkZW4gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgaXRlbXMtY2VudGVyIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInJlbGF0aXZlIHJvdW5kZWQtWzEwMCVdIHctWzI2MHB4XSBoLVsyNjBweF0gY3Vyc29yLWRlZmF1bHQgbXktMCBteC1hdXRvIGJnLVsjMDAwMDAwMTJdIGRhcms6YmctemluYy02MDAvNTBcIixcbiAgdGltZXBpY2tlck1pZGRsZURvdDogXCJ0b3AtMS8yIGxlZnQtMS8yIHctWzZweF0gaC1bNnB4XSAtdHJhbnNsYXRlLXktMS8yIC10cmFuc2xhdGUteC0xLzIgcm91bmRlZC1bNTAlXSBiZy1bIzNiNzFjYV0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlckhhbmRQb2ludGVyOiBcImJnLVsjM2I3MWNhXSBib3R0b20tMS8yIGgtMi81IGxlZnQtW2NhbGMoNTAlLTFweCldIHJ0bDohbGVmdC1hdXRvIG9yaWdpbi1bY2VudGVyX2JvdHRvbV8wXSBydGw6IW9yaWdpbi1bNTAlXzUwJV8wXSB3LVsycHhdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcIi10b3AtWzIxcHhdIC1sZWZ0LVsxNXB4XSB3LVs0cHhdIGJvcmRlci1bMTRweF0gYm9yZGVyLXNvbGlkIGJvcmRlci1bIzNiNzFjYV0gaC1bNHB4XSBib3gtY29udGVudCByb3VuZGVkLVsxMDAlXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJhYnNvbHV0ZSB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiB3LVsxNjBweF0gaC1bMTYwcHhdIHJvdW5kZWQtWzEwMCVdXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJXcmFwcGVyOiBcInJvdW5kZWQtYi1sZyBmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgdy1mdWxsIGgtWzU2cHhdIHB4LVsxMnB4XSBiZy13aGl0ZSBkYXJrOmJnLXppbmMtNTAwXCIsXG4gIHRpbWVwaWNrZXJGb290ZXI6IFwidy1mdWxsIGZsZXgganVzdGlmeS1iZXR3ZWVuXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwidGV4dC1bMC44cmVtXSBtaW4tdy1bNjRweF0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSByb3VuZGVkLVsxMHB4XSB0cmFja2luZy1bMC4xcmVtXSB1cHBlcmNhc2UgdGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsYm94LXNoYWRvdyxib3JkZXJdIGR1cmF0aW9uLVsyNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV0gZGVsYXktWzBtc10gb3V0bGluZS1ub25lIHB5LTAgcHgtWzEwcHhdIGgtWzQwcHhdIG1iLVsxMHB4XSBob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlcklubGluZVdyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCByb3VuZGVkLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDb250YWluZXI6IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgbWF4LWgtW2NhbGMoMTAwJS02NHB4KV0gb3ZlcmZsb3cteS1hdXRvIHNoYWRvdy1bMF8xMHB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLDAuMDcpLDBfNHB4XzZweF8tMnB4X3JnYmEoMCwwLDAsMC4wNSldXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVFbGVtZW50czogXCJmbGV4IGZsZXgtY29sIG1pbi1oLVthdXRvXSBtaW4tdy1bMzEwcHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvdyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLXctW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTo6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTAgcm91bmRlZC1iLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudDogXCJtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6ZmxleC1jb2wgZmxleCB3LWZ1bGwganVzdGlmeS1ldmVubHkgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGwgIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGxcIixcbiAgdGltZXBpY2tlcklubGluZUljb25VcDogXCJhYnNvbHV0ZSBmaWxsLXdoaXRlIC10b3AtWzM1cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnOiBcImgtNCB3LTRcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsICFvcGFjaXR5LTEwMCBjdXJzb3ItcG9pbnRlciBmb2N1czpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzIuNXJlbV0gaG92ZXI6YmctW3Vuc2V0XVwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvbkRvd246IFwiYWJzb2x1dGUgZmlsbC13aGl0ZSAtYm90dG9tLVs0N3B4XSBvcGFjaXR5LTAgaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtW2Vhc2VdIGN1cnNvci1wb2ludGVyIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBsZWZ0LTEvMiB3LVszMHB4XSBoLVszMHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIHRleHQtWzIuNXJlbV1cIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVBbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgbXItMiBtbC02XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlUG06IFwiaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b246IFwiaG92ZXI6YmctWyMwMDAwMDAxNF0gZm9jdXM6YmctWyMwMDAwMDAxNF0gZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzAuOHJlbV0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSB0cmFja2luZy1bLjFyZW1dIHVwcGVyY2FzZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zLGJveC1zaGFkb3dfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm9yZGVyXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zXSBvdXRsaW5lLW5vbmUgcm91bmRlZC1bMTAwJV0gaC1bNDhweF0gbWluLXctWzQ4cHhdIGlubGluZS1ibG9jayBtbC1bMzBweF0gdGV4dC13aGl0ZSBweS0xIHB4LTIgbWItMFwiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcImgtNCB3LTQgbWwtYXV0byBhYnNvbHV0ZSBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcmlnaHQtMS41IHRvcC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6dGV4dC1bIzNiNzFjYV0gZm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazpob3Zlcjp0ZXh0LVsjM2I3MWNhXSBkYXJrOmZvY3VzOnRleHQtWyMzYjcxY2FdIGRhcms6dGV4dC13aGl0ZVwiLFxuICBpbnZhbGlkRmVlZGJhY2s6IFwiYmxvY2sgYWJzb2x1dGUgdGV4dC1zbSB0ZXh0LXJlZC01MDAgZGFyazp0ZXh0LXJlZC0zMDBcIlxufSwgUWYgPSB7XG4gIHRpcHM6IFwic3RyaW5nXCIsXG4gIHRpcHNBY3RpdmU6IFwic3RyaW5nXCIsXG4gIHRpcHNEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgdHJhbnNmb3JtOiBcInN0cmluZ1wiLFxuICBtb2RhbDogXCJzdHJpbmdcIixcbiAgY2xvY2tBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIG9wYWNpdHk6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckRvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2s6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNaWRkbGVEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIYW5kUG9pbnRlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclBvaW50ZXJDaXJjbGU6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9ja0lubmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRm9vdGVyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlckJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVFbGVtZW50czogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uVXA6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Eb3duOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlQW06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlUG06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIGludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFkwIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgQXQodGhpcywgXCJfdG9nZ2xlQW1QbVwiLCAodCkgPT4ge1xuICAgICAgdCA9PT0gXCJQTVwiID8gKHRoaXMuX2lzUG1FbmFibGVkID0gITAsIHRoaXMuX2lzQW1FbmFibGVkID0gITEpIDogdCA9PT0gXCJBTVwiICYmICh0aGlzLl9pc1BtRW5hYmxlZCA9ICExLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICEwKTtcbiAgICB9KTtcbiAgICBBdCh0aGlzLCBcIl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGVcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yKGAke3R9WyR7SH1dYCkgIT09IG51bGwpIHtcbiAgICAgICAgYy5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQXQodGhpcywgXCJfdG9nZ2xlQ2xhc3NBY3RpdmVcIiwgKHQsIHsgdGV4dENvbnRlbnQ6IGUgfSwgaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IFsuLi50XS5maW5kKFxuICAgICAgICAobykgPT4gTnVtYmVyKG8pID09PSBOdW1iZXIoZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNBdHRyaWJ1dGUoWXQpKSB7XG4gICAgICAgICAgaWYgKG8udGV4dENvbnRlbnQgPT09IG4pIHtcbiAgICAgICAgICAgIGMuYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5zZXRBdHRyaWJ1dGUoSCwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGMucmVtb3ZlQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5yZW1vdmVBdHRyaWJ1dGUoSCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEF0KHRoaXMsIFwiX21ha2VNaW51dGVzRGVncmVlc1wiLCAodCwgZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbmNyZW1lbnQ6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICByZXR1cm4gdCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDYpICUgNjAsIHQgPSAzNjAgKyBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpIDogKGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAlIDYwLCB0ID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2KSwgaSAmJiAodCA9IE1hdGgucm91bmQodCAvIDMwKSAqIDMwLCBlID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2IC8gNiwgZSA9PT0gNjAgJiYgKGUgPSBcIjAwXCIpKSwgdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgICBkZWdyZWVzOiB0LFxuICAgICAgICBtaW51dGU6IGUsXG4gICAgICAgIGFkZERlZ3JlZXM6IGkgPyAzMCA6IDZcbiAgICAgIH07XG4gICAgfSk7XG4gICAgQXQodGhpcywgXCJfbWFrZUhvdXJEZWdyZWVzXCIsICh0LCBlLCBpKSA9PiB7XG4gICAgICBpZiAodClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMjQsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICsgMTIsIGkgPT09IDEyICYmIChpID0gXCIwMFwiKSkgOiBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMTIsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICUgMTIsIChpID09PSAwIHx8IGkgPiAxMikgJiYgKGkgPSAxMikpLCBlID49IDM2MCAmJiAoZSA9IDApLCB7XG4gICAgICAgICAgZGVncmVlczogZSxcbiAgICAgICAgICBob3VyOiBpLFxuICAgICAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgQXQodGhpcywgXCJfbWFrZUlubmVySG91cnNEZWdyZWVzXCIsICh0LCBlKSA9PiAodCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDMwKSAlIDI0LCB0ID0gMzYwICsgdCkgOiAoZSA9IE1hdGgucm91bmQodCAvIDMwKSArIDEyLCBlID09PSAxMiAmJiAoZSA9IFwiMDBcIikpLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgaG91cjogZSxcbiAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgfSkpO1xuICAgIEF0KHRoaXMsIFwiX2dldEFwcGVuZENsb2NrXCIsICh0ID0gW10sIGUgPSBgWyR7dWV9XWAsIGkpID0+IHtcbiAgICAgIGxldCB7IG1pblRpbWU6IG4sIG1heFRpbWU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBjb25zdCB7IGlubGluZTogciwgZm9ybWF0MTI6IGEsIGRpc2FibGVQYXN0OiBsLCBkaXNhYmxlRnV0dXJlOiBwIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbiA9IFh0KG4sIGwsIGEpLCBvID0gR3QobywgcCwgYSk7XG4gICAgICBjb25zdCBbdSwgZiwgX10gPSBSKFxuICAgICAgICBvLFxuICAgICAgICAhMVxuICAgICAgKSwgW20sIGcsIHZdID0gUihcbiAgICAgICAgbixcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICAhciAmJiBhICYmIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgJiYgIXRoaXMuX0FNLmhhc0F0dHJpYnV0ZShIKSAmJiAoYy5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKTtcbiAgICAgIGNvbnN0IGIgPSBkLmZpbmRPbmUoZSksIEMgPSAzNjAgLyB0Lmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIHkodykge1xuICAgICAgICByZXR1cm4gdyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChiID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBFID0gKGIub2Zmc2V0V2lkdGggLSAzMikgLyAyLCBUID0gKGIub2Zmc2V0SGVpZ2h0IC0gMzIpIC8gMiwgQSA9IEUgLSA0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCB3O1xuICAgICAgICBhICYmICh3ID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke3JzfVske0h9XWBcbiAgICAgICAgKS50ZXh0Q29udGVudCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgdixcbiAgICAgICAgICBnLFxuICAgICAgICAgIG1cbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBfLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgdVxuICAgICAgICApO1xuICAgICAgfSwgMCksIFsuLi50XS5mb3JFYWNoKCh3LCBTKSA9PiB7XG4gICAgICAgIGNvbnN0IGsgPSB5KFMgKiBDKSwgeCA9IEQoXCJzcGFuXCIpLCAkID0gRChcInNwYW5cIik7XG4gICAgICAgICQuaW5uZXJIVE1MID0gdywgYy5hZGRDbGFzcyh4LCB0aGlzLl9jbGFzc2VzLnRpcHMpLCB4LnNldEF0dHJpYnV0ZShpLCBcIlwiKTtcbiAgICAgICAgY29uc3QgTyA9IHgub2Zmc2V0V2lkdGgsIE0gPSB4Lm9mZnNldEhlaWdodDtcbiAgICAgICAgcmV0dXJuIGMuYWRkU3R5bGUoeCwge1xuICAgICAgICAgIGxlZnQ6IGAke0UgKyBNYXRoLnNpbihrKSAqIEEgLSBPfXB4YCxcbiAgICAgICAgICBib3R0b206IGAke1QgKyBNYXRoLmNvcyhrKSAqIEEgLSBNfXB4YFxuICAgICAgICB9KSwgdC5pbmNsdWRlcyhcIjA1XCIpICYmIHguc2V0QXR0cmlidXRlKFgsIFwiXCIpLCB0LmluY2x1ZGVzKFwiMTNcIikgPyAkLnNldEF0dHJpYnV0ZShjcywgXCJcIikgOiAkLnNldEF0dHJpYnV0ZShscywgXCJcIiksIHguYXBwZW5kQ2hpbGQoJCksIGIuYXBwZW5kQ2hpbGQoeCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZWxlbWVudCAmJiBJLnNldERhdGEodCwgU3MsIHRoaXMpLCB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fY3VycmVudFRpbWUgPSBudWxsLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IGJ0KFwidGltZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLmhvdXJzQXJyYXkgPSBbXG4gICAgICBcIjEyXCIsXG4gICAgICBcIjFcIixcbiAgICAgIFwiMlwiLFxuICAgICAgXCIzXCIsXG4gICAgICBcIjRcIixcbiAgICAgIFwiNVwiLFxuICAgICAgXCI2XCIsXG4gICAgICBcIjdcIixcbiAgICAgIFwiOFwiLFxuICAgICAgXCI5XCIsXG4gICAgICBcIjEwXCIsXG4gICAgICBcIjExXCJcbiAgICBdLCB0aGlzLmlubmVySG91cnMgPSBbXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjEzXCIsXG4gICAgICBcIjE0XCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjE2XCIsXG4gICAgICBcIjE3XCIsXG4gICAgICBcIjE4XCIsXG4gICAgICBcIjE5XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjIxXCIsXG4gICAgICBcIjIyXCIsXG4gICAgICBcIjIzXCJcbiAgICBdLCB0aGlzLm1pbnV0ZXNBcnJheSA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMDVcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjVcIixcbiAgICAgIFwiMzBcIixcbiAgICAgIFwiMzVcIixcbiAgICAgIFwiNDBcIixcbiAgICAgIFwiNDVcIixcbiAgICAgIFwiNTBcIixcbiAgICAgIFwiNTVcIlxuICAgIF0sIHRoaXMuaW5wdXQgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5kYXRhV2l0aEljb24gPSB0LmRhdGFzZXQud2l0aEljb24sIHRoaXMuZGF0YVRvZ2dsZSA9IHQuZGF0YXNldC50b2dnbGUsIHRoaXMuY3VzdG9tSWNvbiA9IGQuZmluZE9uZShcbiAgICAgIFZmLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX2NoZWNrVG9nZ2xlQnV0dG9uKCksIHRoaXMuaW5wdXRGb3JtYXRTaG93ID0gZC5maW5kT25lKFxuICAgICAgV2YsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5pbnB1dEZvcm1hdCA9IHRoaXMuaW5wdXRGb3JtYXRTaG93ID09PSBudWxsID8gXCJcIiA6IE9iamVjdC52YWx1ZXModGhpcy5pbnB1dEZvcm1hdFNob3cuZGF0YXNldClbMF0sIHRoaXMuZWxlbWVudFRvZ2dsZSA9IGQuZmluZE9uZShcbiAgICAgIFFyLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMudG9nZ2xlRWxlbWVudCA9IE9iamVjdC52YWx1ZXMoXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoUXIpLmRhdGFzZXRcbiAgICApWzBdLCB0aGlzLl9ob3VyID0gbnVsbCwgdGhpcy5fbWludXRlcyA9IG51bGwsIHRoaXMuX0FNID0gbnVsbCwgdGhpcy5fUE0gPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5fbW9kYWwgPSBudWxsLCB0aGlzLl9oYW5kID0gbnVsbCwgdGhpcy5fY2lyY2xlID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9pbnB1dFZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAhPT0gXCJcIiA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgOiB0aGlzLmlucHV0LnZhbHVlLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDEyID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gWHIodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLmZvcm1hdDEyICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gYmUodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLnJlYWRPbmx5ICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKHpmLCAhMCksIHRoaXMuaW5wdXRGb3JtYXQgPT09IFwidHJ1ZVwiICYmIHRoaXMuaW5wdXRGb3JtYXQgIT09IFwiXCIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA9ICEwLCB0aGlzLl9jdXJyZW50VGltZSA9IFhyKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fYW5pbWF0aW9ucyA9ICF3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25zLCB0aGlzLmluaXQoKSwgdGhpcy5faXNIb3VycyA9ICEwLCB0aGlzLl9pc01pbnV0ZXMgPSAhMSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExLCB0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9pc0lubmVyID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITEsIHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgIXRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlID0geyBkZWdyZWVzOiBudWxsIH0sIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBraSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB5aTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7IGZvcm1hdDEyOiB0LCBmb3JtYXQyNDogZSwgZW5hYmxlVmFsaWRhdGlvbjogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgbiwgbywgcjtcbiAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoVWYsIFwiXCIpLCB0aGlzLl9jdXJyZW50VGltZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB7IGhvdXJzOiBhLCBtaW51dGVzOiBsLCBhbU9yUG06IHAgfSA9IHRoaXMuX2N1cnJlbnRUaW1lO1xuICAgICAgbiA9IE51bWJlcihhKSA8IDEwID8gMCA6IFwiXCIsIG8gPSBgJHtufSR7TnVtYmVyKGEpfToke2x9YCwgciA9IHAsIHQgPyB0aGlzLmlucHV0LnZhbHVlID0gYCR7b30gJHtyfWAgOiBlICYmICh0aGlzLmlucHV0LnZhbHVlID0gYCR7b31gKTtcbiAgICB9IGVsc2VcbiAgICAgIG4gPSBcIlwiLCBvID0gXCJcIiwgciA9IFwiXCIsIHRoaXMuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLmlucHV0LnZhbHVlICE9PSBcIlwiICYmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShILCBcIlwiKSwgaC50cmlnZ2VyKHRoaXMuaW5wdXQsIFwiaW5wdXRcIikpLCAhKHRoaXMuX29wdGlvbnMgPT09IG51bGwgJiYgdGhpcy5fZWxlbWVudCA9PT0gbnVsbCkgJiYgKGkgJiYgdGhpcy5fZ2V0VmFsaWRhdGUoXCJrZXlkb3duIGNoYW5nZSBibHVyIGZvY3VzXCIpLCB0aGlzLl9oYW5kbGVPcGVuKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQgIT09IG51bGwgJiYgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFNzKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuaW5wdXQgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICAgIH0sIDM1MCksIGgub2ZmKFxuICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApLCBoLm9mZihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYFxuICAgICk7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICB9XG4gIC8vIHByaXZhdGVcbiAgX2NoZWNrVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuY3VzdG9tSWNvbiA9PT0gbnVsbCAmJiAodGhpcy5kYXRhV2l0aEljb24gIT09IHZvaWQgMCAmJiAodGhpcy5fb3B0aW9ucy53aXRoSWNvbiA9IG51bGwsIHRoaXMuZGF0YVdpdGhJY29uID09PSBcInRydWVcIiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpLCB0aGlzLl9vcHRpb25zLndpdGhJY29uICYmIHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbih0aGlzLl9vcHRpb25zKSk7XG4gIH1cbiAgX2FwcGVuZFRvZ2dsZUJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gJGYoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmlucHV0Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyZW5kXCIsIHQpO1xuICB9XG4gIF9nZXREb21FbGVtZW50cygpIHtcbiAgICB0aGlzLl9ob3VyID0gZC5maW5kT25lKGBbJHthc31dYCksIHRoaXMuX21pbnV0ZXMgPSBkLmZpbmRPbmUoYFske0xufV1gKSwgdGhpcy5fQU0gPSBkLmZpbmRPbmUoQmYpLCB0aGlzLl9QTSA9IGQuZmluZE9uZShIZiksIHRoaXMuX3dyYXBwZXIgPSBkLmZpbmRPbmUoYFskeyRufV1gKSwgdGhpcy5fbW9kYWwgPSBkLmZpbmRPbmUoYFske3BhfV1gKSwgdGhpcy5faGFuZCA9IGQuZmluZE9uZShgWyR7TW59XWApLCB0aGlzLl9jaXJjbGUgPSBkLmZpbmRPbmUoYFske05ufV1gKSwgdGhpcy5fY2xvY2sgPSBkLmZpbmRPbmUoYFske3VlfV1gKSwgdGhpcy5fY2xvY2tJbm5lciA9IGQuZmluZE9uZShcbiAgICAgIGBbJHthaX1dYFxuICAgICk7XG4gIH1cbiAgX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnModCwgZSwgaSwgbiwgbywgcikge1xuICAgIGlmICghZSAmJiAhaSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB7IGZvcm1hdDI0OiBhLCBmb3JtYXQxMjogbCwgZGlzYWJsZVBhc3Q6IHAsIGRpc2FibGVGdXR1cmU6IHUgfSA9IHRoaXMuX29wdGlvbnMsIHsgX2lzQW1FbmFibGVkOiBmLCBfaXNQbUVuYWJsZWQ6IF8gfSA9IHRoaXMsIG0gPSByLmtleUNvZGUsIGcgPSByLnRhcmdldC5oYXNBdHRyaWJ1dGUoYWkpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdCkgfHwgci50YXJnZXQuaGFzQXR0cmlidXRlKGNzKTtcbiAgICBpID0gWHQoaSwgcCwgbCksIGUgPSBHdChlLCB1LCBsKSwgdHlwZW9mIGUgIT0gXCJudW1iZXJcIiAmJiAoZSA9IFIoZSwgITEpWzBdKTtcbiAgICBjb25zdCB2ID0gZSAhPT0gXCJcIiA/IGUgKiAzMCA6IFwiXCIsIGIgPSBpICE9PSBcIlwiID8gaSAqIDMwIDogXCJcIjtcbiAgICB0IDwgMCAmJiAodCA9IDM2MCArIHQpLCB0ID0gdCA9PT0gMzYwID8gMCA6IHQ7XG4gICAgY29uc3QgQyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7bHN9XWBcbiAgICAgICksIGsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7Y3N9XWBcbiAgICAgICksIHggPSBQZih0aGlzLl9ob3VyLmlubmVyVGV4dCk7XG4gICAgICBsZXQgJCwgTywgTTtcbiAgICAgIHJldHVybiBtID09PSBydCA/IE8gPSAxIDogbSA9PT0geiAmJiAoTyA9IC0xKSwgeCA9PT0gMTIgJiYgbSA9PT0gcnQgPyBNID0gMSA6IHggPT09IDAgJiYgbSA9PT0gcnQgPyBNID0gMTMgOiB4ID09PSAwICYmIG0gPT09IHogPyBNID0gMjMgOiB4ID09PSAxMyAmJiBtID09PSB6ID8gTSA9IDAgOiB4ID09PSAxICYmIG0gPT09IHogPyBNID0gMTIgOiBNID0geCArIE8sIFMuZm9yRWFjaCgoUCkgPT4ge1xuICAgICAgICBOdW1iZXIoUC50ZXh0Q29udGVudCkgPT09IE0gJiYgKCQgPSBQKTtcbiAgICAgIH0pLCBrLmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSBNICYmICgkID0gUCk7XG4gICAgICB9KSwgISQucGFyZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoWXQpO1xuICAgIH0sIHkgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gaSAhPT0gXCJcIiAmJiBpID4gMTIgPyAoaSAtIDEyKSAqIDMwIDogXCJcIiwgayA9IGUgIT09IFwiXCIgJiYgZSA+IDEyID8gKGUgLSAxMikgKiAzMCA6IFwiXCI7XG4gICAgICBpZiAoIShTICYmIHQgPCBTIHx8IGsgJiYgdCA+IGsgfHwgZSAmJiBlIDwgMTIpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICBpZiAoYSAmJiByLnR5cGUgIT09IFwia2V5ZG93blwiICYmIGcpXG4gICAgICByZXR1cm4geSgpO1xuICAgIGlmIChyLnR5cGUgPT09IFwia2V5ZG93blwiKVxuICAgICAgcmV0dXJuIEMoKTtcbiAgICBjb25zdCBFID0gIW8gfHwgbyA9PT0gXCJQTVwiICYmIF8gfHwgaSAhPT0gXCJcIiAmJiBvID09PSBcIkFNXCIgJiYgZiwgVCA9ICFuIHx8IG4gPT09IFwiUE1cIiAmJiBfIHx8IGUgIT09IFwiXCIgJiYgbiA9PT0gXCJBTVwiICYmIGYsIEEgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gYiA9PT0gMzYwICYmIGwgPyAwIDogYjtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGlmIChvID09PSBcIlBNXCIgJiYgZiB8fCBFICYmIHQgPCBTKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFMgPSB2ID09PSAzNjAgJiYgbCA/IDAgOiB2O1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgaWYgKG4gPT09IFwiQU1cIiAmJiBfIHx8IFQgJiYgdCA+IFMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIHJldHVybiBBKCkgJiYgdygpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICBoLm9uKHRoaXMuX2RvY3VtZW50LCBucywgXCJcIiwgKHQpID0+IHtcbiAgICAgIGxldCBlLCBpLCBuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbmNyZW1lbnQ6IG8sXG4gICAgICAgIG1heFRpbWU6IHIsXG4gICAgICAgIG1pblRpbWU6IGEsXG4gICAgICAgIGZvcm1hdDEyOiBsLFxuICAgICAgICBkaXNhYmxlUGFzdDogcCxcbiAgICAgICAgZGlzYWJsZUZ1dHVyZTogdVxuICAgICAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBsZXQgZiA9IFIoYSwgITEpWzBdLCBfID0gUihyLCAhMSlbMF07XG4gICAgICBjb25zdCBtID0gUihhLCAhMSlbMl0sIGcgPSBSKHIsICExKVsyXTtcbiAgICAgIGYgPSBYdChmLCBwLCBsKSwgXyA9IEd0KF8sIHUsIGwpLCB0eXBlb2YgXyAhPSBcIm51bWJlclwiICYmIChfID0gUihfLCAhMSlbMF0pO1xuICAgICAgY29uc3QgdiA9IGQuZmluZE9uZShgWyR7WH1dYCkgPT09IG51bGwsIGIgPSBkLmZpbmRPbmUoYFske2F0fV1gKSAhPT0gbnVsbCwgQyA9IE51bWJlcih0aGlzLl9oYW5kLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9bXlxcZC1dL2csIFwiXCIpKSwgeSA9IGQuZmluZChcbiAgICAgICAgYFske1h9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBFID0gZC5maW5kKFxuICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICksIFQgPSBkLmZpbmQoXG4gICAgICAgIGBbJHthdH1dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICk7XG4gICAgICBsZXQgQSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh0LnRhcmdldCwgQywgZSkuaG91cjtcbiAgICAgIGNvbnN0IHsgZGVncmVlczogdywgYWRkRGVncmVlczogUyB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKFxuICAgICAgICB0LnRhcmdldCxcbiAgICAgICAgQyxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIGxldCB7IG1pbnV0ZTogaywgZGVncmVlczogeCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKEMsIGkpO1xuICAgICAgY29uc3QgJCA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhcbiAgICAgICAgQyxcbiAgICAgICAgaVxuICAgICAgKS5hZGREZWdyZWVzO1xuICAgICAgbGV0IHsgaG91cjogTyB9ID0gdGhpcy5fbWFrZUlubmVySG91cnNEZWdyZWVzKFxuICAgICAgICBDLFxuICAgICAgICBuXG4gICAgICApO1xuICAgICAgaWYgKHQua2V5Q29kZSA9PT0gTGkpIHtcbiAgICAgICAgY29uc3QgTSA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7a259XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgaC50cmlnZ2VyKE0sIFwiY2xpY2tcIik7XG4gICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgaWYgKGIgJiYgKHQua2V5Q29kZSA9PT0gQmUgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMSwgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIEEgPiAxMiA/IDEgOiBBXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgVCkpLCB0LmtleUNvZGUgPT09IFBlICYmICh0aGlzLl9pc0lubmVyID0gITAsIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIE8gPj0gMjQgfHwgTyA9PT0gXCIwMFwiID8gMCA6IE9cbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgIHRoaXMuX2hvdXIgLSAxLFxuICAgICAgICAgIEVcbiAgICAgICAgKSkpLCB0LmtleUNvZGUgPT09IHJ0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgdyArIDMwLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3cgKyBTfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoTyArPSAxLCBPID09PSAyNCA/IE8gPSAwIDogKE8gPT09IDI1IHx8IE8gPT09IFwiMDAxXCIpICYmIChPID0gMTMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKE8pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIFQpKSA6IChBICs9IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICBBID4gMTIgPyAxIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmtleUNvZGUgPT09IHopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICB3IC0gMzAsXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dyAtIFN9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/IChPIC09IDEsIE8gPT09IDEyID8gTyA9IDAgOiBPID09PSAtMSAmJiAoTyA9IDIzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShPKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSkgOiAoQSAtPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgQSA9PT0gMCA/IDEyIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5rZXlDb2RlID09PSBydCAmJiAoeCArPSAkLCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7eH1kZWcpYFxuICAgICAgICB9KSwgayArPSAxLCBvICYmIChrICs9IDQsIGsgPT09IFwiMDAxNFwiICYmIChrID0gNSkpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIGsgPiA1OSA/IDAgOiBrXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgeVxuICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKSksIHQua2V5Q29kZSA9PT0geiAmJiAoeCAtPSAkLCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7eH1kZWcpYFxuICAgICAgICB9KSwgbyA/IGsgLT0gNSA6IGsgLT0gMSwgayA9PT0gLTEgPyBrID0gNTkgOiBrID09PSAtNSAmJiAoayA9IDU1KSwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShrKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB5XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4odCwgLi4uZSkge1xuICAgIGlmICghdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdClcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0KSB7XG4gICAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChpLCB0KSwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChuLCB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsuLi5lXS5maWx0ZXIoKG4pID0+IChuID09PSBcIlBNXCIgPyAoYy5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKSA6IG4gPT09IFwiQU1cIiA/IChjLmFkZENsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpIDogKGMucmVtb3ZlQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGMucmVtb3ZlQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnJlbW92ZUF0dHJpYnV0ZShIKSwgdGhpcy5fUE0ucmVtb3ZlQXR0cmlidXRlKEgpKSwgbikpO1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCk7XG4gICAgICB9XG4gIH1cbiAgX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZSh0LCBlKSB7XG4gICAgY29uc3QgeyBpbmxpbmU6IGksIGZvcm1hdDEyOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgaSB8fCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZVooMGRlZylcIlxuICAgICAgfSksIG4gJiYgKGMuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gdCA+IDEyID8gdCAqIDMwIC0gMzYwIDogdCAqIDMwO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHQsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBlLCBpIHx8IChjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke299ZGVnKWBcbiAgICAgIH0pLCBjLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICB9KSwgKE51bWJlcih0KSA+IDEyIHx8IHQgPT09IFwiMDBcIikgJiYgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgKHQucHJldmVudERlZmF1bHQoKSwgaC50cmlnZ2VyKHRoaXMuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgb2Uub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpID0gYy5nZXREYXRhQXR0cmlidXRlKHRoaXMuaW5wdXQsIFwidG9nZ2xlXCIpICE9PSBudWxsID8gMjAwIDogMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYy5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfSksIHRoaXMuZWxlbWVudFRvZ2dsZS5ibHVyKCk7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCB7IG1vZGFsSUQ6IG8sIGlubGluZTogciwgZm9ybWF0MTI6IGEgfSA9IHRoaXMuX29wdGlvbnMsIFtsLCBwLCB1XSA9IG4sIGYgPSBEKFwiZGl2XCIpO1xuICAgICAgICAgIGlmICgoTnVtYmVyKGwpID4gMTIgfHwgbCA9PT0gXCIwMFwiKSAmJiAodGhpcy5faXNJbm5lciA9ICEwKSwgdGhpcy5pbnB1dC5ibHVyKCksIGUudGFyZ2V0LmJsdXIoKSwgZi5pbm5lckhUTUwgPSBEZih0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKSwgYy5hZGRDbGFzcyhmLCB0aGlzLl9jbGFzc2VzLm1vZGFsKSwgZi5zZXRBdHRyaWJ1dGUocGEsIFwiXCIpLCBmLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIGYuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKSwgZi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgciA/ICh0aGlzLl9wb3BwZXIgPSBFZSh0aGlzLmlucHV0LCBmLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICAgICAgICB9KSwgdC5hcHBlbmRDaGlsZChmKSkgOiAodC5hcHBlbmRDaGlsZChmKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSksIHRoaXMuX2dldERvbUVsZW1lbnRzKCksIHRoaXMuX2FuaW1hdGlvbnMgPyB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbigpIDogYy5hZGRDbGFzcyh0aGlzLl93cmFwcGVyLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBwLCB1KSwgdGhpcy5fYXBwZW5kVGltZXMoKSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obCwgcCwgdSksIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShsLCBwKSwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgXyA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYSAmJiAoYy5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChcbiAgICAgICAgICAgICAgXyxcbiAgICAgICAgICAgICAgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faGFuZGxlU3dpdGNoVGltZU1vZGUoKSwgdGhpcy5faGFuZGxlT2tCdXR0b24oKSwgdGhpcy5faGFuZGxlQ2xvc2UoKSwgcilcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUhvdmVySW5saW5lQnRuKCksIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSwgdGhpcy5faGFuZGxlSW5saW5lQ2xpY2tzKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVTd2l0Y2hIb3VyTWludXRlKCksIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2soKSwgdGhpcy5faGFuZGxlS2V5Ym9hcmQoKTtcbiAgICAgICAgICAgIGNvbnN0IF8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICBgJHtvc31bJHtIfV1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYy5hZGRDbGFzcyhfLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBjLmFkZFN0eWxlKHRoaXMuX2hvdXIsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICAgIH0pLCBjLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyAkaSh0aGlzLl93cmFwcGVyLCB7XG4gICAgICAgICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICAgICAgICBjb25kaXRpb246ICh7IGtleTogXyB9KSA9PiBfID09PSBcIlRhYlwiXG4gICAgICAgICAgfSksIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIH0sIGkpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUlubGluZUNsaWNrcygpIHtcbiAgICBsZXQgdCwgZTtcbiAgICBjb25zdCBpID0gKF8pID0+IHtcbiAgICAgIGxldCBtID0gXztcbiAgICAgIHJldHVybiBtID4gNTkgPyBtID0gMCA6IG0gPCAwICYmIChtID0gNTkpLCBtO1xuICAgIH0sIG4gPSAoXykgPT4ge1xuICAgICAgbGV0IG0gPSBfO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPyAobSA+IDI0ID8gbSA9IDEgOiBtIDwgMCAmJiAobSA9IDIzKSwgbSA+IDIzICYmIChtID0gMCkpIDogKG0gPiAxMiA/IG0gPSAxIDogbSA8IDEgJiYgKG0gPSAxMiksIG0gPiAxMiAmJiAobSA9IDEpKSwgbTtcbiAgICB9LCBvID0gKF8pID0+IHtcbiAgICAgIGNvbnN0IG0gPSBuKF8pO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCByID0gKF8pID0+IHtcbiAgICAgIGNvbnN0IG0gPSBpKF8pO1xuICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCBhID0gKCkgPT4ge1xuICAgICAgdCArPSAxLCBvKHQpO1xuICAgIH0sIGwgPSAoKSA9PiB7XG4gICAgICBlICs9IDEsIHIoZSk7XG4gICAgfSwgcCA9ICgpID0+IHtcbiAgICAgIHQgLT0gMSwgbyh0KTtcbiAgICB9LCB1ID0gKCkgPT4ge1xuICAgICAgZSAtPSAxLCByKGUpO1xuICAgIH0sIGYgPSAoXykgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXywgMTAwKTtcbiAgICB9O1xuICAgIG9lLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrIG1vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgY29udGV4dG1lbnVcIixcbiAgICAgIGBbJHtTbn1dLCBbJHtJbn1dYCxcbiAgICAgIChfKSA9PiB7XG4gICAgICAgIHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBtLCB0eXBlOiBnIH0gPSBfLCB2ID0gZyA9PT0gXCJtb3VzZWRvd25cIiB8fCBnID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgbS5jbG9zZXN0KGBbJHtTbn1dYCkgPyBtLmNsb3Nlc3QoYFske1NufV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShjYSkgPyB2ID8gZihhKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiB8fCBnID09PSBcImNvbnRleHRtZW51XCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IGEoKSA6IHYgPyBmKGwpIDogZyA9PT0gXCJtb3VzZXVwXCIgfHwgZyA9PT0gXCJ0b3VjaGVuZFwiIHx8IGcgPT09IFwiY29udGV4dG1lbnVcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogbCgpIDogbS5jbG9zZXN0KGBbJHtJbn1dYCkgJiYgKG0uY2xvc2VzdChgWyR7SW59XWApLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKGNhKSA/IHYgPyBmKHApIDogZyA9PT0gXCJtb3VzZXVwXCIgfHwgZyA9PT0gXCJ0b3VjaGVuZFwiID8gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCkgOiBwKCkgOiB2ID8gZih1KSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogdSgpKTtcbiAgICAgIH1cbiAgICApLCBoLm9uKHdpbmRvdywgbnMsIChfKSA9PiB7XG4gICAgICBjb25zdCBtID0gXy5jb2RlLCBnID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoYXMpLCB2ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIExuXG4gICAgICApLCBiID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keTtcbiAgICAgIHN3aXRjaCAodCA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgZSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgIF8ucHJldmVudERlZmF1bHQoKSwgYiB8fCBnID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgYSgpKSA6IHYgJiYgbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgXy5wcmV2ZW50RGVmYXVsdCgpLCBiIHx8IGcgPyAodGhpcy5faG91ci5mb2N1cygpLCBwKCkpIDogdiAmJiB1KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHskbn1dLCBbJHtrbn1dLCBbJHtsYX1dYCxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogZSB9ID0gdGhpcy5fb3B0aW9ucywgaSA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBjLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgICB9KSwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIChuID0gdGhpcy5fZm9jdXNUcmFwKSA9PSBudWxsIHx8IG4uZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLmVsZW1lbnRUb2dnbGUgPyB0aGlzLmVsZW1lbnRUb2dnbGUuZm9jdXMoKSA6IHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodC5oYXNBdHRyaWJ1dGUobGEpKSB7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlQW1QbShcIlBNXCIpLCB0aGlzLmlucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoSCk7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCBbbywgciwgYV0gPSBuO1xuICAgICAgICAgIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShcIjEyXCIsIFwiMDBcIiksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKG8sIHIsIGEpLCB0aGlzLl9ob3VyLmNsaWNrKCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICh0Lmhhc0F0dHJpYnV0ZShrbikgfHwgdC5oYXNBdHRyaWJ1dGUoT24pIHx8IHQuaGFzQXR0cmlidXRlKCRuKSAmJiBlKSAmJiBpKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzaG93VmFsdWVJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTtcbiAgfVxuICBfaGFuZGxlT2tCdXR0b24oKSB7XG4gICAgb2Uub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHtPbn1dYCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdDEyOiBpLFxuICAgICAgICAgIGZvcm1hdDI0OiBuLFxuICAgICAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgICAgIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6IHIsXG4gICAgICAgICAgZGlzYWJsZVBhc3Q6IGEsXG4gICAgICAgICAgZGlzYWJsZUZ1dHVyZTogbFxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucywgcCA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYCR7cnN9WyR7SH1dYFxuICAgICAgICApLCB1ID0gYCR7dGhpcy5faG91ci50ZXh0Q29udGVudH06JHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50fWAsIGYgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIF8gPSBmID09PSAxMiAmJiBpID8gMCA6IGYsIG0gPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGUgPSBYdChlLCBhLCBpKSwgdCA9IEd0KHQsIGwsIGkpO1xuICAgICAgICBsZXQgW2csIHYsIGJdID0gUihcbiAgICAgICAgICB0LFxuICAgICAgICAgICExXG4gICAgICAgICksIFtDLCB5LCBFXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgICBDID0gQyA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBDLCBnID0gZyA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBnO1xuICAgICAgICBjb25zdCBUID0gXyA8IE51bWJlcihDKSwgQSA9IF8gPiBOdW1iZXIoZyk7XG4gICAgICAgIGxldCB3ID0gITA7XG4gICAgICAgIHAgJiYgKHcgPSBiID09PSBwLnRleHRDb250ZW50KTtcbiAgICAgICAgbGV0IFMgPSAhMDtcbiAgICAgICAgcCAmJiAoUyA9IEUgPT09IHAudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCBrID0gbSA+IHYgJiYgXyA9PT0gTnVtYmVyKGcpLCB4ID0gbSA8IHkgJiYgXyA9PT0gTnVtYmVyKEMpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSCwgXCJcIiksIGMuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAodyAmJiAoQSB8fCBrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoYiA9PT0gXCJBTVwiICYmIHAudGV4dENvbnRlbnQgPT09IFwiUE1cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlICE9PSBcIlwiICYmIChTICYmIChUIHx8IHgpIHx8IEUgPT09IFwiUE1cIiAmJiBwLnRleHRDb250ZW50ID09PSBcIkFNXCIpIHx8IE1mKFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50XG4gICAgICAgICkgIT09IHZvaWQgMCAmJiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShEbiksICFvICYmIHIgJiYgdGhpcy5pbnB1dC5mb2N1cygpLCBjLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCBuID8gdGhpcy5pbnB1dC52YWx1ZSA9IHUgOiBwID09PSBudWxsID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke3V9IFBNYCA6IHRoaXMuaW5wdXQudmFsdWUgPSBgJHt1fSAke3AudGV4dENvbnRlbnR9YCwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIGgudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiksIGgudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVIb3ZlcklubGluZUJ0bigpIHtcbiAgICBvZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJtb3VzZW92ZXIgbW91c2VsZWF2ZVwiLFxuICAgICAgYFske0tmfV1gLFxuICAgICAgKHsgdHlwZTogdCwgdGFyZ2V0OiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WWZ9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7amZ9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IChsLCBwKSA9PiBsLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgYy5hZGRDbGFzcyh1LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB1LnNldEF0dHJpYnV0ZShILCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYy5yZW1vdmVDbGFzcyh1LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB1LnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgfSksIGEgPSBlLmhhc0F0dHJpYnV0ZShhcykgPyBpIDogbjtcbiAgICAgICAgbyhhLCB0ID09PSBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEb2N1bWVudENsaWNrSW5saW5lKCkge1xuICAgIGgub24oZG9jdW1lbnQsIEpyLCAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsICYmICF0aGlzLl9tb2RhbC5jb250YWlucyh0KSAmJiAhdC5oYXNBdHRyaWJ1dGUoRmYpKSB7XG4gICAgICAgIGlmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgYy5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgIXRoaXMuX2FuaW1hdGlvbnMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSB7XG4gICAgTGYoXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBvcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBvcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucywgZSA9IGQuZmluZChcbiAgICAgICAgICBvcyxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IGQuZmluZChcbiAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgciA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgYSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbCA9IChwLCB1KSA9PiB7XG4gICAgICAgICAgbi5mb3JFYWNoKChfKSA9PiBfLnJlbW92ZSgpKSwgaS5mb3JFYWNoKChfKSA9PiBfLnJlbW92ZSgpKSwgYy5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYy5yZW1vdmVDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgfSwgNDAxKSwgdGhpcy5fZ2V0QXBwZW5kQ2xvY2socCwgYFske3VlfV1gLCB1KTtcbiAgICAgICAgICBjb25zdCBmID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgXyA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApLCBtID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKF8sIHIpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKG0sIGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBfID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoXywgciksIGYoKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBwLmhhc0F0dHJpYnV0ZShIKSAmJiAocC5oYXNBdHRyaWJ1dGUoTG4pID8gKGMuYWRkQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pLCBjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50ICogNn1kZWcpYCxcbiAgICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICAgIH0pLCB0ICYmIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKHUpID0+IHUucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgICBYXG4gICAgICAgICAgKSwgdGhpcy5faG91ci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIiwgdGhpcy5fbWludXRlcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpIDogcC5oYXNBdHRyaWJ1dGUoYXMpICYmIChjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzB9ZGVnKWBcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgPyAoYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5faG91ci50ZXh0Q29udGVudCAqIDMwIC0gMzYwfWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgJiYgYy5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pKSA6IGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgICAgICB0aGlzLmlubmVySG91cnMsXG4gICAgICAgICAgICBgWyR7YWl9XWAsXG4gICAgICAgICAgICBhdFxuICAgICAgICAgICksIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKHUpID0+IHUucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgICAgS1xuICAgICAgICAgICksIGMuYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgYy5hZGRTdHlsZSh0aGlzLl9taW51dGVzLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5tYXhUaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGQuZmluZChcbiAgICAgIGBbJHtLfV1gXG4gICAgKSwgciA9IGQuZmluZChcbiAgICAgIGBbJHthdH1dYFxuICAgICksIGEgPSBkLmZpbmQoXG4gICAgICBgWyR7WH1dYFxuICAgICk7XG4gICAgaWYgKCFlIHx8IGUgPT09IHQpIHtcbiAgICAgIHFyKFxuICAgICAgICByLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBxcihcbiAgICAgICAgbyxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKSwgTmYoXG4gICAgICAgIGEsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPT09IFwiQU1cIiAmJiB0ID09PSBcIlBNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBjLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5taW5UaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBkLmZpbmQoXG4gICAgICBgWyR7S31dYFxuICAgICksIHIgPSBkLmZpbmQoXG4gICAgICBgWyR7YXR9XWBcbiAgICApLCBhID0gZC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApO1xuICAgICFlIHx8IGUgPT09IHQgPyAoWnIoXG4gICAgICBvLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgWnIoXG4gICAgICByLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgUmYoXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50LFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApKSA6IGUgPT09IFwiUE1cIiAmJiB0ID09PSBcIkFNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBjLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoVGltZU1vZGUoKSB7XG4gICAgaC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgcnMsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXhUaW1lOiBlLCBtaW5UaW1lOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBuLCBkaXNhYmxlRnV0dXJlOiBvLCBmb3JtYXQxMjogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgaSA9IFh0KGksIG4sIHIpLCBlID0gR3QoZSwgbywgcik7XG4gICAgICAgIGNvbnN0IFthLCBsLCBwXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBbdSwgZiwgX10gPSBSKFxuICAgICAgICAgIGksXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgbSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7S31dYFxuICAgICAgICApLCBnID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICk7XG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgbS5mb3JFYWNoKChiKSA9PiB7XG4gICAgICAgICAgICBjLnJlbW92ZUNsYXNzKGIsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgYi5yZW1vdmVBdHRyaWJ1dGUoWXQpO1xuICAgICAgICAgIH0pLCBnLmZvckVhY2goKGIpID0+IHtcbiAgICAgICAgICAgIGMucmVtb3ZlQ2xhc3MoYiwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBiLnJlbW92ZUF0dHJpYnV0ZShZdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIHQudGV4dENvbnRlbnQsXG4gICAgICAgICAgXyxcbiAgICAgICAgICBmLFxuICAgICAgICAgIHVcbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYVxuICAgICAgICApLCB0aGlzLl90b2dnbGVBbVBtKHQudGV4dENvbnRlbnQpLCB0Lmhhc0F0dHJpYnV0ZShIKSB8fCAoZC5maW5kKFxuICAgICAgICAgIHJzXG4gICAgICAgICkuZm9yRWFjaCgoQykgPT4ge1xuICAgICAgICAgIEMuaGFzQXR0cmlidXRlKEgpICYmIChjLnJlbW92ZUNsYXNzKEMsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIEMucmVtb3ZlQXR0cmlidXRlKEgpKTtcbiAgICAgICAgfSksIGMuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdC5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUNsb2NrQ2xpY2soKSB7XG4gICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuLCBmb3JtYXQxMjogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlID0gWHQoZSwgaSwgbyksIHQgPSBHdCh0LCBuLCBvKTtcbiAgICBjb25zdCByID0gUih0LCAhMSlbMl0sIGEgPSBSKGUsICExKVsyXSwgbCA9IFIodCwgITEpWzBdLCBwID0gUihlLCAhMSlbMF0sIHUgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7ZGF9XWBcbiAgICApO1xuICAgIG9lLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBgJHt0YX0gJHtlYX0gJHtpYX0gJHtzYX0gJHtuYX0gJHthYX0gJHtvYX0gJHtyYX1gLFxuICAgICAgXCJcIixcbiAgICAgIChmKSA9PiB7XG4gICAgICAgIHNzKCkgfHwgZi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCB7IHR5cGU6IF8sIHRhcmdldDogbSB9ID0gZiwgeyBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IGcsIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogdiB9ID0gdGhpcy5fb3B0aW9ucywgYiA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBDID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIHkgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIEUgPSBkLmZpbmQoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgVCA9IEdyKGYsIHUpLCBBID0gdS5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGxldCB3ID0gTWF0aC5hdGFuMihULnkgLSBBLCBULnggLSBBKTtcbiAgICAgICAgaWYgKHNzKCkpIHtcbiAgICAgICAgICBjb25zdCAkID0gR3IoZiwgdSwgITApO1xuICAgICAgICAgIHcgPSBNYXRoLmF0YW4yKCQueSAtIEEsICQueCAtIEEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBTID0gbnVsbCwgayA9IG51bGwsIHggPSBudWxsO1xuICAgICAgICBpZiAoXyA9PT0gXCJtb3VzZWRvd25cIiB8fCBfID09PSBcIm1vdXNlbW92ZVwiIHx8IF8gPT09IFwidG91Y2htb3ZlXCIgfHwgXyA9PT0gXCJ0b3VjaHN0YXJ0XCIpXG4gICAgICAgICAgKF8gPT09IFwibW91c2Vkb3duXCIgfHwgXyA9PT0gXCJ0b3VjaHN0YXJ0XCIgfHwgXyA9PT0gXCJ0b3VjaG1vdmVcIikgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3MobSkgfHwgbS5oYXNBdHRyaWJ1dGUoZGEpIHx8IG0uaGFzQXR0cmlidXRlKHVlKSB8fCBtLmhhc0F0dHJpYnV0ZShYKSB8fCBtLmhhc0F0dHJpYnV0ZShLKSB8fCBtLmhhc0F0dHJpYnV0ZShObikgfHwgbS5oYXNBdHRyaWJ1dGUoTW4pIHx8IG0uaGFzQXR0cmlidXRlKHVhKSB8fCBtLmhhc0F0dHJpYnV0ZShscykpICYmICh0aGlzLl9pc01vdXNlTW92ZSA9ICEwLCBzcygpICYmIGYudG91Y2hlcyAmJiAoUyA9IGYudG91Y2hlc1swXS5jbGllbnRYLCBrID0gZi50b3VjaGVzWzBdLmNsaWVudFksIHggPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KFMsIGspKSk7XG4gICAgICAgIGVsc2UgaWYgKF8gPT09IFwibW91c2V1cFwiIHx8IF8gPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgICAgIGlmICh0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKG0pIHx8IG0uaGFzQXR0cmlidXRlKHVlKSB8fCBtLmhhc0F0dHJpYnV0ZShLKSB8fCBtLmhhc0F0dHJpYnV0ZShObikgfHwgbS5oYXNBdHRyaWJ1dGUoTW4pIHx8IG0uaGFzQXR0cmlidXRlKHVhKSB8fCBtLmhhc0F0dHJpYnV0ZShscykpIHtcbiAgICAgICAgICAgIGlmICgoQyB8fCB5KSAmJiB2KSB7XG4gICAgICAgICAgICAgIGNvbnN0ICQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiBsIHx8IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA8IHA7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIGwgIT09IFwiXCIgJiYgcCAhPT0gXCJcIiAmJiAkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgcCAhPT0gXCJcIiAmJiBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGgudHJpZ2dlcih0aGlzLl9taW51dGVzLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYiAmJiBnKSB7XG4gICAgICAgICAgICBjb25zdCAkID0gZC5maW5kT25lKFxuICAgICAgICAgICAgICBgWyR7T259XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaC50cmlnZ2VyKCQsIFwiY2xpY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgbGV0ICQ7XG4gICAgICAgICAgY29uc3QgTyA9IE1hdGgudHJ1bmModyAqIDE4MCAvIE1hdGguUEkpICsgOTAsIHsgZGVncmVlczogTSwgbWludXRlOiBQIH0gPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoTywgJCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucyhNLCBQKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogdHQsIG1pbnV0ZTogZXQgfSA9IHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucyhNLCBQKTtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChjLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3R0fWRlZylgXG4gICAgICAgICAgICB9KSwgZXQgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgVSA9ICgpID0+IGV0ID49IDEwIHx8IGV0ID09PSBcIjAwXCIgPyBldCA6IGAwJHtldH1gO1xuICAgICAgICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFUoKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgICAgICBFXG4gICAgICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICAgICApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNNaW51dGVzID0gdHQsIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UubWludXRlcyA9IGV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQyB8fCB5KSB7XG4gICAgICAgICAgbGV0ICQsIE8gPSBNYXRoLnRydW5jKHcgKiAxODAgLyBNYXRoLlBJKSArIDkwO1xuICAgICAgICAgIGlmIChPID0gTWF0aC5yb3VuZChPIC8gMzApICogMzAsIGMuYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgICAgfSksIHRoaXMuX21ha2VIb3VyRGVncmVlcyhtLCBPLCAkKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IE0gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3MoKSAmJiBPICYmIHgpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiB0dCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKHgsIE8sICQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQoXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB0dCxcbiAgICAgICAgICAgICAgICBQXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IFAsIGhvdXI6IHR0IH0gPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXMobSwgTywgJCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNb3ZlSGFuZChtLCB0dCwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNIb3VycyA9IE8sIHRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBPLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGZcbiAgICAgICAgICApICYmIE0oKTtcbiAgICAgICAgfVxuICAgICAgICBmLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhc1RhcmdldElubmVyQ2xhc3ModCkge1xuICAgIHJldHVybiB0Lmhhc0F0dHJpYnV0ZShhaSkgfHwgdC5oYXNBdHRyaWJ1dGUoYXQpIHx8IHQuaGFzQXR0cmlidXRlKGNzKTtcbiAgfVxuICBfaGFuZGxlTW92ZUhhbmQodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBkLmZpbmQoXG4gICAgICBgWyR7S31dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKSwgbyA9IGQuZmluZChcbiAgICAgIGBbJHthdH1dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKTtcbiAgICB0aGlzLl9pc01vdXNlTW92ZSAmJiAodGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICB9KSA6IGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgfSksIGMuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2l9ZGVnKWBcbiAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWAsIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgbiksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgbyksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UuaG91ciA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnModCwgZSkge1xuICAgIGxldCB7IG1heFRpbWU6IGksIG1pblRpbWU6IG4gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgeyBmb3JtYXQxMjogbywgaW5jcmVtZW50OiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBuID0gWHQobiwgYSwgbyksIGkgPSBHdChpLCBsLCBvKTtcbiAgICBjb25zdCBwID0gUihpLCAhMSlbMV0sIHUgPSBSKG4sICExKVsxXSwgZiA9IFIoaSwgITEpWzBdLCBfID0gUihuLCAhMSlbMF0sIG0gPSBfID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogXywgZyA9IGYgPT09IFwiMTJcIiAmJiBvID8gXCIwXCIgOiBmLCB2ID0gUihpLCAhMSlbMl0sIGIgPSBSKG4sICExKVsyXSwgQyA9IHAgIT09IFwiXCIgPyBwICogNiA6IFwiXCIsIHkgPSB1ICE9PSBcIlwiID8gdSAqIDYgOiBcIlwiLCBFID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBUID0gRSA9PT0gMTIgJiYgbyA/IDAgOiBFO1xuICAgIGlmICghdiAmJiAhYikge1xuICAgICAgaWYgKGkgIT09IFwiXCIgJiYgbiAhPT0gXCJcIikge1xuICAgICAgICBpZiAoTnVtYmVyKGcpID09PSBUICYmIHQgPiBDIHx8IE51bWJlcihtKSA9PT0gVCAmJiB0IDwgeSlcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAobiAhPT0gXCJcIiAmJiBUIDw9IE51bWJlcihtKSkge1xuICAgICAgICBpZiAodCA8PSB5IC0gNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gXCJcIiAmJiBUID49IE51bWJlcihnKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKGIgPT09IFwiUE1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChiID09PSBcIlBNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoVCA8IE51bWJlcihtKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoVCA8PSBOdW1iZXIobSkgJiYgdCA8PSB5IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IFwiQU1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChUIDwgTnVtYmVyKG0pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChUIDw9IE51bWJlcihtKSAmJiB0IDw9IHkgLSA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpICE9PSBcIlwiKSB7XG4gICAgICAgIGlmICh2ID09PSBcIkFNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKFQgPj0gTnVtYmVyKGcpICYmIHQgPj0gQyArIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQgJiYgVCA+PSBOdW1iZXIoZykgJiYgdCA+PSBDICsgNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHIgJiYgKHQgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKiAzMCksIHQgPCAwID8gdCA9IDM2MCArIHQgOiB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgbWludXRlOiBlXG4gICAgfTtcbiAgfVxuICBfcmVtb3ZlTW9kYWwoKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9ucyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlTW9kYWxFbGVtZW50cygpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9LCAzMDApIDogKHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpLCBvZS5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIGAke0pyfSAke25zfSAke3RhfSAke2VhfSAke2lhfSAke3NhfSAke25hfSAke2FhfSAke29hfSAke3JhfWBcbiAgICApLCBoLm9mZih3aW5kb3csIG5zKTtcbiAgfVxuICBfcmVtb3ZlTW9kYWxFbGVtZW50cygpIHtcbiAgICB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcbiAgfVxuICBfdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24odCA9ICExKSB7XG4gICAgdCA/IHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSA6ICh0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgYy5hZGRDbGFzcyh0aGlzLl9jbG9jaywgdGhpcy5fY2xhc3Nlcy5jbG9ja0FuaW1hdGlvbikpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIixcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiXG4gICAgICApO1xuICAgIH0sIDM1MSk7XG4gIH1cbiAgX2FkZEFjdGl2ZUNsYXNzVG9UaXAodCwgZSkge1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgTnVtYmVyKGkudGV4dENvbnRlbnQpID09PSBOdW1iZXIoZSkgJiYgKGMuYWRkQ2xhc3MoaSwgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgaS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIb3VyT3JNaW51dGUodCkge1xuICAgIHJldHVybiB0IDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfYXBwZW5kVGltZXMoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodCkge1xuICAgICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgYFske3VlfV1gLFxuICAgICAgICBLXG4gICAgICApLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICBgWyR7YWl9XWAsXG4gICAgICAgIGF0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgIGBbJHt1ZX1dYCxcbiAgICAgIEtcbiAgICApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uR2YsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoeWksIHQsIHFmKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlpmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKHlpLCB0LCBRZiksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0VmFsaWRhdGUodCkge1xuICAgIGNvbnN0IHsgaW52YWxpZExhYmVsOiBlLCBmb3JtYXQyNDogaSwgZm9ybWF0MTI6IG4sIGFwcGVuZFZhbGlkYXRpb25JbmZvOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCByO1xuICAgIG8gJiYgKHIgPSBEKFwiZGl2XCIpLCByLnNldEF0dHJpYnV0ZShoYSwgXCJcIiksIGMuYWRkQ2xhc3MociwgdGhpcy5fY2xhc3Nlcy5pbnZhbGlkRmVlZGJhY2spLCByLmlubmVySFRNTCA9IGUpLCBvZS5vbih0aGlzLmlucHV0LCB0LCAoeyB0YXJnZXQ6IGEgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwgfHwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbCA9IC9eKDA/WzEtOV18MVswMTJdKSg6WzAtNV1cXGQpIFtBUGFwXVttTV0kLywgcCA9IC9eKFswMV1cXGR8MlswLTNdKSg6WzAtNV1cXGQpJC8sIHUgPSBsLnRlc3QoYS52YWx1ZSk7XG4gICAgICBpZiAocC50ZXN0KGEudmFsdWUpICE9PSAhMCAmJiBpIHx8IHUgIT09ICEwICYmIG4pIHtcbiAgICAgICAgbyAmJiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoRG4sIFwiXCIpLCB0aGlzLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgdGhpcy5pbnB1dC5uZXh0U2libGluZ1xuICAgICAgICApKSwgYy5hZGRTdHlsZShhLCB7IG1hcmdpbkJvdHRvbTogMCB9KSwgYy5hZGRTdHlsZShyLCB7IGJvdHRvbTogXCItMjNweFwiIH0pLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKERuKSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExO1xuICAgICAgY29uc3QgXyA9IGQuZmluZE9uZShcbiAgICAgICAgYFske2hhfV1gXG4gICAgICApO1xuICAgICAgXyAhPT0gbnVsbCAmJiBfLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgU3MpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEpmID0ge1xuICB0aHJlc2hvbGQ6IDEwLFxuICBkaXJlY3Rpb246IFwiYWxsXCJcbn07XG5jbGFzcyB0bSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAuLi5KZixcbiAgICAgIC4uLmVcbiAgICB9O1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIGlmICghdGhpcy5fc3RhcnRQb3NpdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIGkgPSB7XG4gICAgICB4OiBlLnggLSB0aGlzLl9zdGFydFBvc2l0aW9uLngsXG4gICAgICB5OiBlLnkgLSB0aGlzLl9zdGFydFBvc2l0aW9uLnlcbiAgICB9LCBuID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGkpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJhbGxcIikge1xuICAgICAgaWYgKG4ueS52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIG4ueC52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gbi55LnZhbHVlID4gbi54LnZhbHVlID8gbi55LmRpcmVjdGlvbiA6IG4ueC5kaXJlY3Rpb247XG4gICAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtyfWApLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IGRpcmVjdGlvbjogciB9KSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGhpcy5fb3B0aW9ucyA9PT0gXCJyaWdodFwiID8gXCJ4XCIgOiBcInlcIjtcbiAgICBuW29dLmRpcmVjdGlvbiA9PT0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gJiYgbltvXS52YWx1ZSA+IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIChoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtuW29dLmRpcmVjdGlvbn1gKSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwpO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICB9XG4gIF9nZXRDb29yZGluYXRlcyh0KSB7XG4gICAgY29uc3QgW2VdID0gdC50b3VjaGVzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLmNsaWVudFgsXG4gICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG4gIF9nZXREaXJlY3Rpb24odCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC54IDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC54KVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnkgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LnkpXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgZW0ge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gXCJzd2lwZVwiLCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZXZlbnQgPSBlLCB0aGlzLnN3aXBlID0gbmV3IHRtKHQsIGkpLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaEVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydCh0KVxuICAgICksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKHQpXG4gICAgKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQodCkpO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG59XG5jb25zdCBfYSA9IFwic2lkZW5hdlwiLCBocyA9IFwidGUuc2lkZW5hdlwiLCBpbSA9IFwiZGF0YS10ZS1zaWRlbmF2LXJvdGF0ZS1pY29uLXJlZlwiLCBSbiA9IFwiW2RhdGEtdGUtc2lkZW5hdi10b2dnbGUtcmVmXVwiLCBzbSA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaW5pdF1cIiwgbm0gPSAnW2RhdGEtdGUtc2lkZW5hdi1zbGltPVwidHJ1ZVwiXScsIG9tID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cImZhbHNlXCJdJywgcm0gPSBcIltkYXRhLXRlLXNpZGVuYXYtbWVudS1yZWZdXCIsIGtlID0gXCJbZGF0YS10ZS1zaWRlbmF2LWNvbGxhcHNlLXJlZl1cIiwgbGkgPSBcIltkYXRhLXRlLXNpZGVuYXYtbGluay1yZWZdXCIsIGFtID0gRigpID8gMTAwIDogLTEwMCwgbG0gPSBGKCkgPyAtMTAwIDogMTAwLCBjbSA9IHtcbiAgc2lkZW5hdkFjY29yZGlvbjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZDbG9zZU9uRXNjOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Q29sb3I6IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdkNvbnRlbnQ6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2RXhwYW5kYWJsZTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkV4cGFuZE9uSG92ZXI6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZGb2N1c1RyYXA6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZIaWRkZW46IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZNb2RlOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXI6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZTogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50U206IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRNZDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludExnOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50WGw6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlNjcm9sbENvbnRhaW5lcjogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZTbGltOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2U2xpbUNvbGxhcHNlZDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1XaWR0aDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2UG9zaXRpb246IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdlJpZ2h0OiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZXaWR0aDogXCIobnVtYmVyKVwiXG59LCBobSA9IHtcbiAgc2lkZW5hdkFjY29yZGlvbjogITEsXG4gIHNpZGVuYXZCYWNrZHJvcDogITAsXG4gIHNpZGVuYXZCYWNrZHJvcENsYXNzOiBudWxsLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogITAsXG4gIHNpZGVuYXZDb2xvcjogXCJwcmltYXJ5XCIsXG4gIHNpZGVuYXZDb250ZW50OiBudWxsLFxuICBzaWRlbmF2RXhwYW5kYWJsZTogITAsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiAhMSxcbiAgc2lkZW5hdkZvY3VzVHJhcDogITAsXG4gIHNpZGVuYXZIaWRkZW46ICEwLFxuICBzaWRlbmF2TW9kZTogXCJvdmVyXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXI6IG51bGwsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IG51bGwsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2g6IG51bGwsXG4gIHNpZGVuYXZCcmVha3BvaW50U206IDY0MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRNZDogNzY4LFxuICBzaWRlbmF2QnJlYWtwb2ludExnOiAxMDI0LFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiAxMjgwLFxuICBzaWRlbmF2QnJlYWtwb2ludDJ4bDogMTUzNixcbiAgc2lkZW5hdlNjcm9sbENvbnRhaW5lcjogbnVsbCxcbiAgc2lkZW5hdlNsaW06ICExLFxuICBzaWRlbmF2U2xpbUNvbGxhcHNlZDogITEsXG4gIHNpZGVuYXZTbGltV2lkdGg6IDc3LFxuICBzaWRlbmF2UG9zaXRpb246IFwiZml4ZWRcIixcbiAgc2lkZW5hdlJpZ2h0OiAhMSxcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxuICBzaWRlbmF2V2lkdGg6IDI0MFxufTtcbmNsYXNzIHBpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgQXQodGhpcywgXCJfYWRkQmFja2Ryb3BPbkluaXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8ICh0aGlzLl9iYWNrZHJvcC5zaG93KCksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFwidHJhbnNpdGlvbmVuZFwiLCB0aGlzLl9hZGRCYWNrZHJvcE9uSW5pdCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5fSUQgPSBidChcIlwiKSwgdGhpcy5fY29udGVudCA9IG51bGwsIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGUgPSBudWxsLCB0aGlzLl9zbGltQ29sbGFwc2VkID0gITEsIHRoaXMuX2FjdGl2ZU5vZGUgPSBudWxsLCB0aGlzLl90ZW1wU2xpbSA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fdG91Y2ggPSBudWxsLCB0aGlzLl9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCksIHRoaXMuZXNjSGFuZGxlciA9IChpKSA9PiB7XG4gICAgICBpLmtleUNvZGUgPT09IExpICYmIHRoaXMudG9nZ2xlciAmJiBMdCh0aGlzLnRvZ2dsZXIpICYmICh0aGlzLl91cGRhdGUoITEpLCBoLm9mZih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpKTtcbiAgICB9LCB0aGlzLmhhc2hIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKTtcbiAgICB9LCB0ICYmIChJLnNldERhdGEodCwgaHMsIHRoaXMpLCB0aGlzLl9zZXR1cCgpKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiAhdGhpcy5vcHRpb25zLnNpZGVuYXZIaWRkZW4gJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiBoLm9uKHRoaXMuX2VsZW1lbnQsIFwidHJhbnNpdGlvbmVuZFwiLCB0aGlzLl9hZGRCYWNrZHJvcE9uSW5pdCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBfYTtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgICByZXR1cm4gZC5maW5kT25lKFwiYm9keVwiKTtcbiAgICBjb25zdCB0ID0gKGUpID0+ICFlLnBhcmVudE5vZGUgfHwgZS5wYXJlbnROb2RlID09PSBkb2N1bWVudCA/IGUgOiBlLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBlLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmVsYXRpdmVcIikgPyBlLnBhcmVudE5vZGUgOiB0KGUucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIHQodGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICBsZXQgdCA9IDAsIGUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiAhPT0gXCJmaXhlZFwiKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0ID0gbi54LCBlID0gbi54ICsgbi53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgeyB4OiBpIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gTWF0aC5hYnMoaSAtIGUpID4gMTAgOiBNYXRoLmFicyhpIC0gdCkgPCAxMDtcbiAgfVxuICBnZXQgbGlua3MoKSB7XG4gICAgcmV0dXJuIGQuZmluZChsaSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG5hdmlnYXRpb24oKSB7XG4gICAgcmV0dXJuIGQuZmluZChybSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLmhtLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBMKF9hLCB0LCBjbSksIHQ7XG4gIH1cbiAgZ2V0IHNpZGVuYXZTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGAke3RoaXMud2lkdGh9cHhgLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcIjEwMHZoXCIgOiBcIjEwMCVcIixcbiAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbjogYGFsbCAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufSBsaW5lYXJgXG4gICAgfTtcbiAgfVxuICBnZXQgdG9nZ2xlcigpIHtcbiAgICByZXR1cm4gZC5maW5kKFJuKS5maW5kKFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZShlLCBcInRhcmdldFwiKTtcbiAgICAgICAgcmV0dXJuIGQuZmluZE9uZShpKSA9PT0gdGhpcy5fZWxlbWVudDtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldCB0cmFuc2l0aW9uRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uIC8gMWUzfXNgO1xuICB9XG4gIGdldCB0cmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IGxtIDogYW07XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGltQ29sbGFwc2VkID8gdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltV2lkdGggOiB0aGlzLm9wdGlvbnMuc2lkZW5hdldpZHRoO1xuICB9XG4gIGdldCBpc0JhY2tkcm9wVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9iYWNrZHJvcC5fZWxlbWVudDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgY2hhbmdlTW9kZSh0KSB7XG4gICAgdGhpcy5fc2V0TW9kZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGgub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCBoLm9mZih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKSwgdGhpcy5fdG91Y2guZGlzcG9zZSgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgaHMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITEpLCB0aGlzLl91cGRhdGUoITEpLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITApLCB0aGlzLl91cGRhdGUoITApLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoIXRoaXMuaXNWaXNpYmxlKSwgdGhpcy5fdXBkYXRlKCF0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgdG9nZ2xlU2xpbSgpIHtcbiAgICB0aGlzLl9zZXRTbGltKCF0aGlzLl9zbGltQ29sbGFwc2VkKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0LCB0aGlzLl9zZXR1cCgpO1xuICB9XG4gIGdldEJyZWFrcG9pbnQodCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKVt0XTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGgub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFJuLFxuICAgICAgcGkudG9nZ2xlU2lkZW5hdigpXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbTogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50U20sXG4gICAgICBtZDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TWQsXG4gICAgICBsZzogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TGcsXG4gICAgICB4bDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50WGwsXG4gICAgICBcIjJ4bFwiOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnQyeGxcbiAgICB9O1xuICB9XG4gIF9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpO1xuICAgIGlmICh0ID09PSB2b2lkIDAgfHwgIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXJdLCBuID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZV0sIG8gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoXSwgciA9IChsLCBwKSA9PiBsIC0gcCA8IDAgPyAtMSA6IHAgLSBsIDwgMCA/IDEgOiAwLCBhID0gW2ksIG4sIG9dLmZpbHRlcigobCkgPT4gbCAhPSBudWxsICYmIGwgPj0gMCkuc29ydChyKVswXTtcbiAgICBpID4gMCAmJiBpID09PSBhID8gKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcIm92ZXJcIiwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuID0gITApIDogbiA+IDAgJiYgbiA9PT0gYSA/IHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInNpZGVcIiA6IG8gPiAwICYmIG8gPT09IGEgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInB1c2hcIik7XG4gIH1cbiAgX2NvbGxhcHNlSXRlbXMoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGQuZmluZChrZSwgdCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBxdC5nZXRJbnN0YW5jZShpKS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0T2Zmc2V0VmFsdWUodCwgeyBpbmRleDogZSwgcHJvcGVydHk6IGksIG9mZnNldHM6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXRQeFZhbHVlKFxuICAgICAgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtlXVtuW2ldLnByb3BlcnR5XVxuICAgICksIHIgPSB0ID8gbltpXS52YWx1ZSA6IDA7XG4gICAgcmV0dXJuIG8gKyByO1xuICB9XG4gIF9nZXRQcm9wZXJ0eSguLi50KSB7XG4gICAgcmV0dXJuIHQubWFwKChlLCBpKSA9PiBpID09PSAwID8gZSA6IGVbMF0udG9VcHBlckNhc2UoKS5jb25jYXQoZS5zbGljZSgxKSkpLmpvaW4oXCJcIik7XG4gIH1cbiAgX2dldFB4VmFsdWUodCkge1xuICAgIHJldHVybiB0ID8gcGFyc2VGbG9hdCh0KSA6IDA7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKHQsIGUpIHtcbiAgICBlICYmIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlU2xpbSgpIDogZSB8fCAodGhpcy5fc2xpbUNvbGxhcHNlZCB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZXIgJiYgTHQodGhpcy50b2dnbGVyKSAmJiB0aGlzLnRvZ2dsZSgpIDogdGhpcy50b2dnbGVTbGltKCkpO1xuICB9XG4gIF9pc0FjdGl2ZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPyBlID09PSB0IDogdC5hdHRyaWJ1dGVzLmhyZWYgPyBuZXcgVVJMKHQsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmID09PSB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICExO1xuICB9XG4gIF9pc0FsbFRvQmVDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChcbiAgICAgIHNtLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZmlsdGVyKFxuICAgICAgKGkpID0+IGkuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCJcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaXNBbGxDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChrZSwgdGhpcy5fZWxlbWVudCkuZmlsdGVyKFxuICAgICAgKHQpID0+IEx0KHQpXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3ApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcyA/IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcy5zcGxpdChcIiBcIikgOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID8gW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotNTBcIixcbiAgICAgIFwiYmctYmxhY2svMTBcIixcbiAgICAgIFwiZGFyazpiZy1ibGFjay02MFwiLFxuICAgICAgXCJ3LWZ1bGxcIixcbiAgICAgIFwiaC1mdWxsXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmlkXG4gICAgXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBTbyh7XG4gICAgICBpc1Zpc2libGU6IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBiYWNrZHJvcENsYXNzZXM6IHQsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVCYWNrZHJvcCh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIpIHtcbiAgICAgIHQgPyB0aGlzLl9iYWNrZHJvcC5zaG93KCkgOiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIHRoaXMuX3NldHVwVG91Y2goKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fc2V0dXBGb2N1c1RyYXAoKSwgdGhpcy5fc2V0dXBDb2xsYXBzZSgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5fc2V0dXBTbGltKCksIHRoaXMuX3NldHVwSW5pdGlhbFN0eWxpbmcoKSwgdGhpcy5fc2V0dXBTY3JvbGxpbmcoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50ICYmIHRoaXMuX3NldHVwQ29udGVudCgpLCB0aGlzLl9zZXR1cEFjdGl2ZVN0YXRlKCksIHRoaXMuX3NldHVwUmlwcGxlRWZmZWN0KCksIHRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8IHRoaXMuX3VwZGF0ZU9mZnNldHMoITAsICEwKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9zZXRUYWJpbmRleCghMCk7XG4gIH1cbiAgX3NldHVwQWN0aXZlU3RhdGUoKSB7XG4gICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKSwgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLm9uKHQsIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCkpLCBoLm9uKHQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICBlLmtleUNvZGUgPT09IGx0ICYmIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpO1xuICAgICAgfSk7XG4gICAgfSksIGgub24od2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlcik7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2UoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGQuZmluZChrZSwgdCkuZm9yRWFjaChcbiAgICAgICAgKG4sIG8pID0+IHRoaXMuX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogbiwgaW5kZXg6IG8sIG1lbnU6IHQsIG1lbnVJbmRleDogZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfZ2VuZXJhdGVDb2xscGFzZUlEKHQsIGUpIHtcbiAgICByZXR1cm4gYHNpZGVuYXYtY29sbGFwc2UtJHt0aGlzLl9JRH0tJHtlfS0ke3R9YDtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiB0LCBpbmRleDogZSwgbWVudTogaSwgbWVudUluZGV4OiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2VuZXJhdGVDb2xscGFzZUlEKGUsIG4pO1xuICAgIHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIFwiXCIpO1xuICAgIGNvbnN0IFtyXSA9IGQucHJldih0LCBsaSk7XG4gICAgYy5zZXREYXRhQXR0cmlidXRlKHIsIFwiY29sbGFwc2UtaW5pdFwiLCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtvfWApLCByLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgY29uc3QgYSA9IHF0LmdldEluc3RhbmNlKHQpIHx8IG5ldyBxdCh0LCB7XG4gICAgICB0b2dnbGU6ICExLFxuICAgICAgcGFyZW50OiB0aGlzLm9wdGlvbnMuc2lkZW5hdkFjY29yZGlvbiA/IGkgOiB0XG4gICAgfSk7XG4gICAgKHQuZGF0YXNldC50ZVNpZGVuYXZTdGF0ZVNob3cgPT09IFwiXCIgfHwgdC5kYXRhc2V0LnRlQ29sbGFwc2VTaG93ID09PSBcIlwiKSAmJiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSksIGgub24ociwgXCJjbGlja1wiLCAobCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlQ2F0ZWdvcnkobCwgYSwgdCksIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsVG9CZUNvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgaC5vbihcbiAgICAgIHQsXG4gICAgICBcInNob3cudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICExKVxuICAgICksIGgub24oXG4gICAgICB0LFxuICAgICAgXCJoaWRlLnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMClcbiAgICApLCBoLm9uKHQsIFwic2hvd24udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCBoLm9uKHQsIFwiaGlkZGVuLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cENvbnRlbnQoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IGQuZmluZCh0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQpLCB0aGlzLl9jb250ZW50LmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBbXG4gICAgICAgIFwiIXBcIixcbiAgICAgICAgXCIhbVwiLFxuICAgICAgICBcIiFweFwiLFxuICAgICAgICBcIiFwbFwiLFxuICAgICAgICBcIiFwclwiLFxuICAgICAgICBcIiFteFwiLFxuICAgICAgICBcIiFtbFwiLFxuICAgICAgICBcIiFtclwiLFxuICAgICAgICBcIiEtcFwiLFxuICAgICAgICBcIiEtbVwiLFxuICAgICAgICBcIiEtcHhcIixcbiAgICAgICAgXCIhLXBsXCIsXG4gICAgICAgIFwiIS1wclwiLFxuICAgICAgICBcIiEtbXhcIixcbiAgICAgICAgXCIhLW1sXCIsXG4gICAgICAgIFwiIS1tclwiXG4gICAgICBdO1xuICAgICAgWy4uLnQuY2xhc3NMaXN0XS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBlLmZpbmRJbmRleCgobykgPT4gbi5pbmNsdWRlcyhvKSkgPj0gMFxuICAgICAgKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICAgIH0pLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gdGhpcy5fY29udGVudC5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgcmV0dXJuIHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3ICRpKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleUNvZGUgPT09IE9pLFxuICAgICAgICBvbmx5VmlzaWJsZTogITBcbiAgICAgIH0sXG4gICAgICB0aGlzLnRvZ2dsZXJcbiAgICApO1xuICB9XG4gIF9zZXR1cEluaXRpYWxTdHlsaW5nKCkge1xuICAgIHRoaXMuX3NldENvbG9yKCksIGMuc3R5bGUodGhpcy5fZWxlbWVudCwgdGhpcy5zaWRlbmF2U3R5bGUpO1xuICB9XG4gIF9zZXR1cFNjcm9sbGluZygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0ID0gZC5maW5kT25lKFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGkgPSBWYyh0LnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcihcbiAgICAgICAgKG4pID0+IG4gIT09IHRcbiAgICAgICkucmVkdWNlKChuLCBvKSA9PiBuICsgby5jbGllbnRIZWlnaHQsIDApO1xuICAgICAgYy5zdHlsZSh0LCB7XG4gICAgICAgIG1heEhlaWdodDogYGNhbGMoMTAwJSAtICR7aX1weClgLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyB5Yyh0LCB7XG4gICAgICBzdXBwcmVzc1Njcm9sbFg6ICEwLFxuICAgICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXVxuICAgIH0pO1xuICB9XG4gIF9zZXR1cFNsaW0oKSB7XG4gICAgdGhpcy5fc2xpbUNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbUNvbGxhcHNlZCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodGhpcy5fc2xpbUNvbGxhcHNlZCksIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kT25Ib3ZlciAmJiAodGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMuX3NldFNsaW0oITEpO1xuICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgdGhpcy5fc2V0U2xpbSghMCk7XG4gICAgfSkpO1xuICB9XG4gIF9zZXR1cFJpcHBsZUVmZmVjdCgpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGxldCBlID0gVWUuZ2V0SW5zdGFuY2UodCksIGkgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yO1xuICAgICAgaWYgKGUgJiYgZS5fb3B0aW9ucy5zaWRlbmF2Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaWRlbmF2Q29sb3IpXG4gICAgICAgIGUuZGlzcG9zZSgpO1xuICAgICAgZWxzZSBpZiAoZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGkgPSBcIndoaXRlXCIpLCBlID0gbmV3IFVlKHQsIHsgcmlwcGxlQ29sb3I6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwVG91Y2goKSB7XG4gICAgdGhpcy5fdG91Y2ggPSBuZXcgZW0odGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IHRocmVzaG9sZDogMjAgfSksIHRoaXMuX3RvdWNoLmluaXQoKSwgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlbGVmdFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN3aXBlKHQsIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlcmlnaHRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCAhdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodClcbiAgICApO1xuICB9XG4gIF9zZXRBY3RpdmUodCwgZSkge1xuICAgIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlYmFyLXN0YXRlLWFjdGl2ZVwiLCBcIlwiKSwgdGhpcy5fYWN0aXZlTm9kZSAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiksIHRoaXMuX2FjdGl2ZU5vZGUgPSB0O1xuICAgIGNvbnN0IFtpXSA9IGQucGFyZW50cyhcbiAgICAgIHRoaXMuX2FjdGl2ZU5vZGUsXG4gICAgICBrZVxuICAgICk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbl0gPSBkLnByZXYoaSwgbGkpO1xuICAgIHRoaXMuX3NldEFjdGl2ZUNhdGVnb3J5KG4pLCAhZSAmJiAhdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiBxdC5nZXRJbnN0YW5jZShpKS5zaG93KCk7XG4gIH1cbiAgX3NldEFjdGl2ZUNhdGVnb3J5KHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kKGtlLCBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IFtvXSA9IGQucHJldihuLCBsaSk7XG4gICAgICAgIG8gIT09IHQgPyBvLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIikgOiBvLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIiwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmQobGksIGUpLmZpbHRlcigobikgPT4gZC5uZXh0KG4sIGtlKS5sZW5ndGggPT09IDApLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUobiwgdCkgJiYgbiAhPT0gdGhpcy5fYWN0aXZlTm9kZSAmJiB0aGlzLl9zZXRBY3RpdmUobiwgdCk7XG4gICAgICB9KTtcbiAgICB9KSwgdCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldENvbG9yKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcInByaW1hcnlcIixcbiAgICAgIFwic2Vjb25kYXJ5XCIsXG4gICAgICBcInN1Y2Nlc3NcIixcbiAgICAgIFwiaW5mb1wiLFxuICAgICAgXCJ3YXJuaW5nXCIsXG4gICAgICBcImRhbmdlclwiLFxuICAgICAgXCJsaWdodFwiLFxuICAgICAgXCJkYXJrXCJcbiAgICBdLCB7IHNpZGVuYXZDb2xvcjogZSB9ID0gdGhpcy5vcHRpb25zLCBpID0gdC5pbmNsdWRlcyhlKSA/IGUgOiBcInByaW1hcnlcIjtcbiAgICB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgc2lkZW5hdi0ke259YCk7XG4gICAgfSksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgYHNpZGVuYXYtJHtpfWApO1xuICB9XG4gIF9zZXRDb250ZW50T2Zmc2V0cyh0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29udGVudC5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T2Zmc2V0VmFsdWUodCwge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgcHJvcGVydHk6IFwicGFkZGluZ1wiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgYSA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcIm1hcmdpblwiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgbCA9IHt9O1xuICAgICAgaWYgKGkgfHwgKGwudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYCksIGxbZS5wYWRkaW5nLnByb3BlcnR5XSA9IGAke3J9cHhgLCBsW2UubWFyZ2luLnByb3BlcnR5XSA9IGAke2F9cHhgLCBjLnN0eWxlKG4sIGwpLCAhIXQpIHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBjLnN0eWxlKG4sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbb10udHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoLm9uKG4sIFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgYy5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3NldE1vZGUodCkge1xuICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IHQsIHRoaXMuX3VwZGF0ZSh0aGlzLmlzVmlzaWJsZSkpO1xuICB9XG4gIF9zZXRTbGltKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcImNvbGxhcHNlXCIsIFwiY29sbGFwc2VkXCJdIDogW1wiZXhwYW5kXCIsIFwiZXhwYW5kZWRcIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKSwgdCAmJiB0aGlzLl9jb2xsYXBzZUl0ZW1zKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0LCB0aGlzLl90b2dnbGVTbGltRGlzcGxheSh0KSwgYy5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCB9KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldFRhYmluZGV4KHQpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUudGFiSW5kZXggPSB0ID8gMCA6IC0xO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0RXZlbnRzKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcInNob3dcIiwgXCJzaG93blwiXSA6IFtcImhpZGVcIiwgXCJoaWRkZW5cIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKTtcbiAgfVxuICBfcm90YXRlQXJyb3codCwgZSkge1xuICAgIGNvbnN0IFtpXSA9IGQuY2hpbGRyZW4odCwgYFske2ltfV1gKTtcbiAgICBpICYmIChlID8gYy5yZW1vdmVDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikgOiBjLmFkZENsYXNzKGksIFwicm90YXRlLTE4MFwiKSk7XG4gIH1cbiAgX3RvZ2dsZUNhdGVnb3J5KHQsIGUpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIGUudG9nZ2xlKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlICYmICh0aGlzLl90ZW1wU2xpbSA9ICEwLCB0aGlzLl9zZXRTbGltKCExKSk7XG4gIH1cbiAgX3RvZ2dsZVNsaW1EaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFxuICAgICAgbm0sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIG9tLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG4gPSAoKSA9PiB7XG4gICAgICBlLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgYy5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwidW5zZXRcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSksIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBjLnN0eWxlKG8sIHtcbiAgICAgICAgICBkaXNwbGF5OiB0aGlzLl9zbGltQ29sbGFwc2VkID8gXCJub25lXCIgOiBcInVuc2V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHQgPyBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gbigpLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb25cbiAgICApIDogbigpO1xuICB9XG4gIGFzeW5jIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7dH0udGUuc2lkZW5hdmApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLnNpZGVuYXZgKTtcbiAgICB9LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiArIDUpO1xuICB9XG4gIF9pc2lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuICBfdXBkYXRlKHQpIHtcbiAgICB0ICYmIHRoaXMuX2lzaVBob25lKCkgJiYgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcInBzLS1zY3JvbGxpbmcteVwiKSwgdGhpcy50b2dnbGVyICYmIHRoaXMuX3VwZGF0ZVRvZ2dsZXJBcmlhKHQpLCB0aGlzLl91cGRhdGVEaXNwbGF5KHQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX3VwZGF0ZUJhY2tkcm9wKHQpLCB0aGlzLl91cGRhdGVPZmZzZXRzKHQpLCB0ICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2Q2xvc2VPbkVzYyAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IFwic2lkZVwiICYmIGgub24od2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fdXBkYXRlRm9jdXModCk7XG4gIH1cbiAgX3VwZGF0ZURpc3BsYXkodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gMCA6IHRoaXMudHJhbnNsYXRpb247XG4gICAgYy5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7ZX0lKWBcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlRm9jdXModCkge1xuICAgIGlmICh0aGlzLl9zZXRUYWJpbmRleCh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgfVxuICBfdXBkYXRlT2Zmc2V0cyh0LCBlID0gITEpIHtcbiAgICBjb25zdCBbaSwgbl0gPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gW1wicmlnaHRcIiwgXCJsZWZ0XCJdIDogW1wibGVmdFwiLCBcInJpZ2h0XCJdLCBvID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwicGFkZGluZ1wiLCBpKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiID8gMCA6IHRoaXMud2lkdGhcbiAgICB9LCByID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwibWFyZ2luXCIsIG4pLFxuICAgICAgdmFsdWU6IHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJwdXNoXCIgPyAtMSAqIHRoaXMud2lkdGggOiAwXG4gICAgfTtcbiAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJ1cGRhdGUudGUuc2lkZW5hdlwiLCB7XG4gICAgICBtYXJnaW46IHIsXG4gICAgICBwYWRkaW5nOiBvXG4gICAgfSksIHRoaXMuX2NvbnRlbnQgJiYgKHRoaXMuX2NvbnRlbnQuY2xhc3NOYW1lID0gXCJcIiwgdGhpcy5fc2V0Q29udGVudE9mZnNldHModCwgeyBwYWRkaW5nOiBvLCBtYXJnaW46IHIgfSwgZSkpO1xuICB9XG4gIF91cGRhdGVUb2dnbGVyQXJpYSh0KSB7XG4gICAgdGhpcy50b2dnbGVyLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyB0b2dnbGVTaWRlbmF2KCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb25zdCBlID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBSbiksIGkgPSBjLmdldERhdGFBdHRyaWJ1dGVzKGUpLnRhcmdldDtcbiAgICAgIGQuZmluZChpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIChwaS5nZXRJbnN0YW5jZShuKSB8fCBuZXcgcGkobikpLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBJLmdldERhdGEodGhpcywgaHMpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBwaSh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBocyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgbG8gPSBcInN0ZXBwZXJcIiwgSXMgPSBcInRlLnN0ZXBwZXJcIiwgS3MgPSBgLiR7SXN9YCwgTWkgPSBgZGF0YS10ZS0ke2xvfWAsIF9pID0gXCJob3Jpem9udGFsXCIsIHh0ID0gXCJ2ZXJ0aWNhbFwiLCBkbSA9IHtcbiAgc3RlcHBlclR5cGU6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJMaW5lYXI6IFwiYm9vbGVhblwiLFxuICBzdGVwcGVyTm9FZGl0YWJsZTogXCJib29sZWFuXCIsXG4gIHN0ZXBwZXJBY3RpdmU6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJDb21wbGV0ZWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJJbnZhbGlkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyRGlzYWJsZWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQ6IFwibnVtYmVyXCIsXG4gIHN0ZXBwZXJNb2JpbGVCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyTW9iaWxlQmFyQnJlYWtwb2ludDogXCJudW1iZXJcIlxufSwgdW0gPSB7XG4gIHN0ZXBwZXJUeXBlOiBfaSxcbiAgc3RlcHBlckxpbmVhcjogITEsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiAhMSxcbiAgc3RlcHBlckFjdGl2ZTogXCJcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJcIixcbiAgc3RlcHBlckludmFsaWQ6IFwiXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogMCxcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiA0XG59LCBmYSA9IGBtb3VzZWRvd24ke0tzfWAsIG1hID0gYGtleWRvd24ke0tzfWAsIHBtID0gYGtleXVwJHtLc31gLCBnYSA9IGByZXNpemUke0tzfWAsIGp0ID0gYFske01pfS1zdGVwLXJlZl1gLCBHID0gYFske01pfS1oZWFkLXJlZl1gLCBiYSA9IGBbJHtNaX0taGVhZC10ZXh0LXJlZl1gLCBkcyA9IGBbJHtNaX0taGVhZC1pY29uLXJlZl1gLCBzdCA9IGBbJHtNaX0tY29udGVudC1yZWZdYDtcbmNsYXNzIGowIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50SGVpZ2h0ID0gMCwgdGhpcy5fc3RlcHMgPSBkLmZpbmQoYCR7anR9YCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2N1cnJlbnRWaWV3ID0gXCJcIiwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gMCwgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBJcywgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGxvO1xuICB9XG4gIGdldCBhY3RpdmVTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVwc1t0aGlzLl9hY3RpdmVTdGVwSW5kZXhdO1xuICB9XG4gIGdldCBhY3RpdmVTdGVwSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLm9mZih0LCBmYSksIGgub2ZmKHQsIG1hKTtcbiAgICB9KSwgaC5vZmYod2luZG93LCBnYSksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBJcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIGNoYW5nZVN0ZXAodCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodCk7XG4gIH1cbiAgbmV4dFN0ZXAoKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcCh0aGlzLl9hY3RpdmVTdGVwSW5kZXggKyAxKTtcbiAgfVxuICBwcmV2aW91c1N0ZXAoKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcCh0aGlzLl9hY3RpdmVTdGVwSW5kZXggLSAxKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoYCR7anR9YCwgdGhpcy5fZWxlbWVudClbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIsIFwiYWN0aXZlLXN0ZXBcIiksIGUgPSBkLmZpbmQoXG4gICAgICBgJHtiYX1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBkLmZpbmQoXG4gICAgICBgJHtkc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgc3dpdGNoICh0ID8gKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9IHRoaXMuX3N0ZXBzLmluZGV4T2YodCksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImZvbnQtbWVkaXVtXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSkgOiAoZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApKSwgdGhpcy5fYmluZE1vdXNlRG93bigpLCB0aGlzLl9iaW5kS2V5c05hdmlnYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyVHlwZSkge1xuICAgICAgY2FzZSB4dDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlVmVydGljYWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl90b2dnbGVIb3Jpem9udGFsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAodGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50IHx8IHRoaXMuX29wdGlvbnMuc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQpICYmIHRoaXMuX3RvZ2dsZVN0ZXBwZXJWaWV3KCksIHRoaXMuX2JpbmRSZXNpemUoKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnVtLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKGxvLCB0LCBkbSksIHQ7XG4gIH1cbiAgX2JpbmRNb3VzZURvd24oKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtHfWAsIHQpO1xuICAgICAgaC5vbihlLCBmYSwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGQucGFyZW50cyhpLnRhcmdldCwgYCR7anR9YClbMF0sIG8gPSB0aGlzLl9zdGVwcy5pbmRleE9mKG4pO1xuICAgICAgICBpLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3RvZ2dsZVN0ZXAobyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFJlc2l6ZSgpIHtcbiAgICBoLm9uKHdpbmRvdywgZ2EsICgpID0+IHtcbiAgICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB4dCAmJiB0aGlzLl9zZXRTaW5nbGVTdGVwSGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBfaSAmJiB0aGlzLl9zZXRIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwcGVyVmlldygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50IDwgd2luZG93LmlubmVyV2lkdGgsIGUgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgPiB3aW5kb3cuaW5uZXJXaWR0aCwgaSA9IHRoaXMuX29wdGlvbnMuc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0ICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSBfaSAmJiB0aGlzLl90b2dnbGVIb3Jpem9udGFsKCksIGUgJiYgIWkgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IHh0ICYmICh0aGlzLl9zdGVwcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gZC5maW5kT25lKGAke3N0fWAsIG4pO1xuICAgICAgdGhpcy5fcmVzZXRTdGVwcGVySGVpZ2h0KCksIHRoaXMuX3Nob3dFbGVtZW50KG8pO1xuICAgIH0pLCB0aGlzLl90b2dnbGVWZXJ0aWNhbCgpKTtcbiAgfVxuICBfdG9nZ2xlU3RlcCh0KSB7XG4gICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4ICE9PSB0ICYmICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJOb0VkaXRhYmxlICYmIHRoaXMuX3RvZ2dsZURpc2FibGVkKCksIHRoaXMuX3Nob3dFbGVtZW50KFxuICAgICAgZC5maW5kT25lKGAke3N0fWAsIHRoaXMuX3N0ZXBzW3RdKVxuICAgICksIHRoaXMuX3RvZ2dsZUFjdGl2ZSh0KSwgdCA+IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl90b2dnbGVDb21wbGV0ZWQodGhpcy5fYWN0aXZlU3RlcEluZGV4KSwgdGhpcy5fY3VycmVudFZpZXcgPT09IF9pID8gdGhpcy5fYW5pbWF0ZUhvcml6b250YWxTdGVwKHQpIDogKHRoaXMuX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCksIHRoaXMuX3NldFNpbmdsZVN0ZXBIZWlnaHQodGhpcy5fc3RlcHNbdF0pKSwgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KFxuICAgICAgZC5maW5kT25lKGAke0d9YCwgdGhpcy5hY3RpdmVTdGVwKSxcbiAgICAgIGQuZmluZE9uZShgJHtHfWAsIHRoaXMuX3N0ZXBzW3RdKVxuICAgICksIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9IHQsIHRoaXMuX3N0ZXBzW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCB0aGlzLl9zdGVwcy5mb3JFYWNoKChlLCBpKSA9PiB7XG4gICAgICBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0gIT09IGkgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfcmVzZXRTdGVwcGVySGVpZ2h0KCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgfVxuICBfc2V0U3RlcHNIZWlnaHQoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtzdH1gLCB0KSwgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpO1xuICAgICAgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzLnB1c2goe1xuICAgICAgICBwYWRkaW5nVG9wOiBwYXJzZUZsb2F0KGkucGFkZGluZ1RvcCksXG4gICAgICAgIHBhZGRpbmdCb3R0b206IHBhcnNlRmxvYXQoaS5wYWRkaW5nQm90dG9tKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZS5zY3JvbGxIZWlnaHQ7XG4gICAgICBlLnN0eWxlLmhlaWdodCA9IGAke259cHhgO1xuICAgIH0pO1xuICB9XG4gIF9zZXRTaW5nbGVTdGVwSGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKGAke3N0fWAsIHQpLCBpID0gdGhpcy5hY3RpdmVTdGVwID09PSB0LCBuID0gdGhpcy5fc3RlcHMuaW5kZXhPZih0KTtcbiAgICBsZXQgbztcbiAgICBpID8gKGUuc3R5bGUuaGVpZ2h0ID0gXCJcIiwgbyA9IGUuc2Nyb2xsSGVpZ2h0KSA6IG8gPSBlLnNjcm9sbEhlaWdodCArIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlc1tuXS5wYWRkaW5nVG9wICsgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzW25dLnBhZGRpbmdCb3R0b20sIGUuc3R5bGUuaGVpZ2h0ID0gYCR7b31weGA7XG4gIH1cbiAgX3RvZ2dsZVZlcnRpY2FsKCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0geHQsIHRoaXMuX3NldFN0ZXBzSGVpZ2h0KCksIHRoaXMuX2hpZGVJbmFjdGl2ZVN0ZXBzKCk7XG4gIH1cbiAgX3RvZ2dsZUhvcml6b250YWwoKSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBfaSwgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksIHRoaXMuX2hpZGVJbmFjdGl2ZVN0ZXBzKCk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBwZXJDbGFzcygpIHtcbiAgICBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLXN0ZXBwZXItdHlwZV1cIixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApICE9PSBudWxsICYmIHRoaXMuX3N0ZXBzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuZmluZE9uZShgJHtzdH1gLCBlKS5jbGFzc0xpc3QucmVtb3ZlKFwiIW15LTBcIiksIGQuZmluZE9uZShgJHtzdH1gLCBlKS5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIGQuZmluZE9uZShgJHtzdH1gLCBlKS5jbGFzc0xpc3QucmVtb3ZlKFwiIWgtMFwiKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcENsYXNzKHQsIGUsIGkpIHtcbiAgICBpICYmIHRoaXMuX3N0ZXBzW3RdLmNsYXNzTGlzdFtlXShpKTtcbiAgfVxuICBfYmluZEtleXNOYXZpZ2F0aW9uKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChcbiAgICAgICExLFxuICAgICAgZC5maW5kT25lKGAke0d9YCwgdGhpcy5hY3RpdmVTdGVwKVxuICAgICksIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7R31gLCB0KTtcbiAgICAgIGgub24oZSwgbWEsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoXG4gICAgICAgICAgaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGAke2p0fWBcbiAgICAgICAgKVswXSwgbyA9IGQubmV4dChuLCBgJHtqdH1gKVswXSwgciA9IGQucHJldihuLCBgJHtqdH1gKVswXSwgYSA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgblxuICAgICAgICApLCBsID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHAgPSBudWxsLCB1ID0gbnVsbDtcbiAgICAgICAgaWYgKG8gJiYgKHAgPSBkLmZpbmRPbmUoYCR7R31gLCBvKSksIHIgJiYgKHUgPSBkLmZpbmRPbmUoYCR7R31gLCByKSksIGkua2V5Q29kZSA9PT0gUGUgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IHh0ICYmICh1ID8gKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSA6IHAgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBwKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBwKSwgcC5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gQmUgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IHh0ICYmIChwID8gKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBwKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBwKSwgcC5mb2N1cygpKSA6IHUgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0geiAmJiB0aGlzLl9jdXJyZW50VmlldyA9PT0geHQgJiYgKGkucHJldmVudERlZmF1bHQoKSwgcCAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSBydCAmJiB0aGlzLl9jdXJyZW50VmlldyA9PT0geHQgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSBIZSkge1xuICAgICAgICAgIGNvbnN0IGYgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgICB0aGlzLl9zdGVwc1swXVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGYpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGYpLCBmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkua2V5Q29kZSA9PT0gV2UpIHtcbiAgICAgICAgICBjb25zdCBmID0gdGhpcy5fc3RlcHNbdGhpcy5fc3RlcHMubGVuZ3RoIC0gMV0sIF8gPSBkLmZpbmRPbmUoYCR7R31gLCBmKTtcbiAgICAgICAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgXyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgXyksIF8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICAoaS5rZXlDb2RlID09PSBsdCB8fCBpLmtleUNvZGUgPT09IGtzKSAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNoYW5nZVN0ZXAodGhpcy5fc3RlcHMuaW5kZXhPZihuKSkpLCBpLmtleUNvZGUgPT09IE9pICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgbCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgITEpLCBsLmZvY3VzKCkpO1xuICAgICAgfSksIGgub24oZSwgcG0sIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoXG4gICAgICAgICAgaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGAke2p0fWBcbiAgICAgICAgKVswXSwgbyA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgblxuICAgICAgICApLCByID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICAgICAgKTtcbiAgICAgICAgaS5rZXlDb2RlID09PSBPaSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KG8sIHIpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKCExLCByKSwgci5mb2N1cygpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwVGFiSW5kZXgodCwgZSkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCAtMSksIGUgJiYgZS5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCAwKTtcbiAgfVxuICBfdG9nZ2xlT3V0bGluZVN0eWxlcyh0LCBlKSB7XG4gICAgdCAmJiAodC5zdHlsZS5vdXRsaW5lID0gXCJcIiksIGUgJiYgKGUuc3R5bGUub3V0bGluZSA9IFwicmV2ZXJ0XCIpO1xuICB9XG4gIF90b2dnbGVEaXNhYmxlZCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGAke0d9YCwgdGhpcy5fZWxlbWVudCksIGUgPSBkLmZpbmQoXG4gICAgICBgJHtkc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdFt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJjb2xvci1bIzg1ODU4NV1cIiksIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY3Vyc29yLWRlZmF1bHRcIiksIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLVsjODU4NTg1XVwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJhZGRcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckRpc2FibGVkXG4gICAgKTtcbiAgfVxuICBfdG9nZ2xlQWN0aXZlKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFxuICAgICAgYCR7YmF9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgYCR7ZHN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGVbdF0uY2xhc3NMaXN0LmFkZChcImZvbnQtbWVkaXVtXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctc3VjY2Vzcy0xMDBcIiksIGlbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiF0ZXh0LXN1Y2Nlc3MtNzAwXCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShcImZvbnQtbWVkaXVtXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBcIiF0ZXh0LXByaW1hcnktNzAwXCJcbiAgICApLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJhZGRcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJyZW1vdmVcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZVxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUNvbXBsZXRlZCh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGAke2RzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCIhYmctc3VjY2Vzcy0xMDBcIiksIGVbdF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXN1Y2Nlc3MtNzAwXCIpLCBlW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctZGFuZ2VyLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIXRleHQtZGFuZ2VyLTcwMFwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckNvbXBsZXRlZCksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcInJlbW92ZVwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJJbnZhbGlkKTtcbiAgfVxuICBfaGlkZUluYWN0aXZlU3RlcHMoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIpIHx8IHRoaXMuX2hpZGVFbGVtZW50KGQuZmluZE9uZShgJHtzdH1gLCB0KSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEhlaWdodCh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtzdH1gLCB0KSwgaSA9IGdldENvbXB1dGVkU3R5bGUoZSksIG4gPSBkLmZpbmRPbmUoYCR7R31gLCB0KSwgbyA9IGdldENvbXB1dGVkU3R5bGUobiksIHIgPSBlLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoaS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChpLm1hcmdpbkJvdHRvbSksIGEgPSBuLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoby5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChvLm1hcmdpbkJvdHRvbSk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHthICsgcn1weGA7XG4gIH1cbiAgX2hpZGVFbGVtZW50KHQpIHtcbiAgICAhZC5wYXJlbnRzKFxuICAgICAgdCxcbiAgICAgIGAke2p0fWBcbiAgICApWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IHh0IHx8ICh0LmNsYXNzTGlzdC5hZGQoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFoLTBcIikpO1xuICB9XG4gIF9zaG93RWxlbWVudCh0KSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ID8gKHQuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCIhcHktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIWgtMFwiKSkgOiB0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIH1cbiAgX2FuaW1hdGVIb3Jpem9udGFsU3RlcCh0KSB7XG4gICAgY29uc3QgZSA9IHQgPiB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsIGkgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBuID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICk7XG4gICAgbGV0IG8sIHI7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodSwgZikgPT4ge1xuICAgICAgY29uc3QgXyA9IGQuZmluZE9uZShgJHtzdH1gLCB1KTtcbiAgICAgIGYgIT09IHQgJiYgZiAhPT0gdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmIHRoaXMuX2hpZGVFbGVtZW50KF8pO1xuICAgIH0pO1xuICAgIGNvbnN0IGEgPSBcInRyYW5zbGF0ZS14LVsxNTAlXVwiLCBsID0gXCItdHJhbnNsYXRlLXgtWzE1MCVdXCIsIHAgPSBcInRyYW5zbGF0ZS0wXCI7XG4gICAgZSA/IChyID0gbCwgbyA9IHAsIGkuY2xhc3NMaXN0LnJlbW92ZShcInRyYW5zbGF0ZS14LVsxNTAlXVwiKSwgaS5jbGFzc0xpc3QucmVtb3ZlKFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiKSkgOiAociA9IGEsIG8gPSBwLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCItdHJhbnNsYXRlLXgtWzE1MCVdXCIpLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIikpLCBuLmNsYXNzTGlzdC5hZGQociksIGkuY2xhc3NMaXN0LmFkZChvKSwgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKTtcbiAgfVxuICBfYW5pbWF0ZVZlcnRpY2FsU3RlcCh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLl9zdGVwc1t0XVxuICAgICksIGkgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgKTtcbiAgICB0aGlzLl9oaWRlRWxlbWVudChpKSwgdGhpcy5fc2hvd0VsZW1lbnQoZSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIElzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB2YSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgdXMgPSBcImRhdGEtdGUtaW5wdXQtc2VsZWN0ZWRcIiwgVGEgPSBcImRhdGEtdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXCIsIEVhID0gXCJbZGF0YS10ZS1mb3JtLWNoZWNrLWlucHV0XVwiO1xuY2xhc3MgQ2Ege1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwLCB1LCBmKSB7XG4gICAgdGhpcy5pZCA9IHQsIHRoaXMubmF0aXZlT3B0aW9uID0gZSwgdGhpcy5tdWx0aXBsZSA9IGksIHRoaXMudmFsdWUgPSBuLCB0aGlzLmxhYmVsID0gbywgdGhpcy5zZWxlY3RlZCA9IHIsIHRoaXMuZGlzYWJsZWQgPSBhLCB0aGlzLmhpZGRlbiA9IGwsIHRoaXMuc2Vjb25kYXJ5VGV4dCA9IHAsIHRoaXMuZ3JvdXBJZCA9IHUsIHRoaXMuaWNvbiA9IGYsIHRoaXMubm9kZSA9IG51bGwsIHRoaXMuYWN0aXZlID0gITE7XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3RNdWx0aXBsZSgpIDogdGhpcy5fc2VsZWN0U2luZ2xlKCk7XG4gIH1cbiAgX3NlbGVjdFNpbmdsZSgpIHtcbiAgICB0aGlzLnNlbGVjdGVkIHx8ICh0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHVzLCBcIlwiKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCB0aGlzLnNlbGVjdGVkID0gITAsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICEwKSk7XG4gIH1cbiAgX3NlbGVjdE11bHRpcGxlKCkge1xuICAgIGlmICghdGhpcy5zZWxlY3RlZCkge1xuICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgRWEsXG4gICAgICAgIHRoaXMubm9kZVxuICAgICAgKTtcbiAgICAgIHQuY2hlY2tlZCA9ICEwLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHVzLCBcIlwiKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCB0aGlzLnNlbGVjdGVkID0gITAsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICEwKTtcbiAgICB9XG4gIH1cbiAgZGVzZWxlY3QoKSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMuX2Rlc2VsZWN0TXVsdGlwbGUoKSA6IHRoaXMuX2Rlc2VsZWN0U2luZ2xlKCk7XG4gIH1cbiAgX2Rlc2VsZWN0U2luZ2xlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgJiYgKHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUodXMpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHRoaXMuc2VsZWN0ZWQgPSAhMSwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpKTtcbiAgfVxuICBfZGVzZWxlY3RNdWx0aXBsZSgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgRWEsXG4gICAgICAgIHRoaXMubm9kZVxuICAgICAgKTtcbiAgICAgIHQuY2hlY2tlZCA9ICExLCB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHVzKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITEpLCB0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKTtcbiAgICB9XG4gIH1cbiAgc2V0Tm9kZSh0KSB7XG4gICAgdGhpcy5ub2RlID0gdDtcbiAgfVxuICBzZXRBY3RpdmVTdHlsZXMoKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShUYSwgXCJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gITAsIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUodmEsIFwiXCIpO1xuICAgIH1cbiAgfVxuICByZW1vdmVBY3RpdmVTdHlsZXMoKSB7XG4gICAgdGhpcy5hY3RpdmUgJiYgKHRoaXMuYWN0aXZlID0gITEsIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUodmEpKSwgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKFRhKTtcbiAgfVxufVxuY2xhc3MgX20ge1xuICBjb25zdHJ1Y3Rvcih0ID0gITEpIHtcbiAgICB0aGlzLl9tdWx0aXBsZSA9IHQsIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBzZWxlY3QodCkge1xuICAgIHRoaXMuX211bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9ucy5wdXNoKHQpIDogdGhpcy5fc2VsZWN0aW9ucyA9IFt0XTtcbiAgfVxuICBkZXNlbGVjdCh0KSB7XG4gICAgaWYgKHRoaXMuX211bHRpcGxlKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fc2VsZWN0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgIChpKSA9PiB0ID09PSBpXG4gICAgICApO1xuICAgICAgdGhpcy5fc2VsZWN0aW9ucy5zcGxpY2UoZSwgMSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbMF07XG4gIH1cbiAgZ2V0IHNlbGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnM7XG4gIH1cbiAgZ2V0IGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zWzBdICYmIHRoaXMuc2VsZWN0aW9uLmxhYmVsO1xuICB9XG4gIGdldCBsYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnMubWFwKCh0KSA9PiB0LmxhYmVsKS5qb2luKFwiLCBcIik7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnNbMF0gJiYgdGhpcy5zZWxlY3Rpb24udmFsdWU7XG4gIH1cbiAgZ2V0IHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucy5tYXAoKHQpID0+IHQudmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjbyhzKSB7XG4gIHJldHVybiBzLmZpbHRlcigodCkgPT4gIXQuZGlzYWJsZWQpLmV2ZXJ5KCh0KSA9PiB0LnNlbGVjdGVkKTtcbn1cbmNvbnN0IGZtID0gXCJkYXRhLXRlLXNlbGVjdC1mb3JtLW91dGxpbmUtcmVmXCIsIG1tID0gXCJkYXRhLXRlLXNlbGVjdC13cmFwcGVyLXJlZlwiLCBnbSA9IFwiZGF0YS10ZS1zZWxlY3QtaW5wdXQtcmVmXCIsIGJtID0gXCJkYXRhLXRlLXNlbGVjdC1jbGVhci1idG4tcmVmXCIsIHZtID0gXCJkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1jb250YWluZXItcmVmXCIsIFRtID0gXCJkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZcIiwgRW0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbnMtd3JhcHBlci1yZWZcIiwgQ20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbnMtbGlzdC1yZWZcIiwgQW0gPSBcImRhdGEtdGUtc2VsZWN0LWlucHV0LWZpbHRlci1yZWZcIiwgYWMgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZcIiwgeW0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIHdtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tdGV4dC1yZWZcIiwgeG0gPSBcImRhdGEtdGUtZm9ybS1jaGVjay1pbnB1dFwiLCBrbSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLXJlZlwiLCBPbSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLWxhYmVsLXJlZlwiLCBsYyA9IFwiZGF0YS10ZS1zZWxlY3Qtc2VsZWN0ZWRcIiwgU20gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG48L3N2Zz5cbmAsIEltID0gKHMpID0+IHtcbiAgcy5jb2RlID09PSBcIlRhYlwiIHx8IHMuY29kZSA9PT0gXCJFc2NcIiB8fCBzLnByZXZlbnREZWZhdWx0KCk7XG59O1xuZnVuY3Rpb24gcHMocywgdCwgZSwgaSwgbikge1xuICB0LnNlbGVjdFNpemUgPT09IFwiZGVmYXVsdFwiICYmIGMuYWRkQ2xhc3MocywgZSksIHQuc2VsZWN0U2l6ZSA9PT0gXCJzbVwiICYmIGMuYWRkQ2xhc3MocywgaSksIHQuc2VsZWN0U2l6ZSA9PT0gXCJsZ1wiICYmIGMuYWRkQ2xhc3Mocywgbik7XG59XG5mdW5jdGlvbiBEbShzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBuLnNldEF0dHJpYnV0ZShcImlkXCIsIHMpLCBuLnNldEF0dHJpYnV0ZShtbSwgXCJcIik7XG4gIGNvbnN0IG8gPSBEKFwiZGl2XCIpO1xuICBvLnNldEF0dHJpYnV0ZShmbSwgXCJcIiksIGMuYWRkQ2xhc3MobywgaS5mb3JtT3V0bGluZSk7XG4gIGNvbnN0IHIgPSBEKFwiaW5wdXRcIiksIGEgPSB0LnNlbGVjdEZpbHRlciA/IFwiY29tYm9ib3hcIiA6IFwibGlzdGJveFwiLCBsID0gdC5tdWx0aXBsZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBwID0gdC5kaXNhYmxlZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICByLnNldEF0dHJpYnV0ZShnbSwgXCJcIiksIGMuYWRkQ2xhc3MociwgaS5zZWxlY3RJbnB1dCksIHBzKFxuICAgIHIsXG4gICAgdCxcbiAgICBpLnNlbGVjdElucHV0U2l6ZURlZmF1bHQsXG4gICAgaS5zZWxlY3RJbnB1dFNpemVTbSxcbiAgICBpLnNlbGVjdElucHV0U2l6ZUxnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIGMuYWRkQ2xhc3MociwgaS5zZWxlY3RJbnB1dFdoaXRlKSwgci5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIGEpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGwpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgcCksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcInRydWVcIiksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMSksIHQudGFiSW5kZXggJiYgci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCB0LnRhYkluZGV4KSwgdC5kaXNhYmxlZCAmJiByLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0LnNlbGVjdFBsYWNlaG9sZGVyICE9PSBcIlwiICYmIHIuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgdC5zZWxlY3RQbGFjZWhvbGRlciksIHQuc2VsZWN0VmFsaWRhdGlvbiA/IChjLmFkZFN0eWxlKHIsIHtcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwibm9uZVwiLFxuICAgIFwiY2FyZXQtY29sb3JcIjogXCJ0cmFuc3BhcmVudFwiXG4gIH0pLCBjLmFkZFN0eWxlKG8sIHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9KSkgOiByLnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwidHJ1ZVwiKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChyLnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIFwidHJ1ZVwiKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIFwidHJ1ZVwiKSwgci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBJbSkpO1xuICBjb25zdCB1ID0gRChcImRpdlwiKTtcbiAgYy5hZGRDbGFzcyh1LCBpLnNlbGVjdFZhbGlkYXRpb25WYWxpZCk7XG4gIGNvbnN0IGYgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICBgJHt0LnNlbGVjdFZhbGlkRmVlZGJhY2t9YFxuICApO1xuICB1LmFwcGVuZENoaWxkKGYpO1xuICBjb25zdCBfID0gRChcImRpdlwiKTtcbiAgYy5hZGRDbGFzcyhfLCBpLnNlbGVjdFZhbGlkYXRpb25JbnZhbGlkKTtcbiAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGAke3Quc2VsZWN0SW52YWxpZEZlZWRiYWNrfWBcbiAgKTtcbiAgXy5hcHBlbmRDaGlsZChtKTtcbiAgY29uc3QgZyA9IEQoXCJzcGFuXCIpO1xuICBnLnNldEF0dHJpYnV0ZShibSwgXCJcIiksIGMuYWRkQ2xhc3MoZywgaS5zZWxlY3RDbGVhckJ0biksIHBzKFxuICAgIGcsXG4gICAgdCxcbiAgICBpLnNlbGVjdENsZWFyQnRuRGVmYXVsdCxcbiAgICBpLnNlbGVjdENsZWFyQnRuU20sXG4gICAgaS5zZWxlY3RDbGVhckJ0bkxnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIGMuYWRkQ2xhc3MoZywgaS5zZWxlY3RDbGVhckJ0bldoaXRlKTtcbiAgY29uc3QgdiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwi4pyVXCIpO1xuICBnLmFwcGVuZENoaWxkKHYpLCBnLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgY29uc3QgYiA9IEQoXCJzcGFuXCIpO1xuICByZXR1cm4gYy5hZGRDbGFzcyhiLCBpLnNlbGVjdEFycm93KSwgcHMoXG4gICAgYixcbiAgICB0LFxuICAgIGkuc2VsZWN0QXJyb3dEZWZhdWx0LFxuICAgIGkuc2VsZWN0QXJyb3dTbSxcbiAgICBpLnNlbGVjdEFycm93TGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgYy5hZGRDbGFzcyhiLCBpLnNlbGVjdEFycm93V2hpdGUpLCBiLmlubmVySFRNTCA9IFNtLCBvLmFwcGVuZENoaWxkKHIpLCBlICYmIChjLmFkZENsYXNzKGUsIGkuc2VsZWN0TGFiZWwpLCBwcyhcbiAgICBlLFxuICAgIHQsXG4gICAgaS5zZWxlY3RMYWJlbFNpemVEZWZhdWx0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplU20sXG4gICAgaS5zZWxlY3RMYWJlbFNpemVMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBjLmFkZENsYXNzKGUsIGkuc2VsZWN0TGFiZWxXaGl0ZSksIG8uYXBwZW5kQ2hpbGQoZSkpLCB0LnNlbGVjdFZhbGlkYXRpb24gJiYgKG8uYXBwZW5kQ2hpbGQodSksIG8uYXBwZW5kQ2hpbGQoXykpLCB0LnNlbGVjdENsZWFyQnV0dG9uICYmIG8uYXBwZW5kQ2hpbGQoZyksIG8uYXBwZW5kQ2hpbGQoYiksIG4uYXBwZW5kQ2hpbGQobyksIG47XG59XG5mdW5jdGlvbiBBYShzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBsLnNldEF0dHJpYnV0ZSh2bSwgXCJcIiksIGMuYWRkQ2xhc3MobCwgYS5zZWxlY3REcm9wZG93bkNvbnRhaW5lciksIGwuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7c31gKSwgbC5zdHlsZS53aWR0aCA9IGAke2V9cHhgO1xuICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgcC5zZXRBdHRyaWJ1dGUoVG0sIFwiXCIpLCBjLmFkZENsYXNzKHAsIGEuZHJvcGRvd24pO1xuICBjb25zdCB1ID0gRChcImRpdlwiKTtcbiAgdS5zZXRBdHRyaWJ1dGUoRW0sIFwiXCIpLCBjLmFkZENsYXNzKHUsIGEub3B0aW9uc1dyYXBwZXIpLCBjLmFkZENsYXNzKHUsIGEub3B0aW9uc1dyYXBwZXJTY3JvbGxiYXIpLCB1LnN0eWxlLm1heEhlaWdodCA9IGAke2l9cHhgO1xuICBjb25zdCBmID0gY2MoXG4gICAgbyxcbiAgICBuLFxuICAgIHQsXG4gICAgYVxuICApO1xuICByZXR1cm4gdS5hcHBlbmRDaGlsZChmKSwgdC5zZWxlY3RGaWx0ZXIgJiYgcC5hcHBlbmRDaGlsZChcbiAgICAkbSh0LnNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyLCBhKVxuICApLCBwLmFwcGVuZENoaWxkKHUpLCByICYmIHAuYXBwZW5kQ2hpbGQociksIGwuYXBwZW5kQ2hpbGQocCksIGw7XG59XG5mdW5jdGlvbiBjYyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBEKFwiZGl2XCIpO1xuICBuLnNldEF0dHJpYnV0ZShDbSwgXCJcIiksIGMuYWRkQ2xhc3MobiwgaS5vcHRpb25zTGlzdCk7XG4gIGxldCBvO1xuICByZXR1cm4gZS5tdWx0aXBsZSA/IG8gPSBNbShcbiAgICBzLFxuICAgIHQsXG4gICAgZSxcbiAgICBpXG4gICkgOiBvID0gTG0ocywgZSwgaSksIG8uZm9yRWFjaCgocikgPT4ge1xuICAgIG4uYXBwZW5kQ2hpbGQocik7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gJG0ocywgdCkge1xuICBjb25zdCBlID0gRChcImRpdlwiKTtcbiAgYy5hZGRDbGFzcyhlLCB0LmlucHV0R3JvdXApO1xuICBjb25zdCBpID0gRChcImlucHV0XCIpO1xuICByZXR1cm4gaS5zZXRBdHRyaWJ1dGUoQW0sIFwiXCIpLCBjLmFkZENsYXNzKGksIHQuc2VsZWN0RmlsdGVySW5wdXQpLCBpLnBsYWNlaG9sZGVyID0gcywgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2VhcmNoYm94XCIpLCBpLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gTG0ocywgdCwgZSkge1xuICByZXR1cm4gaGMocywgdCwgZSk7XG59XG5mdW5jdGlvbiBNbShzLCB0LCBlLCBpKSB7XG4gIGxldCBuID0gbnVsbDtcbiAgZS5zZWxlY3RBbGwgJiYgKG4gPSBObShcbiAgICB0LFxuICAgIHMsXG4gICAgZSxcbiAgICBpXG4gICkpO1xuICBjb25zdCBvID0gaGMocywgZSwgaSk7XG4gIHJldHVybiBuID8gW24sIC4uLm9dIDogbztcbn1cbmZ1bmN0aW9uIGhjKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdO1xuICByZXR1cm4gcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIG4sXG4gICAgICBcIm9wdGlvbnNcIlxuICAgICkpIHtcbiAgICAgIGNvbnN0IHIgPSBIbShuLCB0LCBlKTtcbiAgICAgIGkucHVzaChyKTtcbiAgICB9IGVsc2VcbiAgICAgIGkucHVzaChkYyhuLCB0LCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gTm0ocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gY28odCksIG8gPSBEKFwiZGl2XCIpO1xuICByZXR1cm4gby5zZXRBdHRyaWJ1dGUoYWMsIFwiXCIpLCBjLmFkZENsYXNzKG8sIGkuc2VsZWN0T3B0aW9uKSwgby5zZXRBdHRyaWJ1dGUoeW0sIFwiXCIpLCBjLmFkZFN0eWxlKG8sIHtcbiAgICBoZWlnaHQ6IGAke2Uuc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YFxuICB9KSwgby5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpLCBvLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgbiksIG4gJiYgby5zZXRBdHRyaWJ1dGUobGMsIFwiXCIpLCBvLmFwcGVuZENoaWxkKHVjKHMsIGUsIGkpKSwgcy5zZXROb2RlKG8pLCBvO1xufVxuZnVuY3Rpb24gZGMocywgdCwgZSkge1xuICBpZiAocy5ub2RlKVxuICAgIHJldHVybiBzLm5vZGU7XG4gIGNvbnN0IGkgPSBEKFwiZGl2XCIpO1xuICByZXR1cm4gaS5zZXRBdHRyaWJ1dGUoYWMsIFwiXCIpLCBjLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uKSwgYy5hZGRTdHlsZShpLCB7XG4gICAgaGVpZ2h0OiBgJHt0LnNlbGVjdE9wdGlvbkhlaWdodH1weGBcbiAgfSksIGMuc2V0RGF0YUF0dHJpYnV0ZShpLCBcImlkXCIsIHMuaWQpLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIiksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBzLnNlbGVjdGVkKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIHMuZGlzYWJsZWQpLCBzLnNlbGVjdGVkICYmIGkuc2V0QXR0cmlidXRlKGxjLCBcIlwiKSwgcy5kaXNhYmxlZCAmJiBpLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZFwiLCAhMCksIHMuaGlkZGVuICYmIGMuYWRkQ2xhc3MoaSwgXCJoaWRkZW5cIiksIGkuYXBwZW5kQ2hpbGQodWMocywgdCwgZSkpLCBzLmljb24gJiYgaS5hcHBlbmRDaGlsZChCbShzLCBlKSksIHMuc2V0Tm9kZShpKSwgaTtcbn1cbmZ1bmN0aW9uIHVjKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IEQoXCJzcGFuXCIpO1xuICBpLnNldEF0dHJpYnV0ZSh3bSwgXCJcIiksIGMuYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb25UZXh0KTtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMubGFiZWwpO1xuICByZXR1cm4gdC5tdWx0aXBsZSAmJiBpLmFwcGVuZENoaWxkKFBtKHMsIGUpKSwgaS5hcHBlbmRDaGlsZChuKSwgKHMuc2Vjb25kYXJ5VGV4dCB8fCB0eXBlb2Ygcy5zZWNvbmRhcnlUZXh0ID09IFwibnVtYmVyXCIpICYmIGkuYXBwZW5kQ2hpbGQoXG4gICAgUm0ocy5zZWNvbmRhcnlUZXh0LCBlKVxuICApLCBpO1xufVxuZnVuY3Rpb24gUm0ocywgdCkge1xuICBjb25zdCBlID0gRChcInNwYW5cIik7XG4gIGMuYWRkQ2xhc3MoZSwgdC5zZWxlY3RPcHRpb25TZWNvbmRhcnlUZXh0KTtcbiAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpO1xuICByZXR1cm4gZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIFBtKHMsIHQpIHtcbiAgY29uc3QgZSA9IEQoXCJpbnB1dFwiKTtcbiAgZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiY2hlY2tib3hcIiksIGMuYWRkQ2xhc3MoZSwgdC5mb3JtQ2hlY2tJbnB1dCksIGUuc2V0QXR0cmlidXRlKHhtLCBcIlwiKTtcbiAgY29uc3QgaSA9IEQoXCJsYWJlbFwiKTtcbiAgcmV0dXJuIHMuc2VsZWN0ZWQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsICEwKSwgcy5kaXNhYmxlZCAmJiBlLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsICEwKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIEJtKHMsIHQpIHtcbiAgY29uc3QgZSA9IEQoXCJzcGFuXCIpLCBpID0gRChcImltZ1wiKTtcbiAgcmV0dXJuIGMuYWRkQ2xhc3MoaSwgdC5zZWxlY3RPcHRpb25JY29uKSwgaS5zcmMgPSBzLmljb24sIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBIbShzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBEKFwiZGl2XCIpO1xuICBpLnNldEF0dHJpYnV0ZShrbSwgXCJcIiksIGMuYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb25Hcm91cCksIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImdyb3VwXCIpLCBpLnNldEF0dHJpYnV0ZShcImlkXCIsIHMuaWQpLCBzLmhpZGRlbiAmJiBjLmFkZENsYXNzKGksIFwiaGlkZGVuXCIpO1xuICBjb25zdCBuID0gRChcImxhYmVsXCIpO1xuICByZXR1cm4gbi5zZXRBdHRyaWJ1dGUoT20sIFwiXCIpLCBjLmFkZENsYXNzKG4sIGUuc2VsZWN0T3B0aW9uR3JvdXBMYWJlbCksIGMuYWRkU3R5bGUobiwgeyBoZWlnaHQ6IGAke3Quc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YCB9KSwgbi5zZXRBdHRyaWJ1dGUoXCJmb3JcIiwgcy5pZCksIG4udGV4dENvbnRlbnQgPSBzLmxhYmVsLCBpLmFwcGVuZENoaWxkKG4pLCBzLm9wdGlvbnMuZm9yRWFjaCgobykgPT4ge1xuICAgIGkuYXBwZW5kQ2hpbGQoZGMobywgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFdtKHMsIHQpIHtcbiAgY29uc3QgZSA9IEQoXCJkaXZcIik7XG4gIHJldHVybiBlLmlubmVySFRNTCA9IHMsIGMuYWRkQ2xhc3MoZSwgdC5zZWxlY3RMYWJlbCksIGMuYWRkQ2xhc3MoZSwgdC5zZWxlY3RGYWtlVmFsdWUpLCBlO1xufVxuY29uc3QgUG4gPSBcInNlbGVjdFwiLCBmaSA9IFwidGUuc2VsZWN0XCIsIE5pID0gYC4ke2ZpfWAsIFZtID0gYGNsb3NlJHtOaX1gLCBGbSA9IGBvcGVuJHtOaX1gLCB5YSA9IGBvcHRpb25TZWxlY3Qke05pfWAsIHdhID0gYG9wdGlvbkRlc2VsZWN0JHtOaX1gLCBZbSA9IGB2YWx1ZUNoYW5nZSR7Tml9YCwgam0gPSBcImNoYW5nZVwiLCB4YSA9IFwiZGF0YS10ZS1zZWxlY3QtaW5pdFwiLCBwYyA9IFwiZGF0YS10ZS1zZWxlY3Qtbm8tcmVzdWx0cy1yZWZcIiwga2EgPSBcImRhdGEtdGUtc2VsZWN0LW9wZW5cIiwgcSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgS3QgPSBcImRhdGEtdGUtaW5wdXQtZm9jdXNlZFwiLCBCbiA9IFwiZGF0YS10ZS1pbnB1dC1kaXNhYmxlZFwiLCBLbSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLWxhYmVsLXJlZlwiLCB6bSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWFsbC1yZWZcIiwgY2kgPSBcImRhdGEtdGUtc2VsZWN0LXNlbGVjdGVkXCIsIFVtID0gXCJbZGF0YS10ZS1zZWxlY3QtbGFiZWwtcmVmXVwiLCBPYSA9IFwiW2RhdGEtdGUtc2VsZWN0LWlucHV0LXJlZl1cIiwgWG0gPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1maWx0ZXItcmVmXVwiLCBHbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLXJlZl1cIiwgcW0gPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLXdyYXBwZXItcmVmXVwiLCBTYSA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbnMtbGlzdC1yZWZdXCIsIFptID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXJlZl1cIiwgUW0gPSBcIltkYXRhLXRlLXNlbGVjdC1jbGVhci1idG4tcmVmXVwiLCBKbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWN1c3RvbS1jb250ZW50LXJlZl1cIiwgdGcgPSBgWyR7cGN9XWAsIElhID0gXCJbZGF0YS10ZS1zZWxlY3QtZm9ybS1vdXRsaW5lLXJlZl1cIiwgZWcgPSBcIltkYXRhLXRlLXNlbGVjdC10b2dnbGVdXCIsIEhuID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdXCIsIGlnID0gMjAwLCBzZyA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogITEsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJib2R5XCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiAhMSxcbiAgZGlzYWJsZWQ6ICExLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IDUsXG4gIHNlbGVjdEZvcm1XaGl0ZTogITEsXG4gIG11bHRpcGxlOiAhMSxcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwib3B0aW9ucyBzZWxlY3RlZFwiLFxuICBzZWxlY3RPcHRpb25IZWlnaHQ6IDM4LFxuICBzZWxlY3RBbGw6ICEwLFxuICBzZWxlY3RBbGxMYWJlbDogXCJTZWxlY3QgYWxsXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcIlNlYXJjaC4uLlwiLFxuICBzZWxlY3RTaXplOiBcImRlZmF1bHRcIixcbiAgc2VsZWN0VmlzaWJsZU9wdGlvbnM6IDUsXG4gIHNlbGVjdEZpbHRlcjogITEsXG4gIHNlbGVjdEZpbHRlckRlYm91bmNlOiAzMDAsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJObyByZXN1bHRzXCIsXG4gIHNlbGVjdFZhbGlkYXRpb246ICExLFxuICBzZWxlY3RWYWxpZEZlZWRiYWNrOiBcIlZhbGlkXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJJbnZhbGlkXCIsXG4gIHNlbGVjdFBsYWNlaG9sZGVyOiBcIlwiXG59LCBuZyA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogXCJib29sZWFuXCIsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIHNlbGVjdERpc3BsYXllZExhYmVsczogXCJudW1iZXJcIixcbiAgc2VsZWN0Rm9ybVdoaXRlOiBcImJvb2xlYW5cIixcbiAgbXVsdGlwbGU6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiBcIm51bWJlclwiLFxuICBzZWxlY3RBbGw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RBbGxMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNpemU6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiBcIm51bWJlclwiLFxuICBzZWxlY3RGaWx0ZXI6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogXCJudW1iZXJcIixcbiAgc2VsZWN0Tm9SZXN1bHRUZXh0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJzdHJpbmdcIlxufSwgb2cgPSB7XG4gIGRyb3Bkb3duOiBcInJlbGF0aXZlIG91dGxpbmUtbm9uZSBtaW4tdy1bMTAwcHhdIG0tMCBzY2FsZS1bMC44XSBvcGFjaXR5LTAgYmctd2hpdGUgc2hhZG93LVswXzJweF81cHhfMF9yZ2JhKDAsMCwwLDAuMTYpLF8wXzJweF8xMHB4XzBfcmdiYSgwLDAsMCwwLjEyKV0gdHJhbnNpdGlvbiBkdXJhdGlvbi0yMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGF0YS1bdGUtc2VsZWN0LW9wZW5dOnNjYWxlLTEwMCBkYXRhLVt0ZS1zZWxlY3Qtb3Blbl06b3BhY2l0eS0xMDAgZGFyazpiZy16aW5jLTcwMFwiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJyZWxhdGl2ZSBmbG9hdC1sZWZ0IG10LVswLjE1cmVtXSBtci1bOHB4XSBoLVsxLjEyNXJlbV0gdy1bMS4xMjVyZW1dIGFwcGVhcmFuY2Utbm9uZSByb3VuZGVkLVswLjI1cmVtXSBib3JkZXItWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIG91dGxpbmUtbm9uZSBiZWZvcmU6cG9pbnRlci1ldmVudHMtbm9uZSBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzAuODc1cmVtXSBiZWZvcmU6dy1bMC44NzVyZW1dIGJlZm9yZTpzY2FsZS0wIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLXRyYW5zcGFyZW50IGJlZm9yZTpvcGFjaXR5LTAgYmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF90cmFuc3BhcmVudF0gYmVmb3JlOmNvbnRlbnQtWycnXSBjaGVja2VkOmJvcmRlci1wcmltYXJ5IGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBjaGVja2VkOmJnLXByaW1hcnkgZGFyazpjaGVja2VkOmJnLXByaW1hcnkgY2hlY2tlZDpiZWZvcmU6b3BhY2l0eS1bMC4xNl0gY2hlY2tlZDphZnRlcjphYnNvbHV0ZSBjaGVja2VkOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmFmdGVyOi1tdC1weCBjaGVja2VkOmFmdGVyOmJsb2NrIGNoZWNrZWQ6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDphZnRlcjpiZy10cmFuc3BhcmVudCBjaGVja2VkOmFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBob3ZlcjpiZWZvcmU6b3BhY2l0eS1bMC4wNF0gaG92ZXI6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOnNoYWRvdy1ub25lIGZvY3VzOnRyYW5zaXRpb24tW2JvcmRlci1jb2xvcl8wLjJzXSBmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGZvY3VzOmJlZm9yZTpvcGFjaXR5LVswLjEyXSBmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZGFyazpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMjU1LDI1NSwyNTUsMC40KV0gZm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gZm9jdXM6YWZ0ZXI6YWJzb2x1dGUgZm9jdXM6YWZ0ZXI6ei1bMV0gZm9jdXM6YWZ0ZXI6YmxvY2sgZm9jdXM6YWZ0ZXI6aC1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnctWzAuODc1cmVtXSBmb2N1czphZnRlcjpyb3VuZGVkLVswLjEyNXJlbV0gZm9jdXM6YWZ0ZXI6Y29udGVudC1bJyddIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gZGFyazpjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gY2hlY2tlZDpmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBjaGVja2VkOmZvY3VzOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOi1tdC1weCBjaGVja2VkOmZvY3VzOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDpmb2N1czphZnRlcjpyb3VuZGVkLW5vbmUgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6YmctdHJhbnNwYXJlbnRcIixcbiAgZm9ybU91dGxpbmU6IFwicmVsYXRpdmVcIixcbiAgaW5pdGlhbGl6ZWQ6IFwiaGlkZGVuXCIsXG4gIGlucHV0R3JvdXA6IFwiZmxleCBpdGVtcy1jZW50ZXIgd2hpdGVzcGFjZS1ub3dyYXAgcC0yLjUgdGV4dC1jZW50ZXIgdGV4dC1iYXNlIGZvbnQtbm9ybWFsIGxlYWRpbmctWzEuNl0gdGV4dC1ncmF5LTcwMCBkYXJrOmJnLXppbmMtODAwIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDBcIixcbiAgbm9SZXN1bHQ6IFwiZmxleCBpdGVtcy1jZW50ZXIgcHgtNFwiLFxuICBvcHRpb25zTGlzdDogXCJsaXN0LW5vbmUgbS0wIHAtMFwiLFxuICBvcHRpb25zV3JhcHBlcjogXCJvdmVyZmxvdy15LWF1dG9cIixcbiAgb3B0aW9uc1dyYXBwZXJTY3JvbGxiYXI6IFwiWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTp3LTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTpoLTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmxvY2sgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06aC0wIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLW5vbmUgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTogWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLWwgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpoLVs1MHB4XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmJnLVsjOTk5XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOnJvdW5kZWRcIixcbiAgc2VsZWN0QXJyb3c6IFwiYWJzb2x1dGUgcmlnaHQtMyB0ZXh0LVswLjhyZW1dIGN1cnNvci1wb2ludGVyIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06dGV4dC1wcmltYXJ5IGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci12YWxpZDp0ZXh0LWdyZWVuLTYwMCBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItaW52YWxpZDp0ZXh0LVtyZ2IoMjIwLDc2LDEwMCldIHctNSBoLTVcIixcbiAgc2VsZWN0QXJyb3dXaGl0ZTogXCJ0ZXh0LWdyYXktNTAgcGVlci1mb2N1czohdGV4dC13aGl0ZSBwZWVyLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOiF0ZXh0LXdoaXRlXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJ0b3AtMlwiLFxuICBzZWxlY3RBcnJvd0xnOiBcInRvcC1bMTNweF1cIixcbiAgc2VsZWN0QXJyb3dTbTogXCJ0b3AtMVwiLFxuICBzZWxlY3RDbGVhckJ0bjogXCJhYnNvbHV0ZSB0b3AtMiByaWdodC05IHRleHQtYmxhY2sgY3Vyc29yLXBvaW50ZXIgZm9jdXM6dGV4dC1wcmltYXJ5IG91dGxpbmUtbm9uZSBkYXJrOnRleHQtZ3JheS0yMDBcIixcbiAgc2VsZWN0Q2xlYXJCdG5XaGl0ZTogXCIhdGV4dC1ncmF5LTUwXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJ0b3AtMiB0ZXh0LWJhc2VcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJ0b3AtWzExcHhdIHRleHQtYmFzZVwiLFxuICBzZWxlY3RDbGVhckJ0blNtOiBcInRvcC0xIHRleHQtWzAuOHJlbV1cIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwiei1bMTA3MF1cIixcbiAgc2VsZWN0RmFrZVZhbHVlOiBcInRyYW5zZm9ybS1ub25lIGhpZGRlbiBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJsb2NrXCIsXG4gIHNlbGVjdEZpbHRlcklucHV0OiBcInJlbGF0aXZlIG0tMCBibG9jayB3LWZ1bGwgbWluLXctMCBmbGV4LWF1dG8gcm91bmRlZCBib3JkZXIgYm9yZGVyLXNvbGlkIGJvcmRlci1ncmF5LTMwMCBiZy10cmFuc3BhcmVudCBiZy1jbGlwLXBhZGRpbmcgcHgtMyBweS0xLjUgdGV4dC1iYXNlIGZvbnQtbm9ybWFsIHRleHQtZ3JheS03MDAgdHJhbnNpdGlvbiBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZm9jdXM6Ym9yZGVyLXByaW1hcnkgZm9jdXM6dGV4dC1ncmF5LTcwMCBmb2N1czpzaGFkb3ctdGUtcHJpbWFyeSBmb2N1czpvdXRsaW5lLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMFwiLFxuICBzZWxlY3RJbnB1dDogXCJwZWVyIGJsb2NrIG1pbi1oLVthdXRvXSB3LWZ1bGwgcm91bmRlZCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIGZvY3VzOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMCBbJjpub3QoW2RhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXSldOnBsYWNlaG9sZGVyOm9wYWNpdHktMCBjdXJzb3ItcG9pbnRlciBkYXRhLVt0ZS1pbnB1dC1kaXNhYmxlZF06YmctWyNlOWVjZWZdIGRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOm1iLTQgZGFyazpkYXRhLVt0ZS1pbnB1dC1kaXNhYmxlZF06YmctemluYy02MDBcIixcbiAgc2VsZWN0SW5wdXRXaGl0ZTogXCIhdGV4dC1ncmF5LTUwXCIsXG4gIHNlbGVjdElucHV0U2l6ZURlZmF1bHQ6IFwicHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMS42XVwiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsyLjE1XVwiLFxuICBzZWxlY3RJbnB1dFNpemVTbTogXCJweS1bMC4zM3JlbV0gcHgtMyB0ZXh0LXhzIGxlYWRpbmctWzEuNV1cIixcbiAgc2VsZWN0TGFiZWw6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTMgbWItMCBtYXgtdy1bOTAlXSBvcmlnaW4tWzBfMF0gdHJ1bmNhdGUgdGV4dC1ncmF5LTUwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1vdXQgcGVlci1mb2N1czpzY2FsZS1bMC44XSBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06c2NhbGUtWzAuOF0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGVlci1mb2N1czp0ZXh0LWdyYXktMjAwIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06c2NhbGUtWzAuOF0gZGFyazpwZWVyLWZvY3VzOnRleHQtcHJpbWFyeVwiLFxuICBzZWxlY3RMYWJlbFdoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0TGFiZWxTaXplRGVmYXVsdDogXCJwdC1bMC4zN3JlbV0gbGVhZGluZy1bMS42XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC45cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dXCIsXG4gIHNlbGVjdExhYmVsU2l6ZUxnOiBcInB0LVswLjM3cmVtXSBsZWFkaW5nLVsyLjE1XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMS4xNXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMS4xNXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzEuMTVyZW1dXCIsXG4gIHNlbGVjdExhYmVsU2l6ZVNtOiBcInB0LVswLjM3cmVtXSB0ZXh0LXhzIGxlYWRpbmctWzEuNV0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuNzVyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuNzVyZW1dIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjc1cmVtXVwiLFxuICBzZWxlY3RPcHRpb246IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHctZnVsbCBweC00IHRydW5jYXRlIHRleHQtZ3JheS03MDAgYmctdHJhbnNwYXJlbnQgc2VsZWN0LW5vbmUgY3Vyc29yLXBvaW50ZXIgZGF0YS1bdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXTpiZy1ibGFjay81IGhvdmVyOlsmOm5vdChbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXSldOmJnLWJsYWNrLzUgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy1ibGFjay81IGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmctYmxhY2svNSBkYXRhLVt0ZS1zZWxlY3Qtc2VsZWN0ZWRdOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06dGV4dC1ncmF5LTQwMCBkYXRhLVt0ZS1zZWxlY3Qtc2VsZWN0ZWRdOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOmJnLXRyYW5zcGFyZW50IGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmJnLWJsYWNrL1swLjAyXSBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGdyb3VwLWRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZ3JvdXAtcmVmXS9vcHQ6cGwtNyBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpob3ZlcjpbJjpub3QoW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF0pXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06dGV4dC1ncmF5LTQwMCBkYXJrOmRhdGEtW3RlLWlucHV0LW11bHRpcGxlLWFjdGl2ZV06Ymctd2hpdGUvMzBcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXA6IFwiZ3JvdXAvb3B0XCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwTGFiZWw6IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIgdy1mdWxsIHB4LTQgdHJ1bmNhdGUgYmctdHJhbnNwYXJlbnQgdGV4dC1ibGFjay81MCBzZWxlY3Qtbm9uZSBkYXJrOnRleHQtZ3JheS0zMDBcIixcbiAgc2VsZWN0T3B0aW9uSWNvbjogXCJ3LTcgaC03IHJvdW5kZWQtZnVsbFwiLFxuICBzZWxlY3RPcHRpb25TZWNvbmRhcnlUZXh0OiBcImJsb2NrIHRleHQtWzAuOHJlbV0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS0zMDBcIixcbiAgc2VsZWN0T3B0aW9uVGV4dDogXCJncm91cFwiLFxuICBzZWxlY3RWYWxpZGF0aW9uVmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtZ3JlZW4tNjAwIGN1cnNvci1wb2ludGVyIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci12YWxpZDpibG9ja1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uSW52YWxpZDogXCJoaWRkZW4gYWJzb2x1dGUgLW10LTMgdy1hdXRvIHRleHQtc20gdGV4dC1bcmdiKDIyMCw3NiwxMDApXSBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItaW52YWxpZDpibG9ja1wiXG59LCByZyA9IHtcbiAgZHJvcGRvd246IFwic3RyaW5nXCIsXG4gIGZvcm1DaGVja0lucHV0OiBcInN0cmluZ1wiLFxuICBmb3JtT3V0bGluZTogXCJzdHJpbmdcIixcbiAgaW5pdGlhbGl6ZWQ6IFwic3RyaW5nXCIsXG4gIGlucHV0R3JvdXA6IFwic3RyaW5nXCIsXG4gIG5vUmVzdWx0OiBcInN0cmluZ1wiLFxuICBvcHRpb25zTGlzdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RBcnJvdzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RBcnJvd0xnOiBcInN0cmluZ1wiLFxuICBzZWxlY3RBcnJvd1NtOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ0bjogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5EZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ0bkxnOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ0blNtOiBcInN0cmluZ1wiLFxuICBzZWxlY3REcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmFrZVZhbHVlOiBcInN0cmluZ1wiLFxuICBzZWxlY3RGaWx0ZXJJbnB1dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0U2l6ZURlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0U2l6ZUxnOiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsU2l6ZURlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsU2l6ZUxnOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25Hcm91cDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXBMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSWNvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uVGV4dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzICRvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jb25maWcuc2VsZWN0UGxhY2Vob2xkZXIgJiYgIXRoaXMuX2NvbmZpZy5tdWx0aXBsZSAmJiB0aGlzLl9hZGRQbGFjZWhvbGRlck9wdGlvbigpLCB0aGlzLl9vcHRpb25zVG9SZW5kZXIgPSB0aGlzLl9nZXRPcHRpb25zVG9SZW5kZXIodCksIHRoaXMuX3BsYWluT3B0aW9ucyA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gbnVsbCwgdGhpcy5fc2VsZWN0aW9uTW9kZWwgPSBuZXcgX20odGhpcy5tdWx0aXBsZSksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEsIHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX3dyYXBwZXJJZCA9IGJ0KFwic2VsZWN0LXdyYXBwZXItXCIpLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkID0gYnQoXCJzZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLVwiKSwgdGhpcy5fc2VsZWN0QWxsSWQgPSBidChcInNlbGVjdC1hbGwtXCIpLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0ID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCAqIHRoaXMuX2NvbmZpZy5zZWxlY3RWaXNpYmxlT3B0aW9ucywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW5wdXQgPSBudWxsLCB0aGlzLl9sYWJlbCA9IGQubmV4dCh0aGlzLl9lbGVtZW50LCBVbSlbMF0sIHRoaXMuX25vdGNoID0gbnVsbCwgdGhpcy5fZmFrZVZhbHVlID0gbnVsbCwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMSwgdGhpcy5fY3VzdG9tQ29udGVudCA9IGQubmV4dChcbiAgICAgIHQsXG4gICAgICBKbVxuICAgIClbMF0sIHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnRUb2dnbGUgPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5faW5wdXRFbCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbnVsbCwgdGhpcy5fY29udGFpbmVyID0gbnVsbCwgdGhpcy5fc2VsZWN0QWxsT3B0aW9uID0gbnVsbCwgdGhpcy5faW5pdCgpLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX2FkZE11dGF0aW9uT2JzZXJ2ZXIoKSwgdGhpcy5fZWxlbWVudCAmJiBJLnNldERhdGEodCwgZmksIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUG47XG4gIH1cbiAgZ2V0IGZpbHRlcklucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBYbSxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgZHJvcGRvd24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShHbSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGdldCBvcHRpb25zTGlzdCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgU2EsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnNXcmFwcGVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBxbSxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgY2xlYXJCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShRbSwgdGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPyB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0IDogdGhpcy5fcGxhaW5PcHRpb25zO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlcyA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlO1xuICB9XG4gIGdldCBtdWx0aXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm11bHRpcGxlO1xuICB9XG4gIGdldCBoYXNTZWxlY3RBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5fY29uZmlnLnNlbGVjdEFsbDtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiAwO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uc2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikgJiYgKHQubXVsdGlwbGUgPSAhMCksIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgKHQuZGlzYWJsZWQgPSAhMCksIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggJiYgKHQudGFiSW5kZXggPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYkluZGV4XCIpKSwgTChQbiwgdCwgbmcpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ub2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoUG4sIHQsIHJnKSwgdDtcbiAgfVxuICBfYWRkUGxhY2Vob2xkZXJPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IG5ldyBPcHRpb24oXCJcIiwgXCJcIiwgITAsICEwKTtcbiAgICB0LmhpZGRlbiA9ICEwLCB0LnNlbGVjdGVkID0gITAsIHRoaXMuX2VsZW1lbnQucHJlcGVuZCh0KTtcbiAgfVxuICBfZ2V0T3B0aW9uc1RvUmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHQuY2hpbGROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBpZiAobi5ub2RlTmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgICAgaWQ6IGJ0KFwiZ3JvdXAtXCIpLFxuICAgICAgICAgIGxhYmVsOiBuLmxhYmVsLFxuICAgICAgICAgIGRpc2FibGVkOiBuLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpLFxuICAgICAgICAgIGhpZGRlbjogbi5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIiksXG4gICAgICAgICAgb3B0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICBhLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIG8ub3B0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KGEsIG8pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksIGUucHVzaChvKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIGUucHVzaCh0aGlzLl9jcmVhdGVPcHRpb25PYmplY3QobikpO1xuICAgIH0pLCBlO1xuICB9XG4gIF9nZXRQbGFpbk9wdGlvbnModCkge1xuICAgIGlmICghZC5maW5kT25lKFwib3B0Z3JvdXBcIiwgdGhpcy5fZWxlbWVudCkpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBpID0gW107XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICBuLFxuICAgICAgICBcIm9wdGlvbnNcIlxuICAgICAgKSA/IG4ub3B0aW9ucy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGkucHVzaChyKTtcbiAgICAgIH0pIDogaS5wdXNoKG4pO1xuICAgIH0pLCBpO1xuICB9XG4gIF9jcmVhdGVPcHRpb25PYmplY3QodCwgZSA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGJ0KFwib3B0aW9uLVwiKSwgbiA9IGUuaWQgPyBlLmlkIDogbnVsbCwgbyA9IGUuZGlzYWJsZWQgPyBlLmRpc2FibGVkIDogITEsIHIgPSB0LnNlbGVjdGVkIHx8IHQuaGFzQXR0cmlidXRlKGNpKSwgYSA9IHQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfHwgbywgbCA9IHQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpIHx8IGUgJiYgZS5oaWRkZW4sIHAgPSB0aGlzLm11bHRpcGxlLCB1ID0gdC52YWx1ZSwgZiA9IHQubGFiZWwsIF8gPSBjLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0LFxuICAgICAgXCJzZWxlY3RTZWNvbmRhcnlUZXh0XCJcbiAgICApLCBtID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwic2VsZWN0LWljb25cIik7XG4gICAgcmV0dXJuIG5ldyBDYShcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBmLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgXyxcbiAgICAgIG4sXG4gICAgICBtXG4gICAgKTtcbiAgfVxuICBfZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKGUpID0+ICFlLmhpZGRlbik7XG4gICAgcmV0dXJuIHRoaXMuaGFzU2VsZWN0QWxsID8gW3RoaXMuX3NlbGVjdEFsbE9wdGlvbiwgLi4udF0gOiB0O1xuICB9XG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGAjJHt0aGlzLl93cmFwcGVySWR9YCksIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKE9hLCB0aGlzLl93cmFwcGVyKSwgdGhpcy5fY29uZmlnLmRpc2FibGVkICYmIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShCbiwgXCJcIik7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RDb250YWluZXI7XG4gICAgdCA9PT0gXCJib2R5XCIgPyB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5ib2R5IDogdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHQpLCB0aGlzLl9pbml0T3V0bGluZUlucHV0KCksIHRoaXMuX3NldERlZmF1bHRTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fYXBwZW5kRmFrZVZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2JpbmRDb21wb25lbnRFdmVudHMoKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IHRoaXMuX2NyZWF0ZVNlbGVjdEFsbE9wdGlvbigpKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSBBYShcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCk7XG4gIH1cbiAgX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpIHtcbiAgICBjb25zdCB0ID0gRG0oXG4gICAgICB0aGlzLl93cmFwcGVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9sYWJlbCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCwgdGhpcy5fZWxlbWVudCksIGMuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2luaXRPdXRsaW5lSW5wdXQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIElhLFxuICAgICAgdGhpcy5fd3JhcHBlclxuICAgICk7XG4gICAgbmV3IFcoXG4gICAgICB0LFxuICAgICAge1xuICAgICAgICBpbnB1dEZvcm1XaGl0ZTogdGhpcy5fY29uZmlnLnNlbGVjdEZvcm1XaGl0ZVxuICAgICAgfSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLmluaXQoKSwgdGhpcy5fbm90Y2ggPSBkLmZpbmRPbmUoSG4sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIF9iaW5kQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIHRoaXMuX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpLCB0aGlzLl9saXN0ZW5Ub1dyYXBwZXJDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKTtcbiAgfVxuICBfc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuc2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSB7XG4gICAgaC5vbih0aGlzLl93cmFwcGVyLCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5faXNPcGVuICYmICF0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24odCkgOiB0aGlzLl9oYW5kbGVDbG9zZWRLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVPcGVuS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZSwgaSA9IGUgPT09IExpIHx8IGUgPT09IHJ0ICYmIHQuYWx0S2V5IHx8IGUgPT09IE9pO1xuICAgIGlmIChlID09PSBPaSAmJiB0aGlzLl9jb25maWcuc2VsZWN0QXV0b1NlbGVjdCAmJiAhdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9oYW5kbGVBdXRvU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbiksIGkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKSwgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX3NldE5leHRPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSGU6XG4gICAgICAgIHRoaXMuX3NldEZpcnN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fYWN0aXZlT3B0aW9uICYmICh0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9PT0gMCA/IHRoaXMuX2hhbmRsZVNlbGVjdEFsbCgpIDogdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbikpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfaGFuZGxlQ2xvc2VkS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZTtcbiAgICBpZiAoZSA9PT0gbHQgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCAoZSA9PT0gbHQgfHwgZSA9PT0geiAmJiB0LmFsdEtleSB8fCBlID09PSB6ICYmIHRoaXMubXVsdGlwbGUpICYmIHRoaXMub3BlbigpLCB0aGlzLm11bHRpcGxlKVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgejpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBydDpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgejpcbiAgICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJ0OlxuICAgICAgICAgIHRoaXMuX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhlOlxuICAgICAgICAgIHRoaXMuX3NldEZpcnN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdlOlxuICAgICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfc2Nyb2xsVG9PcHRpb24odCkge1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZTtcbiAgICBjb25zdCBpID0gdGhpcy5vcHRpb25zLmZpbHRlcigodSkgPT4gIXUuaGlkZGVuKTtcbiAgICB0aGlzLmhhc1NlbGVjdEFsbCA/IGUgPSBpLmluZGV4T2YodCkgKyAxIDogZSA9IGkuaW5kZXhPZih0KTtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2V0TnVtYmVyT2ZHcm91cHNCZWZvcmVPcHRpb24oZSksIG8gPSBlICsgbiwgciA9IHRoaXMub3B0aW9uc1dyYXBwZXIsIGEgPSByLm9mZnNldEhlaWdodCwgbCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHQsIHAgPSByLnNjcm9sbFRvcDtcbiAgICBpZiAoZSA+IC0xKSB7XG4gICAgICBjb25zdCB1ID0gbyAqIGwsIGYgPSB1ICsgbCA+IHAgKyBhO1xuICAgICAgdSA8IHAgPyByLnNjcm9sbFRvcCA9IHUgOiBmID8gci5zY3JvbGxUb3AgPSB1IC0gYSArIGwgOiByLnNjcm9sbFRvcCA9IHA7XG4gICAgfVxuICB9XG4gIF9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIGkgPSB0aGlzLl9vcHRpb25zVG9SZW5kZXIuZmlsdGVyKChyKSA9PiAhci5oaWRkZW4pLCBuID0gdGhpcy5oYXNTZWxlY3RBbGwgPyB0IC0gMSA6IHQ7XG4gICAgbGV0IG8gPSAwO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDw9IG47IHIrKylcbiAgICAgIGVbcl0uZ3JvdXBJZCAmJiBpW29dICYmIGlbb10uaWQgJiYgZVtyXS5ncm91cElkID09PSBpW29dLmlkICYmIG8rKztcbiAgICByZXR1cm4gbztcbiAgfVxuICBfc2V0TmV4dE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ICsgMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgKz0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCAtIDE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgaWYgKGVbdF0pIHtcbiAgICAgIGZvciAoOyBlW3RdLmRpc2FibGVkOyApXG4gICAgICAgIGlmICh0IC09IDEsICFlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlW3RdLCB0KTtcbiAgICB9XG4gIH1cbiAgX3NldEZpcnN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlWzBdLCAwKTtcbiAgfVxuICBfc2V0TGFzdE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSwgZSA9IHQubGVuZ3RoIC0gMTtcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24odFtlXSwgZSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZU9wdGlvbih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2FjdGl2ZU9wdGlvbjtcbiAgICBpICYmIGkucmVtb3ZlQWN0aXZlU3R5bGVzKCksIHQuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gZSwgdGhpcy5fYWN0aXZlT3B0aW9uID0gdDtcbiAgfVxuICBfbGlzdGVuVG9XcmFwcGVyQ2xpY2soKSB7XG4gICAgaC5vbih0aGlzLl93cmFwcGVyLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ2xlYXJCdG5DbGljaygpIHtcbiAgICBoLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5faGFuZGxlQ2xlYXIoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKSB7XG4gICAgaC5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgKHRoaXMuX2hhbmRsZUNsZWFyKCksIHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsZWFyKCkge1xuICAgIGlmICh0aGlzLm11bHRpcGxlKVxuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdC5kZXNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLl9mYWtlVmFsdWUuaW5uZXJIVE1MID0gXCJcIiwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudChudWxsKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCk7XG4gIH1cbiAgX2xpc3RlblRvT3B0aW9uc0NsaWNrKCkge1xuICAgIGgub24odGhpcy5vcHRpb25zV3JhcHBlciwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgaWYgKHQudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcbiAgICAgICAgS21cbiAgICAgICkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJESVZcIiA/IHQudGFyZ2V0IDogZC5jbG9zZXN0KHQudGFyZ2V0LCBabSk7XG4gICAgICBpZiAoaS5oYXNBdHRyaWJ1dGUoem0pKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVNlbGVjdEFsbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gaS5kYXRhc2V0LnRlSWQsIHIgPSB0aGlzLm9wdGlvbnMuZmluZCgoYSkgPT4gYS5pZCA9PT0gbyk7XG4gICAgICByICYmICFyLmRpc2FibGVkICYmIHRoaXMuX2hhbmRsZVNlbGVjdGlvbihyKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlU2VsZWN0QWxsKCkge1xuICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3RlZCA/ICh0aGlzLl9kZXNlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLmRlc2VsZWN0KCkpIDogKHRoaXMuX3NlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdCgpKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCk7XG4gIH1cbiAgX3NlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgIWUuc2VsZWN0ZWQgJiYgIWUuZGlzYWJsZWQgJiYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdChlKSwgZS5zZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2Rlc2VsZWN0QWxsT3B0aW9ucyh0KSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlU2VsZWN0aW9uKHQpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gKHRoaXMuX2hhbmRsZU11bHRpU2VsZWN0aW9uKHQpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpKSA6IHRoaXMuX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpO1xuICB9XG4gIF9oYW5kbGVBdXRvU2VsZWN0aW9uKHQpIHtcbiAgICB0aGlzLl9zaW5nbGVPcHRpb25TZWxlY3QodCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlU2luZ2xlU2VsZWN0aW9uKHQpIHtcbiAgICB0aGlzLl9zaW5nbGVPcHRpb25TZWxlY3QodCksIHRoaXMuY2xvc2UoKSwgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgfVxuICBfc2luZ2xlT3B0aW9uU2VsZWN0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uc1swXTtcbiAgICBlICYmIGUgIT09IHQgJiYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KGUpLCBlLmRlc2VsZWN0KCksIGUubm9kZS5zZXRBdHRyaWJ1dGUoY2ksICExKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHdhLCB7XG4gICAgICB2YWx1ZTogZS52YWx1ZVxuICAgIH0pKSwgKCFlIHx8IGUgJiYgdCAhPT0gZSkgJiYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh0KSwgdC5zZWxlY3QoKSwgdC5ub2RlLnNldEF0dHJpYnV0ZShjaSwgITApLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeWEsIHtcbiAgICAgIHZhbHVlOiB0LnZhbHVlXG4gICAgfSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKSk7XG4gIH1cbiAgX2hhbmRsZU11bHRpU2VsZWN0aW9uKHQpIHtcbiAgICB0LnNlbGVjdGVkID8gKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KHQpLCB0LmRlc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoY2ksICExKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHdhLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pKSA6ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoY2ksICEwKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHlhLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0KSB7XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFltLCB7IHZhbHVlOiB0IH0pO1xuICB9XG4gIF9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKSB7XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGptKTtcbiAgfVxuICBfdXBkYXRlSW5wdXRWYWx1ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmxhYmVscyA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmxhYmVsO1xuICAgIGxldCBlO1xuICAgIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyAhPT0gLTEgJiYgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiB0aGlzLl9jb25maWcuc2VsZWN0RGlzcGxheWVkTGFiZWxzID8gZSA9IGAke3RoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RofSAke3RoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbH1gIDogZSA9IHQsICF0aGlzLm11bHRpcGxlICYmICF0aGlzLl9pc1NlbGVjdGlvblZhbGlkKHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiXCIgOiB0aGlzLl9pc0xhYmVsRW1wdHkodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uKSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCIgXCIgOiBlID8gdGhpcy5faW5wdXQudmFsdWUgPSBlIDogdGhpcy5tdWx0aXBsZSB8fCAhdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faW5wdXQudmFsdWUgPSB0aGlzLl9vcHRpb25zVG9SZW5kZXJbMF0ubGFiZWw7XG4gIH1cbiAgX2lzU2VsZWN0aW9uVmFsaWQodCkge1xuICAgIHJldHVybiAhKHQgJiYgKHQuZGlzYWJsZWQgfHwgdC52YWx1ZSA9PT0gXCJcIikpO1xuICB9XG4gIF9pc0xhYmVsRW1wdHkodCkge1xuICAgIHJldHVybiAhISh0ICYmIHQubGFiZWwgPT09IFwiXCIpO1xuICB9XG4gIF9hcHBlbmRGYWtlVmFsdWUoKSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuX211bHRpcGxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24ubGFiZWw7XG4gICAgdGhpcy5fZmFrZVZhbHVlID0gV20odCwgdGhpcy5fY2xhc3NlcyksIGQuZmluZE9uZShcbiAgICAgIElhLFxuICAgICAgdGhpcy5fd3JhcHBlclxuICAgICkuYXBwZW5kQ2hpbGQodGhpcy5fZmFrZVZhbHVlKTtcbiAgfVxuICBfdXBkYXRlTGFiZWxQb3NpdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoeGEpLCBlID0gdGhpcy5faW5wdXQudmFsdWUgIT09IFwiXCI7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHQgJiYgKGUgfHwgdGhpcy5faXNPcGVuIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlKSA/ICh0aGlzLl9sYWJlbC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShxLCBcIlwiKSkgOiAodGhpcy5fbGFiZWwucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUocSwgXCJcIikpKTtcbiAgfVxuICBfdXBkYXRlTGFiZWxQb3NpdGlvbldoaWxlQ2xvc2luZygpIHtcbiAgICB0aGlzLl9sYWJlbCAmJiAodGhpcy5faW5wdXQudmFsdWUgIT09IFwiXCIgfHwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEpKSk7XG4gIH1cbiAgX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCkge1xuICAgIHRoaXMuX2Zha2VWYWx1ZSAmJiAodGhpcy5faW5wdXQudmFsdWUgPT09IFwiXCIgJiYgdGhpcy5fZmFrZVZhbHVlLmlubmVySFRNTCAhPT0gXCJcIiAmJiAhdGhpcy5fY29uZmlnLnNlbGVjdFBsYWNlaG9sZGVyID8gKHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITAsIHRoaXMuX2Zha2VWYWx1ZS5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITEsIHRoaXMuX2Zha2VWYWx1ZS5yZW1vdmVBdHRyaWJ1dGUocSkpKTtcbiAgfVxuICBfdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCkge1xuICAgIGlmICghdGhpcy5jbGVhckJ1dHRvbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiAwID8gYy5hZGRTdHlsZSh0aGlzLmNsZWFyQnV0dG9uLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSA6IGMuYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgfVxuICBfdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3RlZCwgZSA9IGNvKHRoaXMub3B0aW9ucyk7XG4gICAgIWUgJiYgdCA/IHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpIDogZSAmJiAhdCAmJiB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5kaXNhYmxlZCwgZSA9IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBGbSk7XG4gICAgdGhpcy5faXNPcGVuIHx8IHQgfHwgZS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9vcGVuRHJvcGRvd24oKSwgdGhpcy5fdXBkYXRlRHJvcGRvd25XaWR0aCgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pLCB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmlsdGVySW5wdXQuZm9jdXMoKTtcbiAgICB9LCAwKSwgdGhpcy5fbGlzdGVuVG9TZWxlY3RTZWFyY2goKSwgdGhpcy5fbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSksIHRoaXMuX2xpc3RlblRvT3B0aW9uc0NsaWNrKCksIHRoaXMuX2xpc3RlblRvT3V0c2lkZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvV2luZG93UmVzaXplKCksIHRoaXMuX2lzT3BlbiA9ICEwLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3NldElucHV0QWN0aXZlU3R5bGVzKCkpO1xuICB9XG4gIF9vcGVuRHJvcGRvd24oKSB7XG4gICAgdGhpcy5fcG9wcGVyID0gRWUodGhpcy5faW5wdXQsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShrYSwgXCJcIik7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoO1xuICAgIGMuYWRkU3R5bGUodGhpcy5fZHJvcGRvd25Db250YWluZXIsIHsgd2lkdGg6IGAke3R9cHhgIH0pO1xuICB9XG4gIF9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSwgZSA9IHRoaXMuX2FjdGl2ZU9wdGlvbjtcbiAgICBlICYmIGUucmVtb3ZlQWN0aXZlU3R5bGVzKCk7XG4gICAgY29uc3QgaSA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zWzBdIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uO1xuICAgIGkgPyAodGhpcy5fYWN0aXZlT3B0aW9uID0gaSwgaS5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSB0LmZpbmRJbmRleChcbiAgICAgIChuKSA9PiBuID09PSBpXG4gICAgKSkgOiAodGhpcy5fYWN0aXZlT3B0aW9uID0gbnVsbCwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSAtMSk7XG4gIH1cbiAgX3NldElucHV0QWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShLdCwgXCJcIiksIGQuZmluZE9uZShIbiwgdGhpcy5fd3JhcHBlcikuc2V0QXR0cmlidXRlKFxuICAgICAgS3QsXG4gICAgICBcIlwiXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9XaW5kb3dSZXNpemUoKSB7XG4gICAgaC5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKTtcbiAgfVxuICBfbGlzdGVuVG9TZWxlY3RTZWFyY2goKSB7XG4gICAgdGhpcy5maWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC52YWx1ZSwgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXJEZWJvdW5jZTtcbiAgICAgIHRoaXMuX2RlYm91bmNlRmlsdGVyKGUsIGkpO1xuICAgIH0pO1xuICB9XG4gIF9kZWJvdW5jZUZpbHRlcih0LCBlKSB7XG4gICAgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlVGltZW91dElkKSwgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpbHRlck9wdGlvbnModCk7XG4gICAgfSwgZSk7XG4gIH1cbiAgX2ZpbHRlck9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgbyxcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgICksIGEgPSAhciAmJiBvLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModC50b0xvd2VyQ2FzZSgpKSwgbCA9IHt9O1xuICAgICAgciAmJiAobC5sYWJlbCA9IG8ubGFiZWwsIGwub3B0aW9ucyA9IHRoaXMuX2ZpbHRlcih0LCBvLm9wdGlvbnMpLCBsLm9wdGlvbnMubGVuZ3RoID4gMCAmJiBlLnB1c2gobCkpLCBhICYmIGUucHVzaChvKTtcbiAgICB9KTtcbiAgICBjb25zdCBpID0gdGhpcy5fY29uZmlnLnNlbGVjdE5vUmVzdWx0VGV4dCAhPT0gXCJcIiwgbiA9IGUubGVuZ3RoICE9PSAwO1xuICAgIGlmIChuKVxuICAgICAgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZShlKSwgdGhpcy5fcG9wcGVyLmZvcmNlVXBkYXRlKCksIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnMoZSksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCk7XG4gICAgZWxzZSBpZiAoIW4gJiYgaSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuX2dldE5vUmVzdWx0VGVtcGxhdGUoKTtcbiAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIuaW5uZXJIVE1MID0gbztcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoU2EsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSB8fCBkLmZpbmRPbmUodGcsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgaSA9IGNjKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMub3B0aW9uc1dyYXBwZXIucmVtb3ZlQ2hpbGQoZSksIHRoaXMub3B0aW9uc1dyYXBwZXIuYXBwZW5kQ2hpbGQoaSk7XG4gIH1cbiAgX2dldE5vUmVzdWx0VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLm5vUmVzdWx0fVwiICR7cGN9IHN0eWxlPVwiaGVpZ2h0OiAke3RoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHR9cHhcIj4ke3RoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHR9PC9kaXY+YDtcbiAgfVxuICBfZmlsdGVyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBlLmZpbHRlcihcbiAgICAgIChuKSA9PiBuLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaSlcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0Ryb3Bkb3duS2V5ZG93bigpIHtcbiAgICBoLm9uKFxuICAgICAgdGhpcy5kcm9wZG93bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5faGFuZGxlT3BlbktleWRvd24uYmluZCh0aGlzKVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIHRoaXMuX291dHNpZGVDbGljayA9IHRoaXMuX2hhbmRsZU91dFNpZGVDbGljay5iaW5kKHRoaXMpLCBoLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayk7XG4gIH1cbiAgX2xpc3RlblRvRm9jdXNDaGFuZ2UodCA9ICEwKSB7XG4gICAgaWYgKHQgPT09ICExKSB7XG4gICAgICBoLm9mZihcbiAgICAgICAgdGhpcy5faW5wdXQsXG4gICAgICAgIFwiZm9jdXNcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKEt0LCBcIlwiKVxuICAgICAgKSwgaC5vZmYoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImJsdXJcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKEt0KVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaC5vbihcbiAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgKCkgPT4gdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKEt0LCBcIlwiKVxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgKCkgPT4gdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKEt0KVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZU91dFNpZGVDbGljayh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3dyYXBwZXIgJiYgdGhpcy5fd3JhcHBlci5jb250YWlucyh0LnRhcmdldCksIGkgPSB0LnRhcmdldCA9PT0gdGhpcy5fZHJvcGRvd25Db250YWluZXIsIG4gPSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgbGV0IG87XG4gICAgdGhpcy5fdG9nZ2xlQnV0dG9uIHx8ICh0aGlzLl9lbGVtZW50VG9nZ2xlID0gZC5maW5kKGVnKSksIHRoaXMuX2VsZW1lbnRUb2dnbGUgJiYgdGhpcy5fZWxlbWVudFRvZ2dsZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBhID0gYy5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgICByLFxuICAgICAgICBcInNlbGVjdC10b2dnbGVcIlxuICAgICAgKTtcbiAgICAgIChhID09PSB0aGlzLl9lbGVtZW50LmlkIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGEpKSAmJiAodGhpcy5fdG9nZ2xlQnV0dG9uID0gciwgbyA9IHRoaXMuX3RvZ2dsZUJ1dHRvbi5jb250YWlucyh0LnRhcmdldCkpO1xuICAgIH0pLCAhZSAmJiAhaSAmJiAhbiAmJiAhbyAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgdCA9IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWbSk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3Jlc2V0RmlsdGVyU3RhdGUoKSwgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSksIHRoaXMuX3JlbW92ZURyb3Bkb3duRXZlbnRzKCksIHRoaXMuZHJvcGRvd24ucmVtb3ZlQXR0cmlidXRlKGthKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoS3QpLCB0aGlzLl9pbnB1dC5ibHVyKCksIGQuZmluZE9uZShIbiwgdGhpcy5fd3JhcHBlcikucmVtb3ZlQXR0cmlidXRlKFxuICAgICAgICBLdFxuICAgICAgKSwgdGhpcy5fbGFiZWwgJiYgIXRoaXMuaGFzU2VsZWN0aW9uICYmICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUocSkpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCk7XG4gICAgfSwgMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9pc09wZW4gPSAhMSwgaC5vZmYodGhpcy5kcm9wZG93biwgXCJ0cmFuc2l0aW9uZW5kXCIpO1xuICAgIH0sIGlnKSk7XG4gIH1cbiAgX3Jlc2V0RmlsdGVyU3RhdGUoKSB7XG4gICAgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVEcm9wZG93bkV2ZW50cygpIHtcbiAgICBoLm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spLCB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIGgub2ZmKHRoaXMuZHJvcGRvd24sIFwia2V5ZG93blwiKSwgaC5vZmYodGhpcy5vcHRpb25zV3JhcHBlciwgXCJjbGlja1wiKTtcbiAgfVxuICBfYWRkTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fd3JhcHBlciAmJiAodGhpcy5fdXBkYXRlU2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVEaXNhYmxlZFN0YXRlKCkpO1xuICAgIH0pLCB0aGlzLl9vYnNlcnZlTXV0YXRpb25PYnNlcnZlcigpO1xuICB9XG4gIF91cGRhdGVTZWxlY3Rpb25zKCkge1xuICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlciA9IHRoaXMuX2dldE9wdGlvbnNUb1JlbmRlcih0aGlzLl9lbGVtZW50KSwgdGhpcy5fcGxhaW5PcHRpb25zID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHRoaXMuX3NldERlZmF1bHRTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmZpbHRlciAmJiB0aGlzLmZpbHRlcklucHV0ICYmIHRoaXMuZmlsdGVySW5wdXQudmFsdWU7XG4gICAgdGhpcy5faXNPcGVuICYmICF0ID8gKHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSkgOiB0aGlzLl9pc09wZW4gJiYgdCA/ICh0aGlzLl9maWx0ZXJPcHRpb25zKHRoaXMuZmlsdGVySW5wdXQudmFsdWUpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gQWEoXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5faW5wdXQub2Zmc2V0V2lkdGgsXG4gICAgICB0aGlzLl9kcm9wZG93bkhlaWdodCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlcixcbiAgICAgIHRoaXMuX2N1c3RvbUNvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgfVxuICBfdXBkYXRlRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKE9hLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpID8gKHRoaXMuX2NvbmZpZy5kaXNhYmxlZCA9ICEwLCB0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0LnNldEF0dHJpYnV0ZShCbiwgXCJcIikpIDogKHRoaXMuX2NvbmZpZy5kaXNhYmxlZCA9ICExLCB0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0LnJlbW92ZUF0dHJpYnV0ZShCbikpO1xuICB9XG4gIF9vYnNlcnZlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyICYmIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBhdHRyaWJ1dGVzOiAhMCxcbiAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiAhMCxcbiAgICAgIHN1YnRyZWU6ICEwXG4gICAgfSk7XG4gIH1cbiAgX2Rpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciAmJiAodGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCksIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBudWxsKTtcbiAgfVxuICBfY3JlYXRlU2VsZWN0QWxsT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxJZCwgZSA9IG51bGwsIGkgPSAhMCwgbiA9IFwic2VsZWN0LWFsbFwiLCBvID0gdGhpcy5fY29uZmlnLnNlbGVjdEFsbExhYmVsLCByID0gY28odGhpcy5vcHRpb25zKSwgYSA9ICExLCBsID0gITEsIHAgPSBudWxsLCB1ID0gbnVsbCwgZiA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBDYShcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBmXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZUNvbXBvbmVudEV2ZW50cygpLCB0aGlzLl9kZXN0cm95TWF0ZXJpYWxTZWxlY3QoKSwgdGhpcy5fbGlzdGVuVG9Gb2N1c0NoYW5nZSghMSksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBmaSk7XG4gIH1cbiAgX3JlbW92ZUNvbXBvbmVudEV2ZW50cygpIHtcbiAgICBoLm9mZih0aGlzLmlucHV0LCBcImNsaWNrXCIpLCBoLm9mZih0aGlzLndyYXBwZXIsIHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKSksIGgub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiKSwgaC5vZmYod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9kZXN0cm95TWF0ZXJpYWxUZW1wbGF0ZSgpO1xuICB9XG4gIF9kZXN0cm95TWF0ZXJpYWxUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fd3JhcHBlci5wYXJlbnROb2RlLCBlID0gZC5maW5kKFwibGFiZWxcIiwgdGhpcy5fd3JhcHBlcik7XG4gICAgdC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSwgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0LmFwcGVuZENoaWxkKGkpO1xuICAgIH0pLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGkucmVtb3ZlQXR0cmlidXRlKHEpO1xuICAgIH0pLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaW5pdGlhbGl6ZWQpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh4YSksIHQucmVtb3ZlQ2hpbGQodGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgc2V0VmFsdWUodCkge1xuICAgIHRoaXMub3B0aW9ucy5maWx0ZXIoKGkpID0+IGkuc2VsZWN0ZWQpLmZvckVhY2goKGkpID0+IGkubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpLCBBcnJheS5pc0FycmF5KHQpID8gdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0aGlzLl9zZWxlY3RCeVZhbHVlKGkpO1xuICAgIH0pIDogdGhpcy5fc2VsZWN0QnlWYWx1ZSh0KSwgdGhpcy5fdXBkYXRlU2VsZWN0aW9ucygpO1xuICB9XG4gIF9zZWxlY3RCeVZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbmQoXG4gICAgICAoaSkgPT4gaS52YWx1ZSA9PT0gdFxuICAgICk7XG4gICAgcmV0dXJuIGUgPyAoZS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCwgITApIDogITE7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIGZpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgJG8odGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgZmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGFnID0gKHsgaW5wdXRJRDogcywgbGFiZWxUZXh0OiB0IH0sIGUpID0+IGA8ZGl2IGRhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlciBkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdCBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0V3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0fVwiXG4gICAgICAgICAgaWQ9XCIke3N9XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGUgbGFiZWxcIiAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICBmb3I9XCIke3N9XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0xhYmVsfVwiXG4gICAgICAgICAgPiR7dH1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmAsIGxnID0gKHsgdGV4dDogcywgaWNvblNWRzogdCB9LCBlKSA9PiBgPGRpdiBkYXRhLXRlLWNoaXAtaW5pdCBkYXRhLXRlLXJpcHBsZS1pbml0IGNsYXNzPVwiJHtlLmNoaXBFbGVtZW50fVwiPlxuICAgIDxzcGFuIGRhdGEtdGUtY2hpcC10ZXh0PiR7c308L3NwYW4+IFxuICAgICAgPHNwYW4gZGF0YS10ZS1jaGlwLWNsb3NlIGNsYXNzPVwiJHtlLmNoaXBDbG9zZUljb259XCI+XG4gICAgICAgICR7dH1cbiAgICAgIDwvc3Bhbj5cbiAgPC9kaXY+YCwgRHMgPSBcImNoaXBcIiwgY2cgPSBgdGUuJHtEc31gLCBfYyA9IFwiZGF0YS10ZS1jaGlwLWNsb3NlXCIsIFduID0gYFske19jfV1gLCBoZyA9IFwiZGVsZXRlLnRlLmNoaXBzXCIsIGRnID0gXCJzZWxlY3QudGUuY2hpcFwiLCB1ZyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctMyBoLTNcIj4gPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz48L3N2Zz4nLCBwZyA9IHtcbiAgdGV4dDogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uOiBcImJvb2xlYW5cIixcbiAgaW1nOiBcIm9iamVjdFwiLFxuICBpY29uU1ZHOiBcInN0cmluZ1wiXG59LCBfZyA9IHtcbiAgdGV4dDogXCJcIixcbiAgY2xvc2VJY29uOiAhMSxcbiAgaW1nOiB7IHBhdGg6IFwiXCIsIGFsdDogXCJcIiB9LFxuICBpY29uU1ZHOiB1Z1xufSwgZmcgPSB7XG4gIGljb246IFwiZmxvYXQtcmlnaHQgcGwtWzhweF0gdGV4dC1bMTZweF0gb3BhY2l0eS1bLjUzXSBjdXJzb3ItcG9pbnRlciBmaWxsLVsjYWZhZmFmXSBob3Zlcjp0ZXh0LVsjOGI4YjhiXSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIixcbiAgY2hpcEVsZW1lbnQ6IFwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIGgtWzMycHhdIGxlYWRpbmctbG9vc2UgcHktWzVweF0gcHgtWzEycHhdIG1yLTQgbXktWzVweF0gdGV4dC1bMTNweF0gZm9udC1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gY3Vyc29yLXBvaW50ZXIgYmctWyNlY2VmZjFdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmJnLW5ldXRyYWwtNjAwIHJvdW5kZWQtWzE2cHhdIHRyYW5zaXRpb24tW29wYWNpdHldIGR1cmF0aW9uLTMwMCBlYXNlLWxpbmVhciBbd29yZC13cmFwOiBicmVhay13b3JkXSBzaGFkb3ctbm9uZSBub3JtYWwtY2FzZSBob3Zlcjohc2hhZG93LW5vbmUgYWN0aXZlOmJnLVsjY2FjZmQxXSBpbmxpbmUtYmxvY2sgZm9udC1tZWRpdW0gbGVhZGluZy1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gdGV4dC1jZW50ZXIgbm8tdW5kZXJsaW5lIGFsaWduLW1pZGRsZSBjdXJzb3ItcG9pbnRlciBzZWxlY3Qtbm9uZSBib3JkZXItWy4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItdHJhbnNwYXJlbnQgcHktMS41IHB4LTMgdGV4dC14cyByb3VuZGVkXCIsXG4gIGNoaXBDbG9zZUljb246IFwidy00IGZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6ZmlsbC1bIzhiOGI4Yl0gZGFyazpmaWxsLWdyYXktNDAwIGRhcms6aG92ZXI6ZmlsbC1ncmF5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIlxufSwgbWcgPSB7XG4gIGljb246IFwic3RyaW5nXCIsXG4gIGNoaXBFbGVtZW50OiBcInN0cmluZ1wiLFxuICBjaGlwQ2xvc2VJY29uOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgaGkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIERzO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2FwcGVuZENsb3NlSWNvbigpLCB0aGlzLl9oYW5kbGVEZWxldGUoKSwgdGhpcy5faGFuZGxlVGV4dENoaXAoKSwgdGhpcy5faGFuZGxlQ2xpY2tPbkNoaXAoKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgaC5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiKTtcbiAgfVxuICBhcHBlbmRDaGlwKCkge1xuICAgIGNvbnN0IHsgdGV4dDogdCwgY2xvc2VJY29uOiBlLCBpY29uU1ZHOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiBsZyh7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9LCB0aGlzLl9jbGFzc2VzKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9hcHBlbmRDbG9zZUljb24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICBpZiAoIShkLmZpbmQoV24sIHRoaXMuX2VsZW1lbnQpLmxlbmd0aCA+IDApICYmIHRoaXMuX29wdGlvbnMuY2xvc2VJY29uKSB7XG4gICAgICBjb25zdCBlID0gRChcInNwYW5cIik7XG4gICAgICBlLmNsYXNzTGlzdCA9IHRoaXMuX2NsYXNzZXMuaWNvbiwgZS5zZXRBdHRyaWJ1dGUoX2MpLCBlLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuaWNvblNWRywgdC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgZSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVDbGlja09uQ2hpcCgpIHtcbiAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IGUgfSA9IHQudGFyZ2V0LCBpID0ge307XG4gICAgICBpLnRhZyA9IGUudHJpbSgpLCBoLnRyaWdnZXIoZGcsIHsgZXZlbnQ6IHQsIG9iajogaSB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlKCkge1xuICAgIGQuZmluZChcbiAgICAgIFduLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoICE9PSAwICYmIGgub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCBXbiwgKCkgPT4ge1xuICAgICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhnKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGV4dENoaXAoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbm5lclRleHQgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy5fb3B0aW9ucy50ZXh0KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uX2csXG4gICAgICAuLi5jLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEwoRHMsIGUsIHBnKSwgZTtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmZnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBMKERzLCB0LCBtZyksIHQ7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGNnKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB3aSA9IFwiY2hpcHNcIiwgUmkgPSBgZGF0YS10ZS0ke3dpfWAsIERhID0gYHRlLiR7d2l9YCwgZ2cgPSBgJHtSaX0taW5wdXQtaW5pdGAsIGZ0ID0gYCR7Uml9LWFjdGl2ZWAsICRhID0gYCR7Uml9LWluaXRpYWxgLCBmYyA9IGAke1JpfS1wbGFjZWhvbGRlcmAsIGJnID0gYCR7Uml9LWlucHV0LXdyYXBwZXJgLCBobyA9IFwiZGF0YS10ZS1jaGlwLWluaXRcIiwgbWMgPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBnYyA9IFwiZGF0YS10ZS1jaGlwLXRleHRcIiwgdmcgPSBgWyR7ZnR9XWAsIHVvID0gYFske2hvfV1gLCBUZyA9IGAke3VvfSR7dmd9YCwgVm4gPSBgWyR7bWN9XWAsIEVnID0gYFske2JnfV1gLCBDZyA9IGBbJHtnY31dYCwgQWcgPSBgWyR7ZmN9XWAsIHlnID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmXCIsIHdnID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgeGcgPSBgWyR7eWd9XWAsIGtnID0gYFske3dnfV1gLCBPZSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgRm4gPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgT2cgPSBcImFkZC50ZS5jaGlwc1wiLCBTZyA9IFwiYXJyb3dEb3duLnRlLmNoaXBzXCIsIElnID0gXCJhcnJvd0xlZnQudGUuY2hpcHNcIiwgRGcgPSBcImFycm93UmlnaHQudGUuY2hpcHNcIiwgJGcgPSBcImFycm93VXAudGUuY2hpcHNcIiwgTGEgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCBNYSA9IFwic2VsZWN0LnRlLmNoaXBzXCIsIExnID0ge1xuICBpbnB1dElEOiBcInN0cmluZ1wiLFxuICBwYXJlbnRTZWxlY3RvcjogXCJzdHJpbmdcIixcbiAgaW5pdGlhbFZhbHVlczogXCJhcnJheVwiLFxuICBlZGl0YWJsZTogXCJib29sZWFuXCIsXG4gIGxhYmVsVGV4dDogXCJzdHJpbmdcIixcbiAgaW5wdXRDbGFzc2VzOiBcIm9iamVjdFwiLFxuICBpbnB1dE9wdGlvbnM6IFwib2JqZWN0XCJcbn0sIE1nID0ge1xuICBpbnB1dElEOiBidChcImNoaXBzLWlucHV0LVwiKSxcbiAgcGFyZW50U2VsZWN0b3I6IFwiXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFt7IHRhZzogXCJpbml0MVwiIH0sIHsgdGFnOiBcImluaXQyXCIgfV0sXG4gIGVkaXRhYmxlOiAhMSxcbiAgbGFiZWxUZXh0OiBcIkV4YW1wbGUgbGFiZWxcIixcbiAgaW5wdXRDbGFzc2VzOiB7fSxcbiAgaW5wdXRPcHRpb25zOiB7fVxufSwgTmcgPSB7XG4gIG9wYWNpdHk6IFwib3BhY2l0eS0wXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwicC1bNXB4XVwiLFxuICB0cmFuc2l0aW9uOiBcInRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY29udGVudEVkaXRhYmxlOiBcIm91dGxpbmUtbm9uZSAhYm9yZGVyLVszcHhdICFib3JkZXItc29saWQgIWJvcmRlci1bI2IyYjNiNF1cIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIgZmxleC13cmFwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY2hpcHNJbnB1dDogXCJwZWVyIGJsb2NrIG1pbi1oLVthdXRvXSB3LVsxNTBweF0gcm91bmRlZCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdIG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wXCIsXG4gIGNoaXBzTGFiZWw6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTMgbWItMCBtYXgtdy1bOTAlXSBvcmlnaW4tWzBfMF0gdHJ1bmNhdGUgcHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gdGV4dC1ncmF5LTUwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1vdXQgcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1mb2N1czpzY2FsZS1bMC44XSBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDBcIlxufSwgUmcgPSB7XG4gIG9wYWNpdHk6IFwic3RyaW5nXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwic3RyaW5nXCIsXG4gIHRyYW5zaXRpb246IFwic3RyaW5nXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJzdHJpbmdcIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXQ6IFwic3RyaW5nXCIsXG4gIGNoaXBzTGFiZWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBLMCBleHRlbmRzIGhpIHtcbiAgY29uc3RydWN0b3IoZSwgaSA9IHt9LCBuKSB7XG4gICAgc3VwZXIoZSwgaSk7XG4gICAgQXQodGhpcywgXCJfaGFuZGxlQmx1cklucHV0XCIsICh7IHRhcmdldDogZSB9KSA9PiB7XG4gICAgICBlLnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcChlLCBlLnZhbHVlKSwgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKGUuc2V0QXR0cmlidXRlKGZ0LCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoT2UsIFwiXCIpLCBkLmZpbmRPbmUoXG4gICAgICAgIEZuLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKE9lLCBcIlwiKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApKSA6IChlLnJlbW92ZUF0dHJpYnV0ZShmdCksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKE9lKSwgZC5maW5kT25lKFxuICAgICAgICBGbixcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnJlbW92ZUF0dHJpYnV0ZShPZSksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gaS5yZW1vdmVBdHRyaWJ1dGUoZnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZSwgdGhpcy5faW5wdXRJbnN0YW5jZSA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKGUsIERhLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMubnVtYmVyQ2xpY2tzID0gMCwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHdpO1xuICB9XG4gIGdldCBhY3RpdmVDaGlwKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoVGcsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGFsbENoaXBzKCkge1xuICAgIHJldHVybiBkLmZpbmQodW8sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBjaGlwc0lucHV0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEVnLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9zZXRDaGlwc0NsYXNzKCksIHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KGZjKSwgdGhpcy5faGFuZGxlSW5pdGlhbFZhbHVlKCksIHRoaXMuX2hhbmRsZUlucHV0VGV4dCgpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpLCB0aGlzLl9oYW5kbGVDaGlwc09uU2VsZWN0KCksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCksIHRoaXMuX2hhbmRsZUNoaXBzRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2tzT25DaGlwcygpLCB0aGlzLl9pbnB1dEluc3RhbmNlLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2lucHV0SW5zdGFuY2UuX2FwcGx5Tm90Y2goKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXROb3RjaERhdGEoKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICBrZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICB4ZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICB9XG4gIF9zZXRDaGlwc0NsYXNzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGdnLCBcIlwiKTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlRXZlbnRzKGUpIHtcbiAgICBjb25zdCBbaV0gPSB0aGlzLmFsbENoaXBzLnNsaWNlKC0xKTtcbiAgICBpZiAodGhpcy5hY3RpdmVDaGlwID09PSBudWxsKVxuICAgICAgaS5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIExhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmFsbENoaXBzLmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gdGhpcy5hY3RpdmVDaGlwKSwgbyA9IHRoaXMuX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShuKSwgciA9IFtdO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hY3RpdmVDaGlwLnJlbW92ZSgpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgTGEpLCB0aGlzLm51bWJlckNsaWNrcyA9IG4sIG8uc2V0QXR0cmlidXRlKGZ0LCBcIlwiKSwgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGEuaGFzQXR0cmlidXRlKGZ0KSAmJiAoci5wdXNoKGEpLCByLmxlbmd0aCA+IDEgJiYgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChsKSA9PiBsLnJlbW92ZSgpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZVVwRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyArPSAxLCB0aGlzLm51bWJlckNsaWNrcyA9PT0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxICYmICh0aGlzLm51bWJlckNsaWNrcyA9IDApLCB0aGlzLl9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgRGcpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgJGcpO1xuICB9XG4gIF9oYW5kbGVEb3duRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyAtPSAxLCB0aGlzLm51bWJlckNsaWNrcyA8PSAwICYmICh0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoKSwgdGhpcy5faGFuZGxlTGVmdEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgSWcpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgU2cpO1xuICB9XG4gIF9rZXlib2FyZEV2ZW50cyhlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IGksIGtleUNvZGU6IG4sIGN0cmxLZXk6IG8gfSA9IGU7XG4gICAgaS52YWx1ZS5sZW5ndGggPiAwIHx8IHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwIHx8IChuID09PSBJXyB8fCBuID09PSBEXyA/IHRoaXMuX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSA6IG4gPT09IEJlIHx8IG4gPT09IHJ0ID8gdGhpcy5faGFuZGxlVXBFdmVudHMoZSkgOiBuID09PSBQZSB8fCBuID09PSB6ID8gdGhpcy5faGFuZGxlRG93bkV2ZW50cyhlKSA6IG4gPT09IDY1ICYmIG8gJiYgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3MoKSk7XG4gIH1cbiAgX2hhbmRsZUtleWJvYXJkKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLmlucHV0LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICAoZSkgPT4gdGhpcy5fa2V5Ym9hcmRFdmVudHMoZSlcbiAgICApO1xuICB9XG4gIF9oYW5kbGVFZGl0YWJsZSgpIHtcbiAgICBjb25zdCB7IGVkaXRhYmxlOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGUgJiYgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBoLm9uKGksIFwiZGJsY2xpY2tcIiwgKG4pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShWbiwgaSk7XG4gICAgICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCBpLmNvbnRlbnRFZGl0YWJsZSA9ICEwLCBpLmZvY3VzKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGMuYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgICAgICAgfSwgMjAwKSwgby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpLCBuLnRhcmdldC50ZXh0Q29udGVudCwgaC50cmlnZ2VyKGksIE1hLCB7XG4gICAgICAgICAgZXZlbnQ6IG4sXG4gICAgICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHNcbiAgICAgICAgfSk7XG4gICAgICB9KSwgaC5vbihkb2N1bWVudCwgXCJjbGlja1wiLCAoeyB0YXJnZXQ6IG4gfSkgPT4ge1xuICAgICAgICBjb25zdCBvID0gZC5maW5kT25lKFZuLCBpKSwgciA9IGQuZmluZE9uZShDZywgaSksIGEgPSBuID09PSBpLCBsID0gaSAmJiBpLmNvbnRhaW5zKG4pO1xuICAgICAgICAhYSAmJiAhbCAmJiAoaS5jb250ZW50RWRpdGFibGUgPSAhMSwgaS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIHIudGV4dENvbnRlbnQgIT09IFwiXCIgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYy5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgby5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgICB9LCAxNjApKSwgci50ZXh0Q29udGVudCA9PT0gXCJcIiAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgICB9LCAyMDApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpLnJlbW92ZSgpO1xuICAgICAgICB9LCAzMDApKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IGUucmVtb3ZlQXR0cmlidXRlKGZ0KSk7XG4gIH1cbiAgX2hhbmRsZUFkZEFjdGl2ZUNsYXNzKCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4gZS5zZXRBdHRyaWJ1dGUoZnQsIFwiXCIpKTtcbiAgfVxuICBfaGFuZGxlUmlnaHRLZXlib2FyZEFycm93KGUpIHtcbiAgICB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCBlID09PSAwICYmIChlID0gMSksIHRoaXMuX2hhbmRsZUFkZEFjdGl2ZUNsYXNzV2l0aEtlYnlib2FyZChlKTtcbiAgfVxuICBfaGFuZGxlTGVmdEtleWJvYXJkQXJyb3coZSkge1xuICAgIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIHRoaXMuX2hhbmRsZUFkZEFjdGl2ZUNsYXNzV2l0aEtlYnlib2FyZChlKTtcbiAgfVxuICBfaGFuZGxlQWN0aXZlQ2hpcEFmdGVyUmVtb3ZlKGUpIHtcbiAgICBjb25zdCBpID0gZSA9PT0gMCA/IDEgOiBlIC0gMTtcbiAgICByZXR1cm4gdGhpcy5hbGxDaGlwc1tpXTtcbiAgfVxuICBfaGFuZGxlQ2xpY2tzT25DaGlwcygpIHtcbiAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPT09IDAgJiYgKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoZnQpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IGUucHVzaCh7IHRhZzogaS50ZXh0Q29udGVudC50cmltKCkgfSkpLCBlO1xuICB9XG4gIF9oYW5kbGVFdmVudHMoZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9oYW5kbGVUZXh0Q29udGVudCgpLCBvID0gdGhpcy5hbGxDaGlwcy5maWx0ZXIoXG4gICAgICAocikgPT4gci5oYXNBdHRyaWJ1dGUoZnQpICYmIHJcbiAgICApO1xuICAgIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpLCB7XG4gICAgICBldmVudDogZSxcbiAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzLFxuICAgICAgYXJyT2ZPYmplY3RzOiBuLFxuICAgICAgYWN0aXZlOiBvLFxuICAgICAgYWN0aXZlT2JqOiB7XG4gICAgICAgIHRhZzogby5sZW5ndGggPD0gMCA/IFwiXCIgOiBvWzBdLnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDaGlwc0ZvY3VzKCkge1xuICAgIGgub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoeyB0YXJnZXQ6IHsgYXR0cmlidXRlczogZSB9IH0pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBbLi4uZV07XG4gICAgICBpLmluY2x1ZGVzKGhvKSB8fCBpLmluY2x1ZGVzKG1jKSB8fCBpLmluY2x1ZGVzKGdjKSB8fCB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUluaXRpYWxWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fYXBwZW5kSW5wdXRUb0VsZW1lbnQoJGEpLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSgkYSkpIHtcbiAgICAgIGNvbnN0IHsgaW5pdGlhbFZhbHVlczogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGUuZm9yRWFjaChcbiAgICAgICAgKHsgdGFnOiBpIH0pID0+IHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAodGhpcy5pbnB1dCwgaSlcbiAgICAgICksIGQuZmluZE9uZShcbiAgICAgICAgRm4sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5zZXRBdHRyaWJ1dGUoT2UsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShmdCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKE9lLCBcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50cmFuc2l0aW9uLnNwbGl0KFwiIFwiKVxuICAgICkpO1xuICB9XG4gIF9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGNvbnN0IHsga2V5Q29kZTogaSwgdGFyZ2V0OiBuIH0gPSBlO1xuICAgIGlmIChuLmhhc0F0dHJpYnV0ZShobykpIHtcbiAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVm4sIG4pO1xuICAgICAgaSA9PT0gbHQgJiYgKG4uY29udGVudEVkaXRhYmxlID0gITEsIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCBuLnRleHRDb250ZW50ICE9PSBcIlwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGMuYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDE2MCkgOiBuLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbi5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICB9LCAzMDApKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpID09PSBsdCkge1xuICAgICAgaWYgKG4udmFsdWUgPT09IFwiXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAobiwgbi52YWx1ZSksIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIHRoaXMubnVtYmVyQ2xpY2tzID0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgT2cpO1xuICAgIH1cbiAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgPyAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKSA6IHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApO1xuICB9XG4gIF9oYW5kbGVJbnB1dFRleHQoKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIEFnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgaC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleXVwXCIsXG4gICAgICBlLFxuICAgICAgKGkpID0+IHRoaXMuX2hhbmRsZUtleXNJbnB1dFRvRWxlbWVudChpKVxuICAgICksIGgub24odGhpcy5pbnB1dCwgXCJibHVyXCIsIChpKSA9PiB0aGlzLl9oYW5kbGVCbHVySW5wdXQoaSkpO1xuICB9XG4gIF9hcHBlbmRJbnB1dFRvRWxlbWVudChlKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gYWcodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaSk7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlcl1cIixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRoaXMuX2lucHV0SW5zdGFuY2UgPSBuZXcgVyhcbiAgICAgIG4sXG4gICAgICB0aGlzLl9vcHRpb25zLmlucHV0T3B0aW9ucyxcbiAgICAgIHRoaXMuX29wdGlvbnMuaW5wdXRDbGFzc2VzXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ3JlYXRlQ2hpcChlLCBpKSB7XG4gICAgY29uc3QgbiA9IEQoXCJkaXZcIiksIG8gPSBoaS5nZXRJbnN0YW5jZShuKSwgciA9IG5ldyBoaShvLCB7IHRleHQ6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciAhPT0gXCJcIiA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvcikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHIuYXBwZW5kQ2hpcCgpKSA6IGUuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgci5hcHBlbmRDaGlwKCkpLCBlLnZhbHVlID0gXCJcIiwgZC5maW5kKHVvKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbCA9IGhpLmdldEluc3RhbmNlKGEpO1xuICAgICAgcmV0dXJuIGwgfHwgKGwgPSBuZXcgaGkoYSwge30sIHRoaXMuX2NsYXNzZXMpKSwgbC5pbml0KCk7XG4gICAgfSksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzT25TZWxlY3QoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgaC50cmlnZ2VyKGUsIE1hLCB7XG4gICAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpIHtcbiAgICBsZXQgaTtcbiAgICB0aGlzLmFsbENoaXBzW2UgLSAxXSA9PT0gdm9pZCAwID8gaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDJdIDogaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDFdLCBpLnNldEF0dHJpYnV0ZShmdCk7XG4gIH1cbiAgX2dldENvbmZpZyhlKSB7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIC4uLk1nLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIHJldHVybiBMKHdpLCBpLCBMZyksIGk7XG4gIH1cbiAgX2dldENsYXNzZXMoZSkge1xuICAgIGNvbnN0IGkgPSBjLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUgPSB7XG4gICAgICAuLi5OZyxcbiAgICAgIC4uLmksXG4gICAgICAuLi5lXG4gICAgfSwgTCh3aSwgZSwgUmcpLCBlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlKSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YShlLCBEYSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZSwgaSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IHRoaXMoZSwgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiA/IGkgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgenQgPSB7XG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBjb2xvcjogXCJyZ2IoMTAyLDEwMiwxMDIpXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIG1pID0ge1xuICBsaW5lOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjApXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRvdWdobnV0OiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2xhckFyZWE6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJhZGFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2F0dGVyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uenQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBidWJibGU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBQZyA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIEJnKHQpICYmICFIZyh0KTtcbn07XG5mdW5jdGlvbiBCZyhzKSB7XG4gIHJldHVybiAhIXMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIEhnKHMpIHtcbiAgdmFyIHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocyk7XG4gIHJldHVybiB0ID09PSBcIltvYmplY3QgUmVnRXhwXVwiIHx8IHQgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8IEZnKHMpO1xufVxudmFyIFdnID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgVmcgPSBXZyA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDM7XG5mdW5jdGlvbiBGZyhzKSB7XG4gIHJldHVybiBzLiQkdHlwZW9mID09PSBWZztcbn1cbmZ1bmN0aW9uIFlnKHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBbXSA6IHt9O1xufVxuZnVuY3Rpb24gU2kocywgdCkge1xuICByZXR1cm4gdC5jbG9uZSAhPT0gITEgJiYgdC5pc01lcmdlYWJsZU9iamVjdChzKSA/IFhlKFlnKHMpLCBzLCB0KSA6IHM7XG59XG5mdW5jdGlvbiBqZyhzLCB0LCBlKSB7XG4gIHJldHVybiBzLmNvbmNhdCh0KS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBTaShpLCBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBLZyhzLCB0KSB7XG4gIGlmICghdC5jdXN0b21NZXJnZSlcbiAgICByZXR1cm4gWGU7XG4gIHZhciBlID0gdC5jdXN0b21NZXJnZShzKTtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBYZTtcbn1cbmZ1bmN0aW9uIHpnKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gTmEocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocykuY29uY2F0KHpnKHMpKTtcbn1cbmZ1bmN0aW9uIGJjKHMsIHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdCBpbiBzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIFVnKHMsIHQpIHtcbiAgcmV0dXJuIGJjKHMsIHQpICYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocywgdCkgJiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgdCkpO1xufVxuZnVuY3Rpb24gWGcocywgdCwgZSkge1xuICB2YXIgaSA9IHt9O1xuICByZXR1cm4gZS5pc01lcmdlYWJsZU9iamVjdChzKSAmJiBOYShzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBpW25dID0gU2koc1tuXSwgZSk7XG4gIH0pLCBOYSh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBVZyhzLCBuKSB8fCAoYmMocywgbikgJiYgZS5pc01lcmdlYWJsZU9iamVjdCh0W25dKSA/IGlbbl0gPSBLZyhuLCBlKShzW25dLCB0W25dLCBlKSA6IGlbbl0gPSBTaSh0W25dLCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gWGUocywgdCwgZSkge1xuICBlID0gZSB8fCB7fSwgZS5hcnJheU1lcmdlID0gZS5hcnJheU1lcmdlIHx8IGpnLCBlLmlzTWVyZ2VhYmxlT2JqZWN0ID0gZS5pc01lcmdlYWJsZU9iamVjdCB8fCBQZywgZS5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IFNpO1xuICB2YXIgaSA9IEFycmF5LmlzQXJyYXkodCksIG4gPSBBcnJheS5pc0FycmF5KHMpLCBvID0gaSA9PT0gbjtcbiAgcmV0dXJuIG8gPyBpID8gZS5hcnJheU1lcmdlKHMsIHQsIGUpIDogWGcocywgdCwgZSkgOiBTaSh0LCBlKTtcbn1cblhlLmFsbCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGksIG4pIHtcbiAgICByZXR1cm4gWGUoaSwgbiwgZSk7XG4gIH0sIHt9KTtcbn07XG52YXIgR2cgPSBYZSwgcG8gPSBHZztcbmNvbnN0IFJhID0gXCJjaGFydFwiLCBfcyA9IFwidGUuY2hhcnRcIiwgcWcgPSBcImNoYXJ0XCIsIFluID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgaSA9IChuLCBvLCByKSA9PiB7XG4gICAgY29uc3QgYSA9IG4uc2xpY2UoKTtcbiAgICByZXR1cm4gby5mb3JFYWNoKChsLCBwKSA9PiB7XG4gICAgICB0eXBlb2YgYVtwXSA+IFwidVwiID8gYVtwXSA9IHIuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgIGwsXG4gICAgICAgIHJcbiAgICAgICkgOiByLmlzTWVyZ2VhYmxlT2JqZWN0KGwpID8gYVtwXSA9IHBvKG5bcF0sIGwsIHIpIDogbi5pbmRleE9mKGwpID09PSAtMSAmJiBhLnB1c2gobCk7XG4gICAgfSksIGE7XG4gIH07XG4gIHJldHVybiBwbyhlW3RdLCBzLCB7XG4gICAgYXJyYXlNZXJnZTogaVxuICB9KTtcbn0sIFpnID0ge1xuICBkYXJrVGlja3NDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcIiNmZmZcIixcbiAgZGFya0dyaWRMaW5lc0NvbG9yOiBcIiM1NTVcIixcbiAgZGFya21vZGVPZmY6IFwidW5kZWZpbmVkXCIsXG4gIGRhcmtNb2RlOiBudWxsLFxuICBkYXJrQmdDb2xvcjogXCIjMjYyNjI2XCIsXG4gIGRhcmtCZ0NvbG9yTGlnaHQ6IFwiI2ZmZlwiLFxuICBvcHRpb25zOiBudWxsXG59LCBRZyA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmttb2RlT2ZmOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya01vZGU6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBkYXJrQmdDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0JnQ29sb3JMaWdodDogXCJzdHJpbmdcIixcbiAgb3B0aW9uczogXCIob2JqZWN0fG51bGwpXCJcbn07XG5jbGFzcyB2YyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgdGhpcy5fd2FpdEZvckNoYXJ0cyh0LCBlLCBpLCBuKTtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnRqcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBDaGFydDogdCxcbiAgICAgIEFyY0VsZW1lbnQ6IGUsXG4gICAgICBMaW5lRWxlbWVudDogaSxcbiAgICAgIEJhckVsZW1lbnQ6IG4sXG4gICAgICBQb2ludEVsZW1lbnQ6IG8sXG4gICAgICBCYXJDb250cm9sbGVyOiByLFxuICAgICAgQnViYmxlQ29udHJvbGxlcjogYSxcbiAgICAgIERvdWdobnV0Q29udHJvbGxlcjogbCxcbiAgICAgIExpbmVDb250cm9sbGVyOiBwLFxuICAgICAgUGllQ29udHJvbGxlcjogdSxcbiAgICAgIFBvbGFyQXJlYUNvbnRyb2xsZXI6IGYsXG4gICAgICBSYWRhckNvbnRyb2xsZXI6IF8sXG4gICAgICBTY2F0dGVyQ29udHJvbGxlcjogbSxcbiAgICAgIENhdGVnb3J5U2NhbGU6IGcsXG4gICAgICBMaW5lYXJTY2FsZTogdixcbiAgICAgIExvZ2FyaXRobWljU2NhbGU6IGIsXG4gICAgICBSYWRpYWxMaW5lYXJTY2FsZTogQyxcbiAgICAgIFRpbWVTY2FsZTogeSxcbiAgICAgIFRpbWVTZXJpZXNTY2FsZTogRSxcbiAgICAgIERlY2ltYXRpb246IFQsXG4gICAgICBGaWxsZXI6IEEsXG4gICAgICBMZWdlbmQ6IHcsXG4gICAgICBUaXRsZTogUyxcbiAgICAgIFRvb2x0aXA6IGssXG4gICAgICBTdWJUaXRsZTogeFxuICAgIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0LmVzLmpzXCIpLnRoZW4oKCQpID0+ICQuZik7XG4gICAgcmV0dXJuIHQucmVnaXN0ZXIoXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBmLFxuICAgICAgXyxcbiAgICAgIG0sXG4gICAgICBnLFxuICAgICAgdixcbiAgICAgIGIsXG4gICAgICBDLFxuICAgICAgeSxcbiAgICAgIEUsXG4gICAgICBULFxuICAgICAgQSxcbiAgICAgIHcsXG4gICAgICBTLFxuICAgICAgayxcbiAgICAgIHhcbiAgICApLCB0O1xuICB9XG4gIGFzeW5jIF9nZXRDaGFydERhdGFMYWJlbHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydChcIi4vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qc1wiKTtcbiAgfVxuICBhc3luYyBfd2FpdEZvckNoYXJ0cyh0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIGlmICh0aGlzLl9DaGFydGpzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnRqcygpLCB0aGlzLl9DaGFydERhdGFMYWJlbHMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydERhdGFMYWJlbHMoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2RhdGEgPSBlLCB0aGlzLl9vcHRpb25zID0gaSwgdGhpcy5fdHlwZSA9IGUudHlwZSwgdGhpcy5fY2FudmFzID0gbnVsbCwgdGhpcy5fY2hhcnQgPSBudWxsLCB0aGlzLl9kYXJrT3B0aW9ucyA9IHRoaXMuX2dldERhcmtDb25maWcobiksIHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKSwgdGhpcy5fcHJldkNvbmZpZyA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsIF9zLCB0aGlzKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBxZyksIHRoaXMuX2NoYXJ0Q29uc3RydWN0b3IoKSksIHRoaXMuX2RhcmtPcHRpb25zLmRhcmttb2RlT2ZmICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZGFya09wdGlvbnMuZGFya01vZGUgPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrTW9kZSA9PT0gXCJsaWdodFwiID8gXCJsaWdodFwiIDogdGhpcy5zeXN0ZW1Db2xvck1vZGU7XG4gICAgICB0aGlzLl9oYW5kbGVNb2RlKG8pLCB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29ic2VydmVyQ2FsbGJhY2suYmluZCh0aGlzKSksIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciwge1xuICAgICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBSYTtcbiAgfVxuICBnZXQgc3lzdGVtQ29sb3JNb2RlKCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UudGhlbWUgfHwgKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGFya1wiKSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBfcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgdCAmJiAodGhpcy5fZGF0YSA9IHsgLi4udGhpcy5fZGF0YSwgLi4udCB9LCB0aGlzLl9jaGFydC5kYXRhID0gdGhpcy5fZGF0YSk7XG4gICAgY29uc3QgaSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIGUsXG4gICAgICBcIm9wdGlvbnNcIlxuICAgICkgPyBlIDogeyBvcHRpb25zOiB7IC4uLmUgfSB9O1xuICAgIHRoaXMuX29wdGlvbnMgPSBwbyh0aGlzLl9vcHRpb25zLCBpKSwgdGhpcy5fY2hhcnQub3B0aW9ucyA9IFluKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3R5cGUsXG4gICAgICBtaVxuICAgICkub3B0aW9ucywgdGhpcy5fY2hhcnQudXBkYXRlKCk7XG4gIH1cbiAgc2V0VGhlbWUodCkge1xuICAgIHQgIT09IFwiZGFya1wiICYmIHQgIT09IFwibGlnaHRcIiB8fCAhdGhpcy5fZGF0YSB8fCB0aGlzLl9oYW5kbGVNb2RlKHQpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldERhcmtDb25maWcodCkge1xuICAgIGxldCBlID0ge307XG4gICAgY29uc3QgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgT2JqZWN0LmtleXMoaSkuZm9yRWFjaChcbiAgICAgIChwKSA9PiBwLnN0YXJ0c1dpdGgoXCJkYXJrXCIpICYmIChlW3BdID0gaVtwXSlcbiAgICApLCBlID0ge1xuICAgICAgLi4uWmcsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgeToge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvID0ge1xuICAgICAgcjoge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yLFxuICAgICAgICAgIGJhY2tkcm9wQ29sb3I6IGUuZGFya0JnQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBsID0ge1xuICAgICAgc2NhbGVzOiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gW1wicG9sYXJBcmVhXCIsIFwicmFkYXJcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgPyBvIDoge30gOiBuLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiBlLmRhcmtMYWJlbENvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmxcbiAgICAgIH0sXG4gICAgICAuLi50XG4gICAgfSwgTChSYSwgdCwgUWcpLCB0O1xuICB9XG4gIF9jaGFydENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IHQgPSBZbih0aGlzLl9vcHRpb25zLCB0aGlzLl90eXBlLCBtaSksIGUgPSBbXTtcbiAgICAgIHQuZGF0YUxhYmVsc1BsdWdpbiAmJiBlLnB1c2godGhpcy5fQ2hhcnREYXRhTGFiZWxzLmRlZmF1bHQpLCB0aGlzLl9wcmV2Q29uZmlnID0gdCwgdGhpcy5fY2hhcnQgPSBuZXcgdGhpcy5fQ2hhcnRqcyh0aGlzLl9jYW52YXMsIHtcbiAgICAgICAgLi4udGhpcy5fZGF0YSxcbiAgICAgICAgLi4udCxcbiAgICAgICAgcGx1Z2luczogZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDYW52YXMoKSB7XG4gICAgdGhpcy5fY2FudmFzIHx8ICh0aGlzLl9lbGVtZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiID8gdGhpcy5fY2FudmFzID0gdGhpcy5fZWxlbWVudCA6ICh0aGlzLl9jYW52YXMgPSBEKFwiY2FudmFzXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcykpKTtcbiAgfVxuICBfaGFuZGxlTW9kZSh0KSB7XG4gICAgdCA9PT0gXCJkYXJrXCIgPyAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCksIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX2RhcmtPcHRpb25zLm9wdGlvbnMpKSA6ICh0aGlzLl9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IoITEpLCB0aGlzLl9wcmV2Q29uZmlnICYmIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX3ByZXZDb25maWcpKTtcbiAgfVxuICBfb2JzZXJ2ZXJDYWxsYmFjayh0KSB7XG4gICAgZm9yIChjb25zdCBlIG9mIHQpXG4gICAgICBlLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIHRoaXMuX2hhbmRsZU1vZGUodGhpcy5zeXN0ZW1Db2xvck1vZGUpO1xuICB9XG4gIF9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IodCA9ICEwKSB7XG4gICAgWy4uLnRoaXMuX2RhdGEuZGF0YS5kYXRhc2V0c10uZm9yRWFjaChcbiAgICAgIChlKSA9PiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSAmJiAoZS5ib3JkZXJDb2xvciA9IHQgPyB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrQmdDb2xvciA6IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtCZ0NvbG9yTGlnaHQpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG4gPSBJLmdldERhdGEodGhpcywgX3MpO1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpKSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgIGNvbnN0IG8gPSBlID8gWW4oZSwgaSwgbWkpIDogbWlbaV07XG4gICAgICAgICAgbiA9IG5ldyB2Yyh0aGlzLCB7XG4gICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgLi4ub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBuW3RdKGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIF9zKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG4vKiFcbiAqIHBlcmZlY3Qtc2Nyb2xsYmFyIHYxLjUuM1xuICogQ29weXJpZ2h0IDIwMjEgSHl1bmplIEp1biwgTURCb290c3RyYXAgYW5kIENvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cbmZ1bmN0aW9uICR0KHMpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocyk7XG59XG5mdW5jdGlvbiBvdChzLCB0KSB7XG4gIGZvciAodmFyIGUgaW4gdCkge1xuICAgIHZhciBpID0gdFtlXTtcbiAgICB0eXBlb2YgaSA9PSBcIm51bWJlclwiICYmIChpID0gaSArIFwicHhcIiksIHMuc3R5bGVbZV0gPSBpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZnMocykge1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHJldHVybiB0LmNsYXNzTmFtZSA9IHMsIHQ7XG59XG52YXIgUGEgPSB0eXBlb2YgRWxlbWVudCA8IFwidVwiICYmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IpO1xuZnVuY3Rpb24gWnQocywgdCkge1xuICBpZiAoIVBhKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgbWF0Y2hpbmcgbWV0aG9kIHN1cHBvcnRlZFwiKTtcbiAgcmV0dXJuIFBhLmNhbGwocywgdCk7XG59XG5mdW5jdGlvbiBOZShzKSB7XG4gIHMucmVtb3ZlID8gcy5yZW1vdmUoKSA6IHMucGFyZW50Tm9kZSAmJiBzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocyk7XG59XG5mdW5jdGlvbiBCYShzLCB0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoXG4gICAgcy5jaGlsZHJlbixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gWnQoZSwgdCk7XG4gICAgfVxuICApO1xufVxudmFyIGogPSB7XG4gIG1haW46IFwicHNcIixcbiAgcnRsOiBcInBzX19ydGxcIixcbiAgZWxlbWVudDoge1xuICAgIHRodW1iOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwc19fdGh1bWItXCIgKyBzO1xuICAgIH0sXG4gICAgcmFpbDogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3JhaWwtXCIgKyBzO1xuICAgIH0sXG4gICAgY29uc3VtaW5nOiBcInBzX19jaGlsZC0tY29uc3VtZVwiXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgZm9jdXM6IFwicHMtLWZvY3VzXCIsXG4gICAgY2xpY2tpbmc6IFwicHMtLWNsaWNraW5nXCIsXG4gICAgYWN0aXZlOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwcy0tYWN0aXZlLVwiICsgcztcbiAgICB9LFxuICAgIHNjcm9sbGluZzogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLXNjcm9sbGluZy1cIiArIHM7XG4gICAgfVxuICB9XG59LCBUYyA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xuZnVuY3Rpb24gRWMocywgdCkge1xuICB2YXIgZSA9IHMuZWxlbWVudC5jbGFzc0xpc3QsIGkgPSBqLnN0YXRlLnNjcm9sbGluZyh0KTtcbiAgZS5jb250YWlucyhpKSA/IGNsZWFyVGltZW91dChUY1t0XSkgOiBlLmFkZChpKTtcbn1cbmZ1bmN0aW9uIENjKHMsIHQpIHtcbiAgVGNbdF0gPSBzZXRUaW1lb3V0KFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHMuaXNBbGl2ZSAmJiBzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLnNjcm9sbGluZyh0KSk7XG4gICAgfSxcbiAgICBzLnNldHRpbmdzLnNjcm9sbGluZ1RocmVzaG9sZFxuICApO1xufVxuZnVuY3Rpb24gSmcocywgdCkge1xuICBFYyhzLCB0KSwgQ2MocywgdCk7XG59XG52YXIgUGkgPSBmdW5jdGlvbih0KSB7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuaGFuZGxlcnMgPSB7fTtcbn0sIEFjID0geyBpc0VtcHR5OiB7IGNvbmZpZ3VyYWJsZTogITAgfSB9O1xuUGkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHR5cGVvZiB0aGlzLmhhbmRsZXJzW3RdID4gXCJ1XCIgJiYgKHRoaXMuaGFuZGxlcnNbdF0gPSBbXSksIHRoaXMuaGFuZGxlcnNbdF0ucHVzaChlKSwgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodCwgZSwgITEpO1xufTtcblBpLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgdGhpcy5oYW5kbGVyc1t0XSA9IHRoaXMuaGFuZGxlcnNbdF0uZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZSAmJiBuICE9PSBlID8gITAgOiAoaS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbiwgITEpLCAhMSk7XG4gIH0pO1xufTtcblBpLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgdCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgIHRoaXMudW5iaW5kKHQpO1xufTtcbkFjLmlzRW1wdHkuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzID0gdGhpcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnMpLmV2ZXJ5KFxuICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBzLmhhbmRsZXJzW3RdLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUGkucHJvdG90eXBlLCBBYyk7XG52YXIgSmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xuSmUucHJvdG90eXBlLmV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaS5lbGVtZW50ID09PSB0O1xuICB9KVswXTtcbiAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgUGkodCksIHRoaXMuZXZlbnRFbGVtZW50cy5wdXNoKGUpKSwgZTtcbn07XG5KZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQodCkuYmluZChlLCBpKTtcbn07XG5KZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpO1xuICBuLnVuYmluZChlLCBpKSwgbi5pc0VtcHR5ICYmIHRoaXMuZXZlbnRFbGVtZW50cy5zcGxpY2UodGhpcy5ldmVudEVsZW1lbnRzLmluZGV4T2YobiksIDEpO1xufTtcbkplLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnVuYmluZEFsbCgpO1xuICB9KSwgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xuSmUucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHZhciBuID0gdGhpcy5ldmVudEVsZW1lbnQodCksIG8gPSBmdW5jdGlvbihyKSB7XG4gICAgbi51bmJpbmQoZSwgbyksIGkocik7XG4gIH07XG4gIG4uYmluZChlLCBvKTtcbn07XG5mdW5jdGlvbiBtcyhzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHMpO1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gIHJldHVybiB0LmluaXRDdXN0b21FdmVudChzLCAhMSwgITEsIHZvaWQgMCksIHQ7XG59XG5mdW5jdGlvbiBCcyhzLCB0LCBlLCBpLCBuKSB7XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgbztcbiAgaWYgKHQgPT09IFwidG9wXCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgICAgXCJjb250YWluZXJIZWlnaHRcIixcbiAgICAgIFwic2Nyb2xsVG9wXCIsXG4gICAgICBcInlcIixcbiAgICAgIFwidXBcIixcbiAgICAgIFwiZG93blwiXG4gICAgXTtcbiAgZWxzZSBpZiAodCA9PT0gXCJsZWZ0XCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudFdpZHRoXCIsXG4gICAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgICBcInNjcm9sbExlZnRcIixcbiAgICAgIFwieFwiLFxuICAgICAgXCJsZWZ0XCIsXG4gICAgICBcInJpZ2h0XCJcbiAgICBdO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBwcm9wZXIgYXhpcyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gIHRiKHMsIGUsIG8sIGksIG4pO1xufVxuZnVuY3Rpb24gdGIocywgdCwgZSwgaSwgbikge1xuICB2YXIgbyA9IGVbMF0sIHIgPSBlWzFdLCBhID0gZVsyXSwgbCA9IGVbM10sIHAgPSBlWzRdLCB1ID0gZVs1XTtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITApLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIHZhciBmID0gcy5lbGVtZW50O1xuICBzLnJlYWNoW2xdID0gbnVsbCwgZlthXSA8IDEgJiYgKHMucmVhY2hbbF0gPSBcInN0YXJ0XCIpLCBmW2FdID4gc1tvXSAtIHNbcl0gLSAxICYmIChzLnJlYWNoW2xdID0gXCJlbmRcIiksIHQgJiYgKGYuZGlzcGF0Y2hFdmVudChtcyhcInBzLXNjcm9sbC1cIiArIGwpKSwgdCA8IDAgPyBmLmRpc3BhdGNoRXZlbnQobXMoXCJwcy1zY3JvbGwtXCIgKyBwKSkgOiB0ID4gMCAmJiBmLmRpc3BhdGNoRXZlbnQobXMoXCJwcy1zY3JvbGwtXCIgKyB1KSksIGkgJiYgSmcocywgbCkpLCBzLnJlYWNoW2xdICYmICh0IHx8IG4pICYmIGYuZGlzcGF0Y2hFdmVudChtcyhcInBzLVwiICsgbCArIFwiLXJlYWNoLVwiICsgcy5yZWFjaFtsXSkpO1xufVxuZnVuY3Rpb24gVihzKSB7XG4gIHJldHVybiBwYXJzZUludChzLCAxMCkgfHwgMDtcbn1cbmZ1bmN0aW9uIGViKHMpIHtcbiAgcmV0dXJuIFp0KHMsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgWnQocywgXCJzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgWnQocywgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fCBadChzLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcbn1cbmZ1bmN0aW9uIGliKHMpIHtcbiAgdmFyIHQgPSAkdChzKTtcbiAgcmV0dXJuIFYodC53aWR0aCkgKyBWKHQucGFkZGluZ0xlZnQpICsgVih0LnBhZGRpbmdSaWdodCkgKyBWKHQuYm9yZGVyTGVmdFdpZHRoKSArIFYodC5ib3JkZXJSaWdodFdpZHRoKTtcbn1cbnZhciAkZSA9IHtcbiAgaXNXZWJLaXQ6IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIFwiV2Via2l0QXBwZWFyYW5jZVwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgc3VwcG9ydHNUb3VjaDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIChcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyxcbiAgaXNDaHJvbWU6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudClcbn07XG5mdW5jdGlvbiBCdChzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBzLmNvbnRhaW5lcldpZHRoID0gTWF0aC5yb3VuZChpLndpZHRoKSwgcy5jb250YWluZXJIZWlnaHQgPSBNYXRoLnJvdW5kKGkuaGVpZ2h0KSwgcy5jb250ZW50V2lkdGggPSB0LnNjcm9sbFdpZHRoLCBzLmNvbnRlbnRIZWlnaHQgPSB0LnNjcm9sbEhlaWdodCwgdC5jb250YWlucyhzLnNjcm9sbGJhclhSYWlsKSB8fCAoQmEodCwgai5lbGVtZW50LnJhaWwoXCJ4XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBOZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJYUmFpbCkpLCB0LmNvbnRhaW5zKHMuc2Nyb2xsYmFyWVJhaWwpIHx8IChCYSh0LCBqLmVsZW1lbnQucmFpbChcInlcIikpLmZvckVhY2goXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIE5lKG4pO1xuICAgIH1cbiAgKSwgdC5hcHBlbmRDaGlsZChzLnNjcm9sbGJhcllSYWlsKSksICFzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBzLmNvbnRhaW5lcldpZHRoICsgcy5zZXR0aW5ncy5zY3JvbGxYTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50V2lkdGggPyAocy5zY3JvbGxiYXJYQWN0aXZlID0gITAsIHMucmFpbFhXaWR0aCA9IHMuY29udGFpbmVyV2lkdGggLSBzLnJhaWxYTWFyZ2luV2lkdGgsIHMucmFpbFhSYXRpbyA9IHMuY29udGFpbmVyV2lkdGggLyBzLnJhaWxYV2lkdGgsIHMuc2Nyb2xsYmFyWFdpZHRoID0gSGEoXG4gICAgcyxcbiAgICBWKHMucmFpbFhXaWR0aCAqIHMuY29udGFpbmVyV2lkdGggLyBzLmNvbnRlbnRXaWR0aClcbiAgKSwgcy5zY3JvbGxiYXJYTGVmdCA9IFYoXG4gICAgKHMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgdC5zY3JvbGxMZWZ0KSAqIChzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCkgLyAocy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoKVxuICApKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICExLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgcy5jb250YWluZXJIZWlnaHQgKyBzLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBzLmNvbnRlbnRIZWlnaHQgPyAocy5zY3JvbGxiYXJZQWN0aXZlID0gITAsIHMucmFpbFlIZWlnaHQgPSBzLmNvbnRhaW5lckhlaWdodCAtIHMucmFpbFlNYXJnaW5IZWlnaHQsIHMucmFpbFlSYXRpbyA9IHMuY29udGFpbmVySGVpZ2h0IC8gcy5yYWlsWUhlaWdodCwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gSGEoXG4gICAgcyxcbiAgICBWKHMucmFpbFlIZWlnaHQgKiBzLmNvbnRhaW5lckhlaWdodCAvIHMuY29udGVudEhlaWdodClcbiAgKSwgcy5zY3JvbGxiYXJZVG9wID0gVihcbiAgICBlICogKHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpIC8gKHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0KVxuICApKSA6IHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICExLCBzLnNjcm9sbGJhclhMZWZ0ID49IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoICYmIChzLnNjcm9sbGJhclhMZWZ0ID0gcy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpLCBzLnNjcm9sbGJhcllUb3AgPj0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCAmJiAocy5zY3JvbGxiYXJZVG9wID0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCksIHNiKHQsIHMpLCBzLnNjcm9sbGJhclhBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSwgcy5zY3JvbGxiYXJYV2lkdGggPSAwLCBzLnNjcm9sbGJhclhMZWZ0ID0gMCwgdC5zY3JvbGxMZWZ0ID0gcy5pc1J0bCA9PT0gITAgPyBzLmNvbnRlbnRXaWR0aCA6IDApLCBzLnNjcm9sbGJhcllBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gMCwgcy5zY3JvbGxiYXJZVG9wID0gMCwgdC5zY3JvbGxUb3AgPSAwKTtcbn1cbmZ1bmN0aW9uIEhhKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5tYXgodCwgcy5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpKSwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGggJiYgKHQgPSBNYXRoLm1pbih0LCBzLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkpLCB0O1xufVxuZnVuY3Rpb24gc2IocywgdCkge1xuICB2YXIgZSA9IHsgd2lkdGg6IHQucmFpbFhXaWR0aCB9LCBpID0gTWF0aC5mbG9vcihzLnNjcm9sbFRvcCk7XG4gIHQuaXNSdGwgPyBlLmxlZnQgPSB0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCArIHQuY29udGFpbmVyV2lkdGggLSB0LmNvbnRlbnRXaWR0aCA6IGUubGVmdCA9IHMuc2Nyb2xsTGVmdCwgdC5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IGUuYm90dG9tID0gdC5zY3JvbGxiYXJYQm90dG9tIC0gaSA6IGUudG9wID0gdC5zY3JvbGxiYXJYVG9wICsgaSwgb3QodC5zY3JvbGxiYXJYUmFpbCwgZSk7XG4gIHZhciBuID0geyB0b3A6IGksIGhlaWdodDogdC5yYWlsWUhlaWdodCB9O1xuICB0LmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPyB0LmlzUnRsID8gbi5yaWdodCA9IHQuY29udGVudFdpZHRoIC0gKHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0KSAtIHQuc2Nyb2xsYmFyWVJpZ2h0IC0gdC5zY3JvbGxiYXJZT3V0ZXJXaWR0aCAtIDkgOiBuLnJpZ2h0ID0gdC5zY3JvbGxiYXJZUmlnaHQgLSBzLnNjcm9sbExlZnQgOiB0LmlzUnRsID8gbi5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoICogMiAtIHQuY29udGVudFdpZHRoIC0gdC5zY3JvbGxiYXJZTGVmdCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggOiBuLmxlZnQgPSB0LnNjcm9sbGJhcllMZWZ0ICsgcy5zY3JvbGxMZWZ0LCBvdCh0LnNjcm9sbGJhcllSYWlsLCBuKSwgb3QodC5zY3JvbGxiYXJYLCB7XG4gICAgbGVmdDogdC5zY3JvbGxiYXJYTGVmdCxcbiAgICB3aWR0aDogdC5zY3JvbGxiYXJYV2lkdGggLSB0LnJhaWxCb3JkZXJYV2lkdGhcbiAgfSksIG90KHQuc2Nyb2xsYmFyWSwge1xuICAgIHRvcDogdC5zY3JvbGxiYXJZVG9wLFxuICAgIGhlaWdodDogdC5zY3JvbGxiYXJZSGVpZ2h0IC0gdC5yYWlsQm9yZGVyWVdpZHRoXG4gIH0pO1xufVxuZnVuY3Rpb24gbmIocykge1xuICBzLmVsZW1lbnQsIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclksIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhcllSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gcy5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AsIGkgPSBlID4gcy5zY3JvbGxiYXJZVG9wID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxUb3AgKz0gaSAqIHMuY29udGFpbmVySGVpZ2h0LCBCdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclgsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclhSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0IC0gcy5zY3JvbGxiYXJYUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LCBpID0gZSA+IHMuc2Nyb2xsYmFyWExlZnQgPyAxIDogLTE7XG4gICAgcy5lbGVtZW50LnNjcm9sbExlZnQgKz0gaSAqIHMuY29udGFpbmVyV2lkdGgsIEJ0KHMpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iKHMpIHtcbiAgV2EocywgW1xuICAgIFwiY29udGFpbmVyV2lkdGhcIixcbiAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgIFwicGFnZVhcIixcbiAgICBcInJhaWxYV2lkdGhcIixcbiAgICBcInNjcm9sbGJhclhcIixcbiAgICBcInNjcm9sbGJhclhXaWR0aFwiLFxuICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgIFwieFwiLFxuICAgIFwic2Nyb2xsYmFyWFJhaWxcIlxuICBdKSwgV2EocywgW1xuICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgXCJjb250ZW50SGVpZ2h0XCIsXG4gICAgXCJwYWdlWVwiLFxuICAgIFwicmFpbFlIZWlnaHRcIixcbiAgICBcInNjcm9sbGJhcllcIixcbiAgICBcInNjcm9sbGJhcllIZWlnaHRcIixcbiAgICBcInNjcm9sbFRvcFwiLFxuICAgIFwieVwiLFxuICAgIFwic2Nyb2xsYmFyWVJhaWxcIlxuICBdKTtcbn1cbmZ1bmN0aW9uIFdhKHMsIHQpIHtcbiAgdmFyIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl0sIG8gPSB0WzNdLCByID0gdFs0XSwgYSA9IHRbNV0sIGwgPSB0WzZdLCBwID0gdFs3XSwgdSA9IHRbOF0sIGYgPSBzLmVsZW1lbnQsIF8gPSBudWxsLCBtID0gbnVsbCwgZyA9IG51bGw7XG4gIGZ1bmN0aW9uIHYoeSkge1xuICAgIHkudG91Y2hlcyAmJiB5LnRvdWNoZXNbMF0gJiYgKHlbbl0gPSB5LnRvdWNoZXNbMF0ucGFnZVkpLCBmW2xdID0gXyArIGcgKiAoeVtuXSAtIG0pLCBFYyhzLCBwKSwgQnQocyksIHkuc3RvcFByb3BhZ2F0aW9uKCksIHkudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikgJiYgeS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAxICYmIHkucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBiKCkge1xuICAgIENjKHMsIHApLCBzW3VdLmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5jbGlja2luZyksIHMuZXZlbnQudW5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgdik7XG4gIH1cbiAgZnVuY3Rpb24gQyh5LCBFKSB7XG4gICAgXyA9IGZbbF0sIEUgJiYgeS50b3VjaGVzICYmICh5W25dID0geS50b3VjaGVzWzBdLnBhZ2VZKSwgbSA9IHlbbl0sIGcgPSAoc1tpXSAtIHNbZV0pIC8gKHNbb10gLSBzW2FdKSwgRSA/IHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwidG91Y2htb3ZlXCIsIHYpIDogKHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIHYpLCBzLmV2ZW50Lm9uY2Uocy5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgYiksIHkucHJldmVudERlZmF1bHQoKSksIHNbdV0uY2xhc3NMaXN0LmFkZChqLnN0YXRlLmNsaWNraW5nKSwgeS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBzLmV2ZW50LmJpbmQoc1tyXSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oeSkge1xuICAgIEMoeSk7XG4gIH0pLCBzLmV2ZW50LmJpbmQoc1tyXSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICBDKHksICEwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByYihzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFp0KHQsIFwiOmhvdmVyXCIpO1xuICB9LCBpID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFp0KHMuc2Nyb2xsYmFyWCwgXCI6Zm9jdXNcIikgfHwgWnQocy5zY3JvbGxiYXJZLCBcIjpmb2N1c1wiKTtcbiAgfTtcbiAgZnVuY3Rpb24gbihvLCByKSB7XG4gICAgdmFyIGEgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKTtcbiAgICBpZiAobyA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhcllBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChhID09PSAwICYmIHIgPiAwIHx8IGEgPj0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgJiYgciA8IDApXG4gICAgICAgIHJldHVybiAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgbCA9IHQuc2Nyb2xsTGVmdDtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhclhBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChsID09PSAwICYmIG8gPCAwIHx8IGwgPj0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoICYmIG8gPiAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCEoby5pc0RlZmF1bHRQcmV2ZW50ZWQgJiYgby5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBvLmRlZmF1bHRQcmV2ZW50ZWQpICYmICEoIWUoKSAmJiAhaSgpKSkge1xuICAgICAgdmFyIHIgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IHMub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgaWYgKHIudGFnTmFtZSA9PT0gXCJJRlJBTUVcIilcbiAgICAgICAgICByID0gci5jb250ZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyByLnNoYWRvd1Jvb3Q7IClcbiAgICAgICAgICAgIHIgPSByLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKGViKHIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gMCwgbCA9IDA7XG4gICAgICBzd2l0Y2ggKG8ud2hpY2gpIHtcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gLXMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gLXMuY29udGFpbmVyV2lkdGggOiBhID0gLTMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSBzLmNvbnRlbnRIZWlnaHQgOiBvLmFsdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gcy5jb250ZW50V2lkdGggOiBvLmFsdEtleSA/IGEgPSBzLmNvbnRhaW5lcldpZHRoIDogYSA9IDMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSAtcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gLXMuY29udGFpbmVySGVpZ2h0IDogbCA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBvLnNoaWZ0S2V5ID8gbCA9IHMuY29udGFpbmVySGVpZ2h0IDogbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICBsID0gcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBsID0gcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGwgPSAtcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGEgIT09IDAgfHwgcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgbCAhPT0gMCB8fCAodC5zY3JvbGxUb3AgLT0gbCwgdC5zY3JvbGxMZWZ0ICs9IGEsIEJ0KHMpLCBuKGEsIGwpICYmIG8ucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFiKHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGUociwgYSkge1xuICAgIHZhciBsID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIHAgPSB0LnNjcm9sbFRvcCA9PT0gMCwgdSA9IGwgKyB0Lm9mZnNldEhlaWdodCA9PT0gdC5zY3JvbGxIZWlnaHQsIGYgPSB0LnNjcm9sbExlZnQgPT09IDAsIF8gPSB0LnNjcm9sbExlZnQgKyB0Lm9mZnNldFdpZHRoID09PSB0LnNjcm9sbFdpZHRoLCBtO1xuICAgIHJldHVybiBNYXRoLmFicyhhKSA+IE1hdGguYWJzKHIpID8gbSA9IHAgfHwgdSA6IG0gPSBmIHx8IF8sIG0gPyAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uIDogITA7XG4gIH1cbiAgZnVuY3Rpb24gaShyKSB7XG4gICAgdmFyIGEgPSByLmRlbHRhWCwgbCA9IC0xICogci5kZWx0YVk7XG4gICAgcmV0dXJuICh0eXBlb2YgYSA+IFwidVwiIHx8IHR5cGVvZiBsID4gXCJ1XCIpICYmIChhID0gLTEgKiByLndoZWVsRGVsdGFYIC8gNiwgbCA9IHIud2hlZWxEZWx0YVkgLyA2KSwgci5kZWx0YU1vZGUgJiYgci5kZWx0YU1vZGUgPT09IDEgJiYgKGEgKj0gMTAsIGwgKj0gMTApLCBhICE9PSBhICYmIGwgIT09IGwgJiYgKGEgPSAwLCBsID0gci53aGVlbERlbHRhKSwgci5zaGlmdEtleSA/IFstbCwgLWFdIDogW2EsIGxdO1xuICB9XG4gIGZ1bmN0aW9uIG4ociwgYSwgbCkge1xuICAgIGlmICghJGUuaXNXZWJLaXQgJiYgdC5xdWVyeVNlbGVjdG9yKFwic2VsZWN0OmZvY3VzXCIpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmICghdC5jb250YWlucyhyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBwID0gcjsgcCAmJiBwICE9PSB0OyApIHtcbiAgICAgIGlmIChwLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHUgPSAkdChwKTtcbiAgICAgIGlmIChsICYmIHUub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIGYgPSBwLnNjcm9sbEhlaWdodCAtIHAuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoZiA+IDAgJiYgKHAuc2Nyb2xsVG9wID4gMCAmJiBsIDwgMCB8fCBwLnNjcm9sbFRvcCA8IGYgJiYgbCA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChhICYmIHUub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIF8gPSBwLnNjcm9sbFdpZHRoIC0gcC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKF8gPiAwICYmIChwLnNjcm9sbExlZnQgPiAwICYmIGEgPCAwIHx8IHAuc2Nyb2xsTGVmdCA8IF8gJiYgYSA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBvKHIpIHtcbiAgICB2YXIgYSA9IGkociksIGwgPSBhWzBdLCBwID0gYVsxXTtcbiAgICBpZiAoIW4oci50YXJnZXQsIGwsIHApKSB7XG4gICAgICB2YXIgdSA9ICExO1xuICAgICAgcy5zZXR0aW5ncy51c2VCb3RoV2hlZWxBeGVzID8gcy5zY3JvbGxiYXJZQWN0aXZlICYmICFzLnNjcm9sbGJhclhBY3RpdmUgPyAocCA/IHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbFRvcCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogcy5zY3JvbGxiYXJYQWN0aXZlICYmICFzLnNjcm9sbGJhcllBY3RpdmUgJiYgKGwgPyB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCA6IHQuc2Nyb2xsTGVmdCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogKHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIHQuc2Nyb2xsTGVmdCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkKSwgQnQocyksIHUgPSB1IHx8IGUobCwgcCksIHUgJiYgIXIuY3RybEtleSAmJiAoci5zdG9wUHJvcGFnYXRpb24oKSwgci5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gIH1cbiAgdHlwZW9mIHdpbmRvdy5vbndoZWVsIDwgXCJ1XCIgPyBzLmV2ZW50LmJpbmQodCwgXCJ3aGVlbFwiLCBvKSA6IHR5cGVvZiB3aW5kb3cub25tb3VzZXdoZWVsIDwgXCJ1XCIgJiYgcy5ldmVudC5iaW5kKHQsIFwibW91c2V3aGVlbFwiLCBvKTtcbn1cbmZ1bmN0aW9uIGxiKHMpIHtcbiAgaWYgKCEkZS5zdXBwb3J0c1RvdWNoICYmICEkZS5zdXBwb3J0c0llUG9pbnRlcilcbiAgICByZXR1cm47XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKGcsIHYpIHtcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBDID0gdC5zY3JvbGxMZWZ0LCB5ID0gTWF0aC5hYnMoZyksIEUgPSBNYXRoLmFicyh2KTtcbiAgICBpZiAoRSA+IHkpIHtcbiAgICAgIGlmICh2IDwgMCAmJiBiID09PSBzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodCB8fCB2ID4gMCAmJiBiID09PSAwKVxuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPT09IDAgJiYgdiA+IDAgJiYgJGUuaXNDaHJvbWU7XG4gICAgfSBlbHNlIGlmICh5ID4gRSAmJiAoZyA8IDAgJiYgQyA9PT0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoIHx8IGcgPiAwICYmIEMgPT09IDApKVxuICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBmdW5jdGlvbiBpKGcsIHYpIHtcbiAgICB0LnNjcm9sbFRvcCAtPSB2LCB0LnNjcm9sbExlZnQgLT0gZywgQnQocyk7XG4gIH1cbiAgdmFyIG4gPSB7fSwgbyA9IDAsIHIgPSB7fSwgYSA9IG51bGw7XG4gIGZ1bmN0aW9uIGwoZykge1xuICAgIHJldHVybiBnLnRhcmdldFRvdWNoZXMgPyBnLnRhcmdldFRvdWNoZXNbMF0gOiBnO1xuICB9XG4gIGZ1bmN0aW9uIHAoZykge1xuICAgIHJldHVybiBnLnBvaW50ZXJUeXBlICYmIGcucG9pbnRlclR5cGUgPT09IFwicGVuXCIgJiYgZy5idXR0b25zID09PSAwID8gITEgOiAhIShnLnRhcmdldFRvdWNoZXMgJiYgZy50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSB8fCBnLnBvaW50ZXJUeXBlICYmIGcucG9pbnRlclR5cGUgIT09IFwibW91c2VcIiAmJiBnLnBvaW50ZXJUeXBlICE9PSBnLk1TUE9JTlRFUl9UWVBFX01PVVNFKTtcbiAgfVxuICBmdW5jdGlvbiB1KGcpIHtcbiAgICBpZiAocChnKSkge1xuICAgICAgdmFyIHYgPSBsKGcpO1xuICAgICAgbi5wYWdlWCA9IHYucGFnZVgsIG4ucGFnZVkgPSB2LnBhZ2VZLCBvID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIGEgIT09IG51bGwgJiYgY2xlYXJJbnRlcnZhbChhKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZihnLCB2LCBiKSB7XG4gICAgaWYgKCF0LmNvbnRhaW5zKGcpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIEMgPSBnOyBDICYmIEMgIT09IHQ7ICkge1xuICAgICAgaWYgKEMuY2xhc3NMaXN0LmNvbnRhaW5zKGouZWxlbWVudC5jb25zdW1pbmcpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgeSA9ICR0KEMpO1xuICAgICAgaWYgKGIgJiYgeS5vdmVyZmxvd1kubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgRSA9IEMuc2Nyb2xsSGVpZ2h0IC0gQy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChFID4gMCAmJiAoQy5zY3JvbGxUb3AgPiAwICYmIGIgPCAwIHx8IEMuc2Nyb2xsVG9wIDwgRSAmJiBiID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKHYgJiYgeS5vdmVyZmxvd1gubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgVCA9IEMuc2Nyb2xsV2lkdGggLSBDLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoVCA+IDAgJiYgKEMuc2Nyb2xsTGVmdCA+IDAgJiYgdiA8IDAgfHwgQy5zY3JvbGxMZWZ0IDwgVCAmJiB2ID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgQyA9IEMucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIF8oZykge1xuICAgIGlmIChwKGcpKSB7XG4gICAgICB2YXIgdiA9IGwoZyksIGIgPSB7IHBhZ2VYOiB2LnBhZ2VYLCBwYWdlWTogdi5wYWdlWSB9LCBDID0gYi5wYWdlWCAtIG4ucGFnZVgsIHkgPSBiLnBhZ2VZIC0gbi5wYWdlWTtcbiAgICAgIGlmIChmKGcudGFyZ2V0LCBDLCB5KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaShDLCB5KSwgbiA9IGI7XG4gICAgICB2YXIgRSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBUID0gRSAtIG87XG4gICAgICBUID4gMCAmJiAoci54ID0gQyAvIFQsIHIueSA9IHkgLyBULCBvID0gRSksIGUoQywgeSkgJiYgZy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtKCkge1xuICAgIHMuc2V0dGluZ3Muc3dpcGVFYXNpbmcgJiYgKGNsZWFySW50ZXJ2YWwoYSksIGEgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFyLnggJiYgIXIueSkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoci54KSA8IDAuMDEgJiYgTWF0aC5hYnMoci55KSA8IDAuMDEpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzLmVsZW1lbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaShyLnggKiAzMCwgci55ICogMzApLCByLnggKj0gMC44LCByLnkgKj0gMC44O1xuICAgIH0sIDEwKSk7XG4gIH1cbiAgJGUuc3VwcG9ydHNUb3VjaCA/IChzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaHN0YXJ0XCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaG1vdmVcIiwgXyksIHMuZXZlbnQuYmluZCh0LCBcInRvdWNoZW5kXCIsIG0pKSA6ICRlLnN1cHBvcnRzSWVQb2ludGVyICYmICh3aW5kb3cuUG9pbnRlckV2ZW50ID8gKHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJkb3duXCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVybW92ZVwiLCBfKSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcnVwXCIsIG0pKSA6IHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAocy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyRG93blwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyTW92ZVwiLCBfKSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyVXBcIiwgbSkpKTtcbn1cbnZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcImtleWJvYXJkXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXSxcbiAgICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIHNjcm9sbGluZ1RocmVzaG9sZDogMWUzLFxuICAgIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICAgIHN1cHByZXNzU2Nyb2xsWTogITEsXG4gICAgc3dpcGVFYXNpbmc6ICEwLFxuICAgIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICAgIHdoZWVsUHJvcGFnYXRpb246ICEwLFxuICAgIHdoZWVsU3BlZWQ6IDFcbiAgfTtcbn0sIGhiID0ge1xuICBcImNsaWNrLXJhaWxcIjogbmIsXG4gIFwiZHJhZy10aHVtYlwiOiBvYixcbiAga2V5Ym9hcmQ6IHJiLFxuICB3aGVlbDogYWIsXG4gIHRvdWNoOiBsYlxufSwgQmkgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkpLCAhdCB8fCAhdC5ub2RlTmFtZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBlbGVtZW50IGlzIHNwZWNpZmllZCB0byBpbml0aWFsaXplIFBlcmZlY3RTY3JvbGxiYXJcIik7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHQuY2xhc3NMaXN0LmFkZChqLm1haW4pLCB0aGlzLnNldHRpbmdzID0gY2IoKTtcbiAgZm9yICh2YXIgbiBpbiBlKVxuICAgIHRoaXMuc2V0dGluZ3Nbbl0gPSBlW25dO1xuICB0aGlzLmNvbnRhaW5lcldpZHRoID0gbnVsbCwgdGhpcy5jb250YWluZXJIZWlnaHQgPSBudWxsLCB0aGlzLmNvbnRlbnRXaWR0aCA9IG51bGwsIHRoaXMuY29udGVudEhlaWdodCA9IG51bGw7XG4gIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmZvY3VzKTtcbiAgfSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5mb2N1cyk7XG4gIH07XG4gIHRoaXMuaXNSdGwgPSAkdCh0KS5kaXJlY3Rpb24gPT09IFwicnRsXCIsIHRoaXMuaXNSdGwgPT09ICEwICYmIHQuY2xhc3NMaXN0LmFkZChqLnJ0bCksIHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0gdC5zY3JvbGxMZWZ0LCB1ID0gbnVsbDtcbiAgICByZXR1cm4gdC5zY3JvbGxMZWZ0ID0gLTEsIHUgPSB0LnNjcm9sbExlZnQgPCAwLCB0LnNjcm9sbExlZnQgPSBwLCB1O1xuICB9KCksIHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdC5zY3JvbGxXaWR0aCAtIHQuY2xpZW50V2lkdGggOiAwLCB0aGlzLmV2ZW50ID0gbmV3IEplKCksIHRoaXMub3duZXJEb2N1bWVudCA9IHQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IGZzKGouZWxlbWVudC5yYWlsKFwieFwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYUmFpbCksIHRoaXMuc2Nyb2xsYmFyWCA9IGZzKGouZWxlbWVudC50aHVtYihcInhcIikpLCB0aGlzLnNjcm9sbGJhclhSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWCksIHRoaXMuc2Nyb2xsYmFyWC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhclhBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhclhXaWR0aCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWExlZnQgPSBudWxsO1xuICB2YXIgYSA9ICR0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpO1xuICB0aGlzLnNjcm9sbGJhclhCb3R0b20gPSBwYXJzZUludChhLmJvdHRvbSwgMTApLCBpc05hTih0aGlzLnNjcm9sbGJhclhCb3R0b20pID8gKHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMSwgdGhpcy5zY3JvbGxiYXJYVG9wID0gVihhLnRvcCkpIDogdGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9ICEwLCB0aGlzLnJhaWxCb3JkZXJYV2lkdGggPSBWKGEuYm9yZGVyTGVmdFdpZHRoKSArIFYoYS5ib3JkZXJSaWdodFdpZHRoKSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IFYoYS5tYXJnaW5MZWZ0KSArIFYoYS5tYXJnaW5SaWdodCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgdGhpcy5yYWlsWFdpZHRoID0gbnVsbCwgdGhpcy5yYWlsWFJhdGlvID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IGZzKGouZWxlbWVudC5yYWlsKFwieVwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMuc2Nyb2xsYmFyWSA9IGZzKGouZWxlbWVudC50aHVtYihcInlcIikpLCB0aGlzLnNjcm9sbGJhcllSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWSksIHRoaXMuc2Nyb2xsYmFyWS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllUb3AgPSBudWxsO1xuICB2YXIgbCA9ICR0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpO1xuICB0aGlzLnNjcm9sbGJhcllSaWdodCA9IHBhcnNlSW50KGwucmlnaHQsIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJZUmlnaHQpID8gKHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICExLCB0aGlzLnNjcm9sbGJhcllMZWZ0ID0gVihsLmxlZnQpKSA6IHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICEwLCB0aGlzLnNjcm9sbGJhcllPdXRlcldpZHRoID0gdGhpcy5pc1J0bCA/IGliKHRoaXMuc2Nyb2xsYmFyWSkgOiBudWxsLCB0aGlzLnJhaWxCb3JkZXJZV2lkdGggPSBWKGwuYm9yZGVyVG9wV2lkdGgpICsgVihsLmJvcmRlckJvdHRvbVdpZHRoKSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBWKGwubWFyZ2luVG9wKSArIFYobC5tYXJnaW5Cb3R0b20pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFlIZWlnaHQgPSBudWxsLCB0aGlzLnJhaWxZUmF0aW8gPSBudWxsLCB0aGlzLnJlYWNoID0ge1xuICAgIHg6IHQuc2Nyb2xsTGVmdCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxMZWZ0ID49IHRoaXMuY29udGVudFdpZHRoIC0gdGhpcy5jb250YWluZXJXaWR0aCA/IFwiZW5kXCIgOiBudWxsLFxuICAgIHk6IHQuc2Nyb2xsVG9wIDw9IDAgPyBcInN0YXJ0XCIgOiB0LnNjcm9sbFRvcCA+PSB0aGlzLmNvbnRlbnRIZWlnaHQgLSB0aGlzLmNvbnRhaW5lckhlaWdodCA/IFwiZW5kXCIgOiBudWxsXG4gIH0sIHRoaXMuaXNBbGl2ZSA9ICEwLCB0aGlzLnNldHRpbmdzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBoYltwXShpKTtcbiAgfSksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdC5zY3JvbGxMZWZ0LCB0aGlzLmV2ZW50LmJpbmQodGhpcy5lbGVtZW50LCBcInNjcm9sbFwiLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGkub25TY3JvbGwocCk7XG4gIH0pLCBCdCh0aGlzKTtcbn07XG5CaS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAodGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPyB0aGlzLmVsZW1lbnQuc2Nyb2xsV2lkdGggLSB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGggOiAwLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IFYoJHQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luTGVmdCkgKyBWKCR0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpblJpZ2h0KSwgdGhpcy5yYWlsWU1hcmdpbkhlaWdodCA9IFYoJHQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luVG9wKSArIFYoJHQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luQm90dG9tKSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgQnQodGhpcyksIEJzKHRoaXMsIFwidG9wXCIsIDAsICExLCAhMCksIEJzKHRoaXMsIFwibGVmdFwiLCAwLCAhMSwgITApLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSk7XG59O1xuQmkucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKEJ0KHRoaXMpLCBCcyh0aGlzLCBcInRvcFwiLCB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wIC0gdGhpcy5sYXN0U2Nyb2xsVG9wKSwgQnMoXG4gICAgdGhpcyxcbiAgICBcImxlZnRcIixcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCAtIHRoaXMubGFzdFNjcm9sbExlZnRcbiAgKSwgdGhpcy5sYXN0U2Nyb2xsVG9wID0gTWF0aC5mbG9vcih0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KTtcbn07XG5CaS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMuZXZlbnQudW5iaW5kQWxsKCksIE5lKHRoaXMuc2Nyb2xsYmFyWCksIE5lKHRoaXMuc2Nyb2xsYmFyWSksIE5lKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCBOZSh0aGlzLnNjcm9sbGJhcllSYWlsKSwgdGhpcy5yZW1vdmVQc0NsYXNzZXMoKSwgdGhpcy5lbGVtZW50ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSBudWxsLCB0aGlzLmlzQWxpdmUgPSAhMSk7XG59O1xuQmkucHJvdG90eXBlLnJlbW92ZVBzQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gIXQubWF0Y2goL15wcyhbLV9dLit8KSQvKTtcbiAgfSkuam9pbihcIiBcIik7XG59O1xuY29uc3Qgam4gPSBcInBlcmZlY3RTY3JvbGxiYXJcIiwgZGIgPSBcInBlcmZlY3Qtc2Nyb2xsYmFyXCIsIGdzID0gXCJ0ZS5wZXJmZWN0U2Nyb2xsYmFyXCIsIGt0ID0gXCJ0ZVwiLCBPdCA9IFwicHNcIiwgS24gPSBbXG4gIHsgdGU6IGBzY3JvbGxYLiR7a3R9LiR7T3R9YCwgcHM6IFwicHMtc2Nyb2xsLXhcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWS4ke2t0fS4ke090fWAsIHBzOiBcInBzLXNjcm9sbC15XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFVwLiR7a3R9LiR7T3R9YCwgcHM6IFwicHMtc2Nyb2xsLXVwXCIgfSxcbiAgeyB0ZTogYHNjcm9sbERvd24uJHtrdH0uJHtPdH1gLCBwczogXCJwcy1zY3JvbGwtZG93blwiIH0sXG4gIHsgdGU6IGBzY3JvbGxMZWZ0LiR7a3R9LiR7T3R9YCwgcHM6IFwicHMtc2Nyb2xsLWxlZnRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsUmlnaHQuJHtrdH0uJHtPdH1gLCBwczogXCJwcy1zY3JvbGwtcmlnaHRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWEVuZC4ke2t0fS4ke090fWAsIHBzOiBcInBzLXgtcmVhY2gtZW5kXCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlFbmQuJHtrdH0uJHtPdH1gLCBwczogXCJwcy15LXJlYWNoLWVuZFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxYU3RhcnQuJHtrdH0uJHtPdH1gLCBwczogXCJwcy14LXJlYWNoLXN0YXJ0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlTdGFydC4ke2t0fS4ke090fWAsIHBzOiBcInBzLXktcmVhY2gtc3RhcnRcIiB9XG5dLCB1YiA9IHtcbiAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwia2V5Ym9hcmRcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdLFxuICB3aGVlbFNwZWVkOiAxLFxuICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgc3dpcGVFYXNpbmc6ICEwLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgc2Nyb2xsaW5nVGhyZXNob2xkOiAxZTMsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICBwb3NpdGlvblJpZ2h0OiAhMFxufSwgcGIgPSB7XG4gIGhhbmRsZXJzOiBcIihzdHJpbmd8YXJyYXkpXCIsXG4gIHdoZWVsU3BlZWQ6IFwibnVtYmVyXCIsXG4gIHdoZWVsUHJvcGFnYXRpb246IFwiYm9vbGVhblwiLFxuICBzd2lwZUVhc2luZzogXCJib29sZWFuXCIsXG4gIG1pblNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogXCJudW1iZXJcIixcbiAgdXNlQm90aFdoZWVsQXhlczogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWDogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWTogXCJib29sZWFuXCIsXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHBvc2l0aW9uUmlnaHQ6IFwiYm9vbGVhblwiXG59LCBfYiA9IHtcbiAgcHM6IFwiZ3JvdXAvcHMgb3ZlcmZsb3ctaGlkZGVuIFtvdmVyZmxvdy1hbmNob3I6bm9uZV0gdG91Y2gtbm9uZVwiLFxuICByYWlsWDogXCJncm91cC94IGFic29sdXRlIGJvdHRvbS0wIGgtWzAuOTM3NXJlbV0gaGlkZGVuIG9wYWNpdHktMCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLF9vcGFjaXR5XSBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgei1bMTAzNV0gZ3JvdXAtWyYucHMtLWFjdGl2ZS14XS9wczpibG9jayBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy14XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGZvY3VzOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgb3V0bGluZS1ub25lXCIsXG4gIHJhaWxYQ29sb3JzOiBcImdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmctdHJhbnNwYXJlbnQgaG92ZXI6IWJnLVsjZWVlXSBmb2N1czohYmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IWJnLVsjZWVlXSBkYXJrOmhvdmVyOiFiZy1bIzU1NV0gZGFyazpmb2N1czohYmctWyM1NTVdIGRhcms6WyYucHMtLWNsaWNraW5nXTohYmctWyM1NTVdXCIsXG4gIHJhaWxYVGh1bWI6IFwiYWJzb2x1dGUgYm90dG9tLTAuNSByb3VuZGVkLW1kIGgtMS41IGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktMTAwIGdyb3VwLWFjdGl2ZS9wczpvcGFjaXR5LTEwMCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX2hlaWdodF8uMnNfZWFzZS1pbi1vdXRdIGdyb3VwLWhvdmVyL3g6aC1bMTFweF0gZ3JvdXAtZm9jdXMveDpoLVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS94OmgtWzExcHhdIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWFRodW1iQ29sb3JzOiBcImJnLVsjYWFhXSBncm91cC1ob3Zlci94OmJnLVsjOTk5XSBncm91cC1mb2N1cy94OmJnLVsjOTk5XVwiLFxuICByYWlsWTogXCJncm91cC95IGFic29sdXRlIHJpZ2h0LTAgdy1bMC45Mzc1cmVtXSBoaWRkZW4gb3BhY2l0eS0wIHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsX29wYWNpdHldIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSB6LVsxMDM1XSBncm91cC1bJi5wcy0tYWN0aXZlLXldL3BzOmJsb2NrIGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktNjAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS02MCBncm91cC1bJi5wcy0tc2Nyb2xsaW5nLXldL3BzOm9wYWNpdHktNjAgaG92ZXI6IW9wYWNpdHktOTAgZm9jdXM6IW9wYWNpdHktOTAgWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlDb2xvcnM6IFwiZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpiZy10cmFuc3BhcmVudCBob3ZlcjohYmctWyNlZWVdIGZvY3VzOiFiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohYmctWyNlZWVdIGRhcms6aG92ZXI6IWJnLVsjNTU1XSBkYXJrOmZvY3VzOiFiZy1bIzU1NV0gZGFyazpbJi5wcy0tY2xpY2tpbmddOiFiZy1bIzU1NV1cIixcbiAgcmFpbFlUaHVtYjogXCJhYnNvbHV0ZSByaWdodC0wLjUgcm91bmRlZC1tZCB3LTEuNSBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF93aWR0aF8uMnNfZWFzZS1pbi1vdXQsX29wYWNpdHldIGdyb3VwLWhvdmVyL3k6dy1bMTFweF0gZ3JvdXAtZm9jdXMveTp3LVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTp3LVsxMXB4XSBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlUaHVtYkNvbG9yczogXCJiZy1bI2FhYV0gZ3JvdXAtaG92ZXIveTpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveTpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS95OmJnLVsjOTk5XVwiXG59LCBmYiA9IHtcbiAgcHM6IFwic3RyaW5nXCIsXG4gIHJhaWxYOiBcInN0cmluZ1wiLFxuICByYWlsWENvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYjogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYkNvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFk6IFwic3RyaW5nXCIsXG4gIHJhaWxZQ29sb3JzOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iQ29sb3JzOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgTG8ge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9wc0NsYXNzZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXhcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFgsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFksXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFlDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX190aHVtYi14XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxYVGh1bWIsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhUaHVtYkNvbG9yc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3RodW1iLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFlUaHVtYixcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWVRodW1iQ29sb3JzXG4gICAgICB9XG4gICAgXSwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsIGdzLCB0aGlzKSwgYy5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBkYikpLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gam47XG4gIH1cbiAgZ2V0IHJhaWxYKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCIucHNfX3JhaWwteFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgcmFpbFkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcIi5wc19fcmFpbC15XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlLmhhbmRsZXJzICE9PSB2b2lkIDAgJiYgKGUuaGFuZGxlcnMgPSBlLmhhbmRsZXJzLnNwbGl0KFwiIFwiKSksIHQgPSB7XG4gICAgICAuLi51YixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChqbiwgdCwgcGIpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uX2IsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoam4sIHQsIGZiKSwgdDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQgJiYgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgZ3MpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fZGF0YUF0dHJPcHRpb25zID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMucGVyZmVjdFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMucmVtb3ZlRXZlbnQoS24pLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBudWxsO1xuICB9XG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG5ldyBCaSh0aGlzLl9lbGVtZW50LCB0aGlzLl9vcHRpb25zKSwgdGhpcy5fYWRkUGVyZmVjdFNjcm9sbGJhclN0eWxlcygpLCB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCksIHRoaXMuX2luaXRFdmVudHMoS24pLCB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdCA9IHtcbiAgICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIiwgXCJjbGFzc05hbWVcIl1cbiAgICAgIH07XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHQpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlU2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSwgZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIndpZHRoXCIpO1xuICAgIHRoaXMucmFpbFggJiYgKHRoaXMucmFpbFguc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoY2FsYygtMTAwJSArICR7dGhpcy5fY2FuVHJhbnNmb3JtKHQpID8gdCA6IFwiMHB4XCJ9KSlgKSwgdGhpcy5yYWlsWSAmJiAodGhpcy5yYWlsWS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWChjYWxjKC0xMDAlICsgJHt0aGlzLl9jYW5UcmFuc2Zvcm0oZSkgPyBlIDogXCIwcHhcIn0pKWApO1xuICB9XG4gIF9jYW5UcmFuc2Zvcm0odCkge1xuICAgIHJldHVybiB0ICYmIHQuaW5jbHVkZXMoXCJweFwiKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKTtcbiAgfVxuICBfaW5pdEV2ZW50cyh0ID0gW10pIHtcbiAgICB0LmZvckVhY2goXG4gICAgICAoeyBwczogZSwgdGU6IGkgfSkgPT4gaC5vbihcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgZSxcbiAgICAgICAgKG4pID0+IGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpLCB7IGU6IG4gfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIF9hZGRQZXJmZWN0U2Nyb2xsYmFyU3R5bGVzKCkge1xuICAgIHRoaXMuX3BzQ2xhc3Nlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAuJHt0LnBzfWAsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgYy5hZGRDbGFzcyhlLCB0LnRlKSwgYy5hZGRDbGFzcyhlLCB0LnRlQ29sb3IpO1xuICAgIH0pLCBjLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucHMpLCBjLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwicHNcIik7XG4gIH1cbiAgcmVtb3ZlRXZlbnQodCkge1xuICAgIGxldCBlID0gW107XG4gICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IEtuLmZpbHRlcigoeyB0ZTogaSB9KSA9PiBpID09PSB0KSksIGUuZm9yRWFjaCgoeyBwczogaSwgdGU6IG4gfSkgPT4ge1xuICAgICAgaC5vZmYodGhpcy5fZWxlbWVudCwgaSksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIG4pO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBJLmdldERhdGEodGhpcywgZ3MpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFlICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChlIHx8IChlID0gbmV3IExvKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgZ3MpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHljID0gTG8sIG1iID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1zZWxlY3QtcmVmXCIsIGdiID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLW5hdi1yZWZcIiwgYmIgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tcmlnaHQtcmVmXCIsIHZiID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLWxlZnQtcmVmXCIsIFRiID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLXN0YXJ0LXJlZlwiLCBFYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1lbmQtcmVmXCIsIENiID0gKHtcbiAgdGV4dDogcyxcbiAgZW50cmllczogdCxcbiAgZW50cmllc09wdGlvbnM6IGUsXG4gIGZ1bGxQYWdpbmF0aW9uOiBpLFxuICByb3dzVGV4dDogbixcbiAgYWxsVGV4dDogbyxcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiByLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogYSxcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBsLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBwLFxuICBjbGFzc2VzOiB1XG59LCBmLCBfKSA9PiB7XG4gIGNvbnN0IG0gPSBlLm1hcCgoZykgPT4gZyA9PT0gXCJBbGxcIiA/IGA8b3B0aW9uIHZhbHVlPVwiJHtnfVwiICR7ZyA9PT0gdCA/IFwic2VsZWN0ZWRcIiA6IFwiXCJ9PiR7b308L29wdGlvbj5gIDogYDxvcHRpb24gdmFsdWU9XCIke2d9XCIgJHtnID09PSB0ID8gXCJzZWxlY3RlZFwiIDogXCJcIn0+JHtnfTwvb3B0aW9uPmApLmpvaW4oYFxuYCk7XG4gIHJldHVybiBgXG48ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb259ICR7XyA/IGAke3UucGFnaW5hdGlvbkJvcmRlcmVkfWAgOiBcIlwifSAke3UuYm9yZGVyQ29sb3J9ICR7dS5jb2xvcn1cIj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5zZWxlY3RJdGVtc1dyYXBwZXJ9XCI+ICBcbiAgICA8cCBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uUm93c1RleHR9ICR7ZiA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dH1gIDogXCJcIn1cIj4ke259PC9wPlxuICAgIDxkaXYgY2xhc3M9XCIke3Uuc2VsZWN0V3JhcHBlcn0gJHtmID8gYCR7dS5sb2FkaW5nUGFnaW5hdGlvblNlbGVjdFdyYXBwZXJ9YCA6IFwiXCJ9XCI+XG4gICAgICA8c2VsZWN0IG5hbWU9XCJlbnRyaWVzXCJcbiAgICAgICAgJHtmID8gXCJkaXNhYmxlZFwiIDogXCJcIn0gY2xhc3M9XCJzZWxlY3RcIiAke21ifT5cbiAgICAgICAgJHttfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb25OYXZ9ICR7ZiA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25OYXZ9YCA6IFwiXCJ9XCIgJHtnYn0+XG4gICR7c31cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCIke3UucGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyfVwiPlxuICAgICR7aSA/IGA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblN0YXJ0QnV0dG9ufVwiICR7VGJ9PlxuICAgICAgICAgICAke3J9XG4gICAgICAgICAgPC9idXR0b24+YCA6IFwiXCJ9XG4gICAgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25MZWZ0QnV0dG9ufVwiICR7dmJ9PlxuICAgICAgJHthfVxuICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblJpZ2h0QnV0dG9ufVwiICR7YmJ9PlxuICAgICAgJHtsfVxuICA8L2J1dHRvbj5cbiAgICAke2kgPyBgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25FbmRCdXR0b259XCIgJHtFYn0+XG4gICAgICAgICAgICR7cH1cbiAgICAgICAgICA8L2J1dHRvbj5gIDogXCJcIn1cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG59LCBBYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtc29ydC1pY29uLXJlZlwiLCB5YiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaGVhZGVyLWNoZWNrYm94LXJlZlwiLCB3YiA9IChzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSA9PiB7XG4gIGNvbnN0IGwgPSBlID8gYFxuICA8dGggc2NvcGU9XCJjb2xcIj5cbiAgICA8ZGl2IGNsYXNzPVwiJHthLmNoZWNrYm94SGVhZGVyV3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cIiR7YS5jaGVja2JveEhlYWRlcn1cIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICR7eWJ9XG4gICAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvdGg+XG4gIGAgOiAnPHRoIHNjb3BlPVwiY29sXCI+PC90aD4nLCBwID0gcy5tYXAoKHUsIGYpID0+IHtcbiAgICBjb25zdCBfID0gdS5maXhlZCA/IHMuZmlsdGVyKChtLCBnKSA9PiBtLmZpeGVkID09PSB1LmZpeGVkICYmIGcgPCBmKS5yZWR1Y2UoKG0sIGcpID0+IG0gKyBnLndpZHRoLCAwKSA6IG51bGw7XG4gICAgcmV0dXJuIGA8dGggY2xhc3M9XCIke2EuY29sdW1ufSAke2kgPyBgJHthLnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7YS5ib3JkZXJDb2xvcn0gJHtuID8gYCR7YS5zbX1gIDogXCJcIn0gJHt1LmZpeGVkID8gYCR7YS5maXhlZEhlYWRlcn0gJHthLmNvbG9yfWAgOiBcIlwifSAke28gPyBgJHthLmxvYWRpbmdDb2x1bW59YCA6IFwiXCJ9XCIgc3R5bGU9XCIke3UuZml4ZWQgPyBgJHt1LmZpeGVkID09PSBcInJpZ2h0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIn06ICR7X31weDtgIDogXCJcIn1cIiBzY29wZT1cImNvbFwiPiR7dS5zb3J0ID8gYDxkaXYgY2xhc3M9XCIke2Euc29ydEljb25XcmFwcGVyfVwiPjxzcGFuIGNsYXNzPVwiJHthLnNvcnRJY29ufSAke28gPyBcImludmlzaWJsZVwiIDogXCJcIn1cIiBkYXRhLXRlLXNvcnQ9XCIke3UuZmllbGR9XCIgJHtBYn0+JHtyfTwvc3Bhbj5gIDogXCJcIn0gPHNwYW4gY2xhc3M9XCIke3Uuc29ydCA/IFwiXCIgOiBcInBsLVsxOHB4XVwifVwiPiR7dS5sYWJlbH08L3NwYW4+PC9kaXY+PC90aD5gO1xuICB9KTtcbiAgcmV0dXJuIFt0ID8gbCA6IFwiXCIsIC4uLnBdLmpvaW4oYFxuYCk7XG59LCB4YiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LXJlZlwiLCBrYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LWNoZWNrYm94LXJlZlwiLCBPYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtY2VsbC1yZWZcIiwgU2IgPSAoe1xuICByb3dzOiBzLFxuICBjb2x1bW5zOiB0LFxuICBub0ZvdW5kTWVzc2FnZTogZSxcbiAgZWRpdDogaSxcbiAgc2VsZWN0YWJsZTogbixcbiAgbG9hZGluZzogbyxcbiAgYm9yZGVyZWQ6IHIsXG4gIGJvcmRlcmxlc3M6IGEsXG4gIHN0cmlwZWQ6IGwsXG4gIGhvdmVyOiBwLFxuICBzbTogdSxcbiAgY2xhc3NlczogZlxufSkgPT4ge1xuICBjb25zdCBfID0gcy5tYXAoKG0pID0+IHtcbiAgICBjb25zdCBnID0gYFxuICAgICAgPHRkIGRhdGEtdGUtZmllbGQ9XCJjaGVja2JveFwiIGNsYXNzPVwiJHtyID8gYCR7Zi50YWJsZUJvcmRlcmVkfSAke2YuYm9yZGVyQ29sb3J9YCA6IFwiXCJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2YuY2hlY2tib3hSb3dXcmFwcGVyfVwiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3M9XCIke2YuY2hlY2tib3hSb3d9XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICAgICBkYXRhLXRlLXJvdy1pbmRleD1cIiR7bS5yb3dJbmRleH1cIiAgJHtrYn0vPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGQ+YCwgdiA9IHQubWFwKChiLCBDKSA9PiB7XG4gICAgICBjb25zdCB5ID0ge307XG4gICAgICBpZiAoYi53aWR0aCAmJiAoeVtcIm1pbi13aWR0aFwiXSA9IGAke2Iud2lkdGggLSAxfXB4YCwgeVtcIm1heC13aWR0aFwiXSA9IGAke2Iud2lkdGh9cHhgLCB5LndpZHRoID0gYCR7Yi53aWR0aH1weGApLCBiLmZpeGVkKSB7XG4gICAgICAgIGNvbnN0IFQgPSB0LmZpbHRlcigoQSwgdykgPT4gQS5maXhlZCA9PT0gYi5maXhlZCAmJiB3IDwgQykucmVkdWNlKChBLCB3KSA9PiBBICsgdy53aWR0aCwgMCk7XG4gICAgICAgIHlbYi5maXhlZCA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCJdID0gYCR7VH1weGA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYDx0ZCBzdHlsZT1cIiR7T2JqZWN0LmtleXMoeSkubWFwKChUKSA9PiBgJHtUfTogJHt5W1RdfWApLmpvaW4oXCI7IFwiKX1cIiBjbGFzcz1cIiR7Zi5yb3dJdGVtfSAke2YuYm9yZGVyQ29sb3J9ICR7aSA/IGAke2YuZWRpdH1gIDogXCJcIn0gJHtyID8gYCR7Zi50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke3UgPyBgJHtmLnNtfWAgOiBcIlwifSAke2IuZml4ZWQgPyBgJHtmLmZpeGVkSGVhZGVyfSAke2YuY29sb3J9YCA6IFwiXCJ9XCIgJHtPYn0gZGF0YS10ZS1maWVsZD1cIiR7Yi5maWVsZH1cIiAke2kgJiYgJ2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIid9PiR7bVtiLmZpZWxkXX08L3RkPmA7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gYDx0ciBzY29wZT1cInJvd1wiIGNsYXNzPVwiJHtmLnJvd30gJHtmLmJvcmRlckNvbG9yfSAke2Yucm93QW5pbWF0aW9ufSAke2wgPyBgJHtmLnN0cmlwZWR9YCA6IFwiXCJ9ICR7YSA/IGAke2YuYm9yZGVybGVzc31gIDogXCJcIn0gJHtwID8gYCR7Zi5ob3ZlclJvd31gIDogXCJcIn1cIiBkYXRhLXRlLWluZGV4PVwiJHttLnJvd0luZGV4fVwiICR7eGJ9PiR7biA/IGcgOiBcIlwifSR7dn08L3RyPmA7XG4gIH0pO1xuICByZXR1cm4gcy5sZW5ndGggPiAwIHx8IG8gPyBfLmpvaW4oYFxuYCkgOiBgPHRyIGNsYXNzPVwiJHtmLm5vRm91bmRNZXNzYWdlV3JhcHBlcn0gJHtmLmJvcmRlckNvbG9yfVwiPjx0ZCBjbGFzcz1cIiR7Zi5ub0ZvdW5kTWVzc2FnZX1cIj4ke2V9PC90ZD48L3RyPmA7XG59LCBJYiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaW5uZXItcmVmXCIsIERiID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1oZWFkZXItcmVmXCIsIFZhID0gKHtcbiAgY29sdW1uczogcyxcbiAgcm93czogdCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gIGVkaXQ6IGksXG4gIG11bHRpOiBuLFxuICBzZWxlY3RhYmxlOiBvLFxuICBsb2FkaW5nOiByLFxuICBsb2FkaW5nTWVzc2FnZTogYSxcbiAgcGFnaW5hdGlvbjogbCxcbiAgYm9yZGVyZWQ6IHAsXG4gIGJvcmRlcmxlc3M6IHUsXG4gIHN0cmlwZWQ6IGYsXG4gIGhvdmVyOiBfLFxuICBmaXhlZEhlYWRlcjogbSxcbiAgc206IGcsXG4gIHNvcnRJY29uVGVtcGxhdGU6IHYsXG4gIGNsYXNzZXM6IGJcbn0pID0+IHtcbiAgY29uc3QgQyA9IFNiKHtcbiAgICByb3dzOiB0LFxuICAgIGNvbHVtbnM6IHMsXG4gICAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gICAgZWRpdDogaSxcbiAgICBsb2FkaW5nOiByLFxuICAgIHNlbGVjdGFibGU6IG8sXG4gICAgYm9yZGVyZWQ6IHAsXG4gICAgYm9yZGVybGVzczogdSxcbiAgICBzdHJpcGVkOiBmLFxuICAgIGhvdmVyOiBfLFxuICAgIHNtOiBnLFxuICAgIGNsYXNzZXM6IGJcbiAgfSksIHkgPSB3YihcbiAgICBzLFxuICAgIG8sXG4gICAgbixcbiAgICBwLFxuICAgIGcsXG4gICAgcixcbiAgICB2LFxuICAgIGJcbiAgKTtcbiAgcmV0dXJuIHsgdGFibGU6IGBcbjxkaXYgY2xhc3M9XCIke2IuY29sb3J9XCIgJHtJYn0+XG4gIDx0YWJsZSBjbGFzcz1cIiR7Yi50YWJsZX1cIj5cbiAgICA8dGhlYWQgY2xhc3M9XCIke2IudGFibGVIZWFkZXJ9ICR7cCA/IGAke2IudGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHt1ID8gYCR7Yi5ib3JkZXJsZXNzfWAgOiBcIlwifSAke2IuYm9yZGVyQ29sb3J9XCIgJHtEYn0+XG4gICAgICA8dHI+XG4gICAgICAgICR7eX1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgICA8dGJvZHkgY2xhc3M9XCIke20gPyBgJHtiLmZpeGVkSGVhZGVyQm9keX1gIDogXCJcIn1cIj5cbiAgICAgICR7ciA/IFwiXCIgOiBDfVxuICAgIDwvdGJvZHk+XG4gIDwvdGFibGU+XG48L2Rpdj5cbiR7ciA/IGBcbiAgPGRpdiBjbGFzcz1cIiR7Yi5sb2FkaW5nSXRlbXNXcmFwcGVyfVwiPlxuICAgIDxkaXYgY2xhc3M9XCIke2IubG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcn1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2IubG9hZGluZ1Byb2dyZXNzQmFyfVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjxwIGNsYXNzPVwiJHtiLmxvYWRpbmdNZXNzYWdlfVwiPiR7YX08L3A+XG5gIDogXCJcIn1cbiR7bC5lbmFibGUgPyBDYihsLCByLCBwKSA6IFwiXCJ9XG4gIGAsIHJvd3M6IEMsIGNvbHVtbjogeSB9O1xufSwgJGIgPSAoeyByb3dzOiBzLCBmaWVsZDogdCwgb3JkZXI6IGUgfSkgPT4gcy5zb3J0KChuLCBvKSA9PiB7XG4gIGxldCByID0gblt0XSwgYSA9IG9bdF07XG4gIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIChyID0gci50b0xvd2VyQ2FzZSgpKSwgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiAoYSA9IGEudG9Mb3dlckNhc2UoKSksIHIgPCBhID8gZSA9PT0gXCJkZXNjXCIgPyAxIDogLTEgOiByID4gYSA/IGUgPT09IFwiZGVzY1wiID8gLTEgOiAxIDogMDtcbn0pLCBMYiA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcmV0dXJuIG8uaW5uZXJIVE1MID0gbiwgbiA9IG8udGV4dENvbnRlbnQgfHwgby5pbm5lclRleHQgfHwgXCJcIiwgbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkubWF0Y2godC50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcbiAgcmV0dXJuIHMuZmlsdGVyKChuKSA9PiB7XG4gICAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBpKG5bZV0pO1xuICAgIGxldCBvID0gT2JqZWN0LnZhbHVlcyhuKTtcbiAgICByZXR1cm4gZSAmJiBBcnJheS5pc0FycmF5KGUpICYmIChvID0gT2JqZWN0LmtleXMobikuZmlsdGVyKChyKSA9PiBlLmluY2x1ZGVzKHIpKS5tYXAoKHIpID0+IG5bcl0pKSwgby5maWx0ZXIoKHIpID0+IGkocikpLmxlbmd0aCA+IDA7XG4gIH0pO1xufSwgRmEgPSAoeyByb3dzOiBzLCBlbnRyaWVzOiB0LCBhY3RpdmVQYWdlOiBlIH0pID0+IHtcbiAgY29uc3QgaSA9IGUgKiB0O1xuICByZXR1cm4gcy5zbGljZShpLCBpICsgTnVtYmVyKHQpKTtcbn0sIHhpID0gXCJkYXRhdGFibGVcIiwgX3QgPSBgZGF0YS10ZS0ke3hpfWAsIGdpID0gYHRlLiR7eGl9YCwgenMgPSBgLiR7Z2l9YCwgTWIgPSBgWyR7X3R9LWlubmVyLXJlZl1gLCB6biA9IGBbJHtfdH0tY2VsbC1yZWZdYCwgTmIgPSBgWyR7X3R9LWhlYWRlci1yZWZdYCwgUmIgPSBgWyR7X3R9LWhlYWRlci1jaGVja2JveC1yZWZdYCwgUGIgPSBgWyR7X3R9LXBhZ2luYXRpb24tcmlnaHQtcmVmXWAsIEJiID0gYFske190fS1wYWdpbmF0aW9uLWxlZnQtcmVmXWAsIEhiID0gYFske190fS1wYWdpbmF0aW9uLXN0YXJ0LXJlZl1gLCBXYiA9IGBbJHtfdH0tcGFnaW5hdGlvbi1lbmQtcmVmXWAsIFZiID0gYFske190fS1wYWdpbmF0aW9uLW5hdi1yZWZdYCwgRmIgPSBgWyR7X3R9LXNlbGVjdC1yZWZdYCwgVW4gPSBgWyR7X3R9LXNvcnQtaWNvbi1yZWZdYCwgZGkgPSBgWyR7X3R9LXJvdy1yZWZdYCwgWG4gPSBgWyR7X3R9LXJvdy1jaGVja2JveC1yZWZdYCwgWWIgPSBgc2VsZWN0Um93cyR7enN9YCwgWWEgPSBgcmVuZGVyJHt6c31gLCBqYiA9IGByb3dDbGljayR7enN9YCwgS2IgPSBgdXBkYXRlJHt6c31gLCB6YiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTAuNUwxMiAzbTAgMGw3LjUgNy41TTEyIDN2MThcIiAvPlxuPC9zdmc+YCwgVWIgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTguNzUgMTkuNWwtNy41LTcuNSA3LjUtNy41bS02IDE1TDUuMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCBYYiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xNS43NSAxOS41TDguMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCBHYiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk04LjI1IDQuNWw3LjUgNy41LTcuNSA3LjVcIiAvPlxuPC9zdmc+YCwgcWIgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTEuMjUgNC41bDcuNSA3LjUtNy41IDcuNW0tNi0xNWw3LjUgNy41LTcuNSA3LjVcIi8+XG48L3N2Zz5gLCBaYiA9IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCIsIFFiID0gXCJib3JkZXItbm9uZVwiLCBKYiA9IFwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbWwtWzEuNXJlbV0gbXItWzZweF0gbXQtWzAuMTVyZW1dIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50IGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMFwiLCB0diA9IFwibWItWzAuMTI1cmVtXSBtaW4taC1bMS41cmVtXSBwbC1bMS41cmVtXSBtbC0zIGZsZXggaXRlbXMtY2VudGVyXCIsIGV2ID0gXCJyZWxhdGl2ZSBmbG9hdC1sZWZ0IC1tbC1bMS41cmVtXSBtci1bNnB4XSBtdC1bMC4xNXJlbV0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBjaGVja2VkOmJnLXByaW1hcnkgY2hlY2tlZDpiZWZvcmU6b3BhY2l0eS1bMC4xNl0gY2hlY2tlZDphZnRlcjphYnNvbHV0ZSBjaGVja2VkOmFmdGVyOi1tdC1weCBjaGVja2VkOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmFmdGVyOmJsb2NrIGNoZWNrZWQ6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDphZnRlcjpiZy10cmFuc3BhcmVudCBjaGVja2VkOmFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBob3ZlcjpiZWZvcmU6b3BhY2l0eS1bMC4wNF0gaG92ZXI6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOnNoYWRvdy1ub25lIGZvY3VzOnRyYW5zaXRpb24tW2JvcmRlci1jb2xvcl8wLjJzXSBmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGZvY3VzOmJlZm9yZTpvcGFjaXR5LVswLjEyXSBmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gZm9jdXM6YWZ0ZXI6YWJzb2x1dGUgZm9jdXM6YWZ0ZXI6ei1bMV0gZm9jdXM6YWZ0ZXI6YmxvY2sgZm9jdXM6YWZ0ZXI6aC1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnctWzAuODc1cmVtXSBmb2N1czphZnRlcjpyb3VuZGVkLVswLjEyNXJlbV0gZm9jdXM6YWZ0ZXI6Y29udGVudC1bJyddIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gY2hlY2tlZDpmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBjaGVja2VkOmZvY3VzOmFmdGVyOi1tdC1weCBjaGVja2VkOmZvY3VzOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDpmb2N1czphZnRlcjpyb3VuZGVkLW5vbmUgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwXCIsIGl2ID0gXCJtYi1bMC4xMjVyZW1dIG1pbi1oLVsxLjVyZW1dIHBsLVsxLjVyZW1dIG1sLTMgZmxleCBpdGVtcy1jZW50ZXJcIiwgc3YgPSBcImJnLXdoaXRlIGRhcms6YmctbmV1dHJhbC04MDBcIiwgbnYgPSBcInB5LTQgcGwtMSB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHRleHQtWyMyMTI1MjldIGRhcms6dGV4dC13aGl0ZVwiLCBvdiA9IFwiZm9jdXM6b3V0bGluZS1ub25lXCIsIHJ2ID0gXCJzdGlja3kgdG9wLTAgei0zMFwiLCBhdiA9IFwic3RpY2t5IHotMTAgYmctaW5oZXJpdFwiLCBsdiA9IFwiaG92ZXI6YmctbmV1dHJhbC0xMDAgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTcwMFwiLCBjdiA9IFwicG9pbnRlci1ldmVudHMtbm9uZSBjdXJzb3Itbm9uZSB0ZXh0LW5ldXRyYWwtNDAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBodiA9IFwiaC1bMnB4XSByZWxhdGl2ZSB3LWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCIsIGR2ID0gXCJ0ZXh0LWNlbnRlciB0ZXh0LW5ldXRyYWwtNTAwIGZvbnQtbGlnaCB0ZXh0LXNtIG15LTQgZGFyazp0ZXh0LW5ldXRyYWwtNDAwXCIsIHV2ID0gXCJ0ZXh0LW5ldXRyYWwtNTAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBwdiA9IFwidGV4dC1uZXV0cmFsLTUwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgX3YgPSBcInBvaW50ZXItZXZlbnRzLW5vbmUgY3Vyc29yLW5vbmVcIiwgZnYgPSBcImgtZnVsbCB3LVs0NSVdIGJnLXByaW1hcnktNDAwIGRhcms6YmctcHJpbWFyeS02MDBcIiwgbXYgPSBcImgtZnVsbCBhbmltYXRlLVtwcm9ncmVzc18zc19lYXNlLWluLW91dF9pbmZpbml0ZV1cIiwgZ3YgPSBcInBsLTIgcHktMyBmb250LWxpZ2h0IHRleHQtc20gZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIGJ2ID0gXCJib3JkZXItYlwiLCB2diA9IFwiZmxleCBtZDpmbGV4LXJvdyBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHktMiBzcGFjZS14LTQgdGV4dC1zbSBmbGV4LWNvbCBsZWFkaW5nLVsxLjZdXCIsIFR2ID0gXCJib3JkZXIgYm9yZGVyLXQtMFwiLCBFdiA9IFwib3JkZXItMSBteS0zIG1kOm9yZGVyLW5vbmUgbWQ6bXktMCBtZDpwci0xXCIsIEN2ID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIEF2ID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCB5diA9IFwiZm9udC1ub3JtYWwgb3JkZXItMiBtYi0zIG1kOm9yZGVyLW5vbmUgbWQ6bWItMFwiLCB3diA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgeHYgPSBcImZvbnQtbGlnaHRcIiwga3YgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIE92ID0gXCJib3JkZXItYlwiLCBTdiA9IFwidHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi0zMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIiwgSXYgPSBcIndoaXRlc3BhY2Utbm93cmFwIHRleHQtY2xpcCBvdmVyZmxvdy1oaWRkZW4gcHgtWzEuNHJlbV0gcHktNFwiLCBEdiA9IFwicmVsYXRpdmVcIiwgJHYgPSBcIiFiZy1uZXV0cmFsLTEwMCBkYXJrOiFiZy1uZXV0cmFsLTYwMFwiLCBMdiA9IFwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC00IG9yZGVyLTMgbWQ6b3JkZXItbm9uZVwiLCBNdiA9IFwidy1bNzBweF1cIiwgTnYgPSBcIiFweS0yXCIsIFJ2ID0gXCJ3LVsxNXB4XSBoLVsxMHB4XSBvcmlnaW4tYm90dG9tIGZvbnQtYmxhY2sgbXItMSBvcGFjaXR5LTAgdGV4dC1uZXV0cmFsLTUwMCBncm91cC1ob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uIGhvdmVyOmVhc2UtaW4tb3V0IHRyYW5zZm9ybSBlYXNlLWxpbmVhciBkdXJhdGlvbi0zMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LW5ldXRyYWwtNDAwXCIsIFB2ID0gXCJmbGV4IGZsZXgtcm93IGdyb3VwXCIsIEJ2ID0gXCJbJjpudGgtY2hpbGQob2RkKV06YmctbmV1dHJhbC01MCBbJjpudGgtY2hpbGQob2RkKV06ZGFyazpiZy1uZXV0cmFsLTcwMFwiLCBIdiA9IFwiYm9yZGVyXCIsIFd2ID0gXCJib3JkZXItYiBmb250LW5vcm1hbCBweC1bMS40cmVtXVwiLCBWdiA9IFwidGV4dC1sZWZ0IHRleHQtc20gZm9udC1saWdodCB3LWZ1bGwgbGVhZGluZy1bMS42XVwiLCBGdiA9IHtcbiAgYm9yZGVyZWQ6IFwiYm9vbGVhblwiLFxuICBib3JkZXJsZXNzOiBcImJvb2xlYW5cIixcbiAgY2xpY2thYmxlUm93czogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRWYWx1ZTogXCJzdHJpbmdcIixcbiAgZWRpdDogXCJib29sZWFuXCIsXG4gIGVudHJpZXM6IFwiKG51bWJlcnxzdHJpbmcpXCIsXG4gIGVudHJpZXNPcHRpb25zOiBcImFycmF5XCIsXG4gIGZ1bGxQYWdpbmF0aW9uOiBcImJvb2xlYW5cIixcbiAgaG92ZXI6IFwiYm9vbGVhblwiLFxuICBsb2FkaW5nOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZ01lc3NhZ2U6IFwic3RyaW5nXCIsXG4gIG1heFdpZHRoOiBcIihudWxsfG51bWJlcnxzdHJpbmcpXCIsXG4gIG1heEhlaWdodDogXCIobnVsbHxudW1iZXJ8c3RyaW5nKVwiLFxuICBtdWx0aTogXCJib29sZWFuXCIsXG4gIG5vRm91bmRNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0YWJsZTogXCJib29sZWFuXCIsXG4gIHNtOiBcImJvb2xlYW5cIixcbiAgc29ydEZpZWxkOiBcIihudWxsfHN0cmluZylcIixcbiAgc29ydE9yZGVyOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlcjogXCJib29sZWFuXCIsXG4gIHN0cmlwZWQ6IFwiYm9vbGVhblwiLFxuICByb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgb2ZUZXh0OiBcInN0cmluZ1wiLFxuICBhbGxUZXh0OiBcInN0cmluZ1wiLFxuICBmb3JjZVNvcnQ6IFwiYm9vbGVhblwiLFxuICBzb3J0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCJcbn0sIFl2ID0ge1xuICBib3JkZXJlZDogITEsXG4gIGJvcmRlcmxlc3M6ICExLFxuICBjbGlja2FibGVSb3dzOiAhMSxcbiAgZGVmYXVsdFZhbHVlOiBcIi1cIixcbiAgZWRpdDogITEsXG4gIGVudHJpZXM6IDEwLFxuICBlbnRyaWVzT3B0aW9uczogWzEwLCAyNSwgNTAsIDIwMF0sXG4gIGZpeGVkSGVhZGVyOiAhMSxcbiAgZnVsbFBhZ2luYXRpb246ICExLFxuICBob3ZlcjogITEsXG4gIGxvYWRpbmc6ICExLFxuICBsb2FkaW5nTWVzc2FnZTogXCJMb2FkaW5nIHJlc3VsdHMuLi5cIixcbiAgbWF4V2lkdGg6IG51bGwsXG4gIG1heEhlaWdodDogbnVsbCxcbiAgbXVsdGk6ICExLFxuICBub0ZvdW5kTWVzc2FnZTogXCJObyBtYXRjaGluZyByZXN1bHRzIGZvdW5kXCIsXG4gIHBhZ2luYXRpb246ICEwLFxuICBzZWxlY3RhYmxlOiAhMSxcbiAgc206ICExLFxuICBzb3J0RmllbGQ6IG51bGwsXG4gIHNvcnRPcmRlcjogXCJhc2NcIixcbiAgc3RyaXBlZDogITEsXG4gIHJvd3NUZXh0OiBcIlJvd3MgcGVyIHBhZ2U6XCIsXG4gIG9mVGV4dDogXCJvZlwiLFxuICBhbGxUZXh0OiBcIkFsbFwiLFxuICBmb3JjZVNvcnQ6ICExLFxuICBzb3J0SWNvblRlbXBsYXRlOiB6YixcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiBVYixcbiAgcGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZTogcWIsXG4gIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiBYYixcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBHYlxufSwganYgPSB7XG4gIGxhYmVsOiBcInN0cmluZ1wiLFxuICBmaWVsZDogXCJzdHJpbmdcIixcbiAgZml4ZWQ6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBmb3JtYXQ6IFwiKGZ1bmN0aW9ufG51bGwpXCIsXG4gIHdpZHRoOiBcIihudW1iZXJ8bnVsbClcIixcbiAgc29ydDogXCJib29sZWFuXCIsXG4gIGNvbHVtbkluZGV4OiBcIm51bWJlclwiXG59LCBLdiA9IHtcbiAgbGFiZWw6IFwiXCIsXG4gIGZpZWxkOiBcIlwiLFxuICBmaXhlZDogITEsXG4gIGZvcm1hdDogbnVsbCxcbiAgd2lkdGg6IG51bGwsXG4gIHNvcnQ6ICEwLFxuICBjb2x1bW5JbmRleDogMFxufSwgenYgPSB7XG4gIHRhYmxlOiBWdixcbiAgdGFibGVIZWFkZXI6IFd2LFxuICBjb2x1bW46IG52LFxuICBwYWdpbmF0aW9uOiB2dixcbiAgc2VsZWN0V3JhcHBlcjogTXYsXG4gIHNjcm9sbDogRHYsXG4gIHRhYmxlQm9yZGVyZWQ6IEh2LFxuICBwYWdpbmF0aW9uQm9yZGVyZWQ6IFR2LFxuICBib3JkZXJsZXNzOiBRYixcbiAgY2hlY2tib3hSb3dXcmFwcGVyOiBpdixcbiAgY2hlY2tib3hSb3c6IGV2LFxuICBjaGVja2JveEhlYWRlcldyYXBwZXI6IHR2LFxuICBjaGVja2JveEhlYWRlcjogSmIsXG4gIHJvdzogT3YsXG4gIHJvd0l0ZW06IEl2LFxuICBzdHJpcGVkOiBCdixcbiAgc29ydEljb25XcmFwcGVyOiBQdixcbiAgc29ydEljb246IFJ2LFxuICBwYWdpbmF0aW9uUm93c1RleHQ6IHh2LFxuICBwYWdpbmF0aW9uTmF2OiB5dixcbiAgcGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyOiBFdixcbiAgaG92ZXJSb3c6IGx2LFxuICBib3JkZXJDb2xvcjogWmIsXG4gIGNvbG9yOiBzdixcbiAgZml4ZWRIZWFkZXI6IHJ2LFxuICBmaXhlZEhlYWRlckJvZHk6IGF2LFxuICBzZWxlY3RhYmxlUm93OiAkdixcbiAgcm93QW5pbWF0aW9uOiBTdixcbiAgc206IE52LFxuICBlZGl0OiBvdixcbiAgc2VsZWN0SXRlbXNXcmFwcGVyOiBMdixcbiAgcGFnaW5hdGlvblN0YXJ0QnV0dG9uOiBrdixcbiAgcGFnaW5hdGlvbkxlZnRCdXR0b246IEF2LFxuICBwYWdpbmF0aW9uUmlnaHRCdXR0b246IHd2LFxuICBwYWdpbmF0aW9uRW5kQnV0dG9uOiBDdixcbiAgbG9hZGluZ0l0ZW1zV3JhcHBlcjogaHYsXG4gIGxvYWRpbmdQcm9ncmVzc0JhcldyYXBwZXI6IG12LFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXI6IGZ2LFxuICBsb2FkaW5nTWVzc2FnZTogZHYsXG4gIGxvYWRpbmdQYWdpbmF0aW9uUm93c1RleHQ6IHB2LFxuICBsb2FkaW5nUGFnaW5hdGlvblNlbGVjdFdyYXBwZXI6IF92LFxuICBsb2FkaW5nUGFnaW5hdGlvbk5hdjogdXYsXG4gIGxvYWRpbmdDb2x1bW46IGN2LFxuICBub0ZvdW5kTWVzc2FnZVdyYXBwZXI6IGJ2LFxuICBub0ZvdW5kTWVzc2FnZTogZ3Zcbn0sIFV2ID0ge1xuICB0YWJsZTogXCJzdHJpbmdcIixcbiAgdGFibGVIZWFkZXI6IFwic3RyaW5nXCIsXG4gIGNvbHVtbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgc2Nyb2xsOiBcInN0cmluZ1wiLFxuICB0YWJsZUJvcmRlcmVkOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uQm9yZGVyZWQ6IFwic3RyaW5nXCIsXG4gIGJvcmRlcmxlc3M6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94Um93V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hSb3c6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SGVhZGVyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hIZWFkZXI6IFwic3RyaW5nXCIsXG4gIHJvdzogXCJzdHJpbmdcIixcbiAgcm93SXRlbTogXCJzdHJpbmdcIixcbiAgc3RyaXBlZDogXCJzdHJpbmdcIixcbiAgc29ydEljb25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBzb3J0SWNvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJvd3NUZXh0OiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTmF2OiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uQnV0dG9uc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGhvdmVyUm93OiBcInN0cmluZ1wiLFxuICBib3JkZXJDb2xvcjogXCJzdHJpbmdcIixcbiAgY29sb3I6IFwic3RyaW5nXCIsXG4gIGZpeGVkSGVhZGVyOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlckJvZHk6IFwic3RyaW5nXCIsXG4gIHNlbGVjdGFibGVSb3c6IFwic3RyaW5nXCIsXG4gIHJvd0FuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgc206IFwic3RyaW5nXCIsXG4gIGVkaXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEl0ZW1zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblN0YXJ0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTGVmdEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJpZ2h0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uRW5kQnV0dG9uOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nSXRlbXNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXI6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0OiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvblNlbGVjdFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdQYWdpbmF0aW9uTmF2OiBcInN0cmluZ1wiLFxuICBsb2FkaW5nQ29sdW1uOiBcInN0cmluZ1wiLFxuICBub0ZvdW5kTWVzc2FnZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIG5vRm91bmRNZXNzYWdlOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgd2Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zKGkpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhuKSwgdGhpcy5fc29ydFJldmVyc2UgPSAhMSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3NlYXJjaCA9IFwiXCIsIHRoaXMuX3NlYXJjaENvbHVtbiA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25MZWZ0ID0gbnVsbCwgdGhpcy5fcGFnaW5hdGlvblJpZ2h0ID0gbnVsbCwgdGhpcy5fcGFnaW5hdGlvblN0YXJ0ID0gbnVsbCwgdGhpcy5fcGFnaW5hdGlvbkVuZCA9IG51bGwsIHRoaXMuX3NlbGVjdCA9IG51bGwsIHRoaXMuX3NlbGVjdEluc3RhbmNlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWQgPSBbXSwgdGhpcy5fY2hlY2tib3hlcyA9IG51bGwsIHRoaXMuX2hlYWRlckNoZWNrYm94ID0gbnVsbCwgdGhpcy5fcm93cyA9IHRoaXMuX2dldFJvd3MoZS5yb3dzKSwgdGhpcy5fY29sdW1ucyA9IHRoaXMuX2dldENvbHVtbnMoZS5jb2x1bW5zKSwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsIGdpLCB0aGlzKSwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX3NldHVwKCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB4aTtcbiAgfVxuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1ucy5tYXAoKHQsIGUpID0+IHtcbiAgICAgIGxldCBpID0ge1xuICAgICAgICAuLi5LdixcbiAgICAgICAgZmllbGQ6IGBmaWVsZF8ke2V9YCxcbiAgICAgICAgY29sdW1uSW5kZXg6IGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IGkubGFiZWwgPSB0IDogdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiAoaSA9IHtcbiAgICAgICAgLi4uaSxcbiAgICAgICAgLi4udFxuICAgICAgfSksIEwoXCJjb2x1bW5cIiwgaSwganYpLCBpO1xuICAgIH0pO1xuICB9XG4gIGdldCByb3dzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3dzLm1hcCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHtcbiAgICAgICAgcm93SW5kZXg6IGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IHRoaXMuY29sdW1ucy5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICAgIHRbb10gPT09IDAgPyBpW24uZmllbGRdID0gdFtvXSA6IGlbbi5maWVsZF0gPSB0W29dIHx8IHRoaXMuX29wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgfSkgOiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHRoaXMuY29sdW1ucy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIHRbbi5maWVsZF0gPT09IDAgPyBpW24uZmllbGRdID0gdFtuLmZpZWxkXSA6IGlbbi5maWVsZF0gPSB0W24uZmllbGRdIHx8IHRoaXMuX29wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgfSksIGk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNlYXJjaFJlc3VsdCgpIHtcbiAgICByZXR1cm4gTGIodGhpcy5yb3dzLCB0aGlzLl9zZWFyY2gsIHRoaXMuX3NlYXJjaENvbHVtbik7XG4gIH1cbiAgZ2V0IGNvbXB1dGVkUm93cygpIHtcbiAgICBsZXQgdCA9IFsuLi50aGlzLnNlYXJjaFJlc3VsdF07XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyICYmICh0ID0gJGIoe1xuICAgICAgcm93czogdCxcbiAgICAgIGZpZWxkOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCxcbiAgICAgIG9yZGVyOiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlclxuICAgIH0pKSwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmICh0aGlzLl9vcHRpb25zLmVudHJpZXMgPT09IFwiQWxsXCIgPyB0ID0gRmEoe1xuICAgICAgcm93czogdCxcbiAgICAgIGVudHJpZXM6IHQubGVuZ3RoLFxuICAgICAgYWN0aXZlUGFnZTogdGhpcy5fYWN0aXZlUGFnZVxuICAgIH0pIDogdCA9IEZhKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBlbnRyaWVzOiB0aGlzLl9vcHRpb25zLmVudHJpZXMsXG4gICAgICBhY3RpdmVQYWdlOiB0aGlzLl9hY3RpdmVQYWdlXG4gICAgfSkpLCB0O1xuICB9XG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gMSA6IE1hdGguY2VpbCh0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGggLyB0aGlzLl9vcHRpb25zLmVudHJpZXMpO1xuICB9XG4gIGdldCBuYXZpZ2F0aW9uVGV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlUGFnZSAqIHRoaXMuX29wdGlvbnMuZW50cmllcztcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RoID09PSAwID8gYDAgJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gMGAgOiB0aGlzLl9vcHRpb25zLmVudHJpZXMgPT09IFwiQWxsXCIgPyBgMSAtICR7dGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RofSAke3RoaXMuX29wdGlvbnMub2ZUZXh0fSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH1gIDogYCR7dCArIDF9IC0gJHt0aGlzLmNvbXB1dGVkUm93cy5sZW5ndGggKyB0fSAke3RoaXMuX29wdGlvbnMub2ZUZXh0fSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH1gO1xuICB9XG4gIGdldCB0YWJsZU9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXMsXG4gICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMsXG4gICAgICByb3dzOiB0aGlzLmNvbXB1dGVkUm93cyxcbiAgICAgIG5vRm91bmRNZXNzYWdlOiB0aGlzLl9vcHRpb25zLm5vRm91bmRNZXNzYWdlLFxuICAgICAgZWRpdDogdGhpcy5fb3B0aW9ucy5lZGl0LFxuICAgICAgbG9hZGluZzogdGhpcy5fb3B0aW9ucy5sb2FkaW5nLFxuICAgICAgbG9hZGVyQ2xhc3M6IHRoaXMuX29wdGlvbnMubG9hZGVyQ2xhc3MsXG4gICAgICBsb2FkaW5nTWVzc2FnZTogdGhpcy5fb3B0aW9ucy5sb2FkaW5nTWVzc2FnZSxcbiAgICAgIHNlbGVjdGFibGU6IHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSxcbiAgICAgIG11bHRpOiB0aGlzLl9vcHRpb25zLm11bHRpLFxuICAgICAgYm9yZGVyZWQ6IHRoaXMuX29wdGlvbnMuYm9yZGVyZWQsXG4gICAgICBib3JkZXJsZXNzOiB0aGlzLl9vcHRpb25zLmJvcmRlcmxlc3MsXG4gICAgICBzdHJpcGVkOiB0aGlzLl9vcHRpb25zLnN0cmlwZWQsXG4gICAgICBob3ZlcjogdGhpcy5fb3B0aW9ucy5ob3ZlcixcbiAgICAgIGZpeGVkSGVhZGVyOiB0aGlzLl9vcHRpb25zLmZpeGVkSGVhZGVyLFxuICAgICAgc206IHRoaXMuX29wdGlvbnMuc20sXG4gICAgICBzb3J0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnNvcnRJY29uVGVtcGxhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIGVuYWJsZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uLFxuICAgICAgICB0ZXh0OiB0aGlzLm5hdmlnYXRpb25UZXh0LFxuICAgICAgICBlbnRyaWVzOiB0aGlzLl9vcHRpb25zLmVudHJpZXMsXG4gICAgICAgIGVudHJpZXNPcHRpb25zOiB0aGlzLl9vcHRpb25zLmVudHJpZXNPcHRpb25zLFxuICAgICAgICBmdWxsUGFnaW5hdGlvbjogdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbixcbiAgICAgICAgcm93c1RleHQ6IHRoaXMuX29wdGlvbnMucm93c1RleHQsXG4gICAgICAgIG9mVGV4dDogdGhpcy5fb3B0aW9ucy5vZlRleHQsXG4gICAgICAgIGFsbFRleHQ6IHRoaXMuX29wdGlvbnMuYWxsVGV4dCxcbiAgICAgICAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZSxcbiAgICAgICAgcGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZSxcbiAgICAgICAgY2xhc3NlczogdGhpcy5fY2xhc3Nlc1xuICAgICAgfSxcbiAgICAgIGZvcmNlU29ydDogdGhpcy5fb3B0aW9ucy5mb3JjZVNvcnRcbiAgICB9O1xuICB9XG4gIC8vIFB1YmxpY1xuICB1cGRhdGUodCwgZSA9IHt9KSB7XG4gICAgdCAmJiB0LnJvd3MgJiYgKHRoaXMuX3Jvd3MgPSB0LnJvd3MpLCB0ICYmIHQuY29sdW1ucyAmJiAodGhpcy5fY29sdW1ucyA9IHQuY29sdW1ucyksIHRoaXMuX2NsZWFyQ2xhc3NMaXN0KGUpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh7IC4uLnRoaXMuX29wdGlvbnMsIC4uLmUgfSksIHRoaXMuX3NldHVwKCksIHRoaXMuX3BlcmZvcm1Tb3J0KCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9zZWxlY3RJbnN0YW5jZSAmJiB0aGlzLl9zZWxlY3RJbnN0YW5jZS5kaXNwb3NlKCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBnaSksIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIuZGVzdHJveSgpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBzZWFyY2godCwgZSkge1xuICAgIHRoaXMuX3NlYXJjaCA9IHQsIHRoaXMuX3NlYXJjaENvbHVtbiA9IGUsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3JlbmRlclJvd3MoKSwgdGhpcy5fb3B0aW9ucy5tYXhIZWlnaHQgJiYgKHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIuZWxlbWVudC5zY3JvbGxUb3AgPSAwLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLnVwZGF0ZSgpKTtcbiAgfVxuICBzb3J0KHQsIGUgPSBcImFzY1wiKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPSBlLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgPSB0aGlzLmNvbHVtbnMuZmluZChcbiAgICAgIChuKSA9PiBuLmxhYmVsID09PSB0XG4gICAgKS5maWVsZCA6IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gdC5maWVsZDtcbiAgICBjb25zdCBpID0gZC5maW5kT25lKFxuICAgICAgYFtkYXRhLXRlLXNvcnQ9XCIke3RoaXMuX29wdGlvbnMuc29ydEZpZWxkfVwiXWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3JlbmRlclJvd3MoKSwgdGhpcy5fc2V0QWN0aXZlU29ydEljb24oaSk7XG4gIH1cbiAgc2V0QWN0aXZlUGFnZSh0KSB7XG4gICAgdCA8IHRoaXMucGFnZXMgJiYgdGhpcy5fY2hhbmdlQWN0aXZlUGFnZSh0KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uenYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoeGksIHQsIFV2KSwgdDtcbiAgfVxuICBfY2hhbmdlQWN0aXZlUGFnZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlUGFnZSA9IHQsIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX2NsZWFyQ2xhc3NMaXN0KHQpIHtcbiAgICBbXCJob3ZlclwiLCBcImJvcmRlcmVkXCIsIFwiYm9yZGVybGVzc1wiLCBcInNtXCIsIFwic3RyaXBlZFwiXS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB0aGlzLl9vcHRpb25zW2VdICYmICF0W2VdICYmIGMucmVtb3ZlRGF0YUF0dHJpYnV0ZShgZGF0YS10ZS0ke2V9YCk7XG4gICAgfSk7XG4gIH1cbiAgX2VtaXRTZWxlY3RFdmVudCgpIHtcbiAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWWIsIHtcbiAgICAgIHNlbGVjdGVkUm93czogdGhpcy5yb3dzLmZpbHRlcihcbiAgICAgICAgKHQpID0+IHRoaXMuX3NlbGVjdGVkLmluZGV4T2YodC5yb3dJbmRleCkgIT09IC0xXG4gICAgICApLFxuICAgICAgc2VsZWN0ZWRJbmRleGVzOiB0aGlzLl9zZWxlY3RlZCxcbiAgICAgIGFsbFNlbGVjdGVkOiB0aGlzLl9zZWxlY3RlZC5sZW5ndGggPT09IHRoaXMucm93cy5sZW5ndGhcbiAgICB9KTtcbiAgfVxuICBfZ2V0Um93cyh0ID0gW10pIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFwidGJvZHlcIiwgdGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUgPyBbLi4uZC5maW5kKFwidHJcIiwgZSkubWFwKChuKSA9PiBkLmZpbmQoXCJ0ZFwiLCBuKS5tYXAoKG8pID0+IG8uaW5uZXJIVE1MKSksIC4uLnRdIDogdDtcbiAgfVxuICBfZ2V0Q29sdW1ucyh0ID0gW10pIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFwidGhlYWRcIiwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcInRyXCIsIGUpO1xuICAgIHJldHVybiBbLi4uZC5maW5kKFwidGhcIiwgaSkubWFwKChvKSA9PiAoe1xuICAgICAgbGFiZWw6IG8uaW5uZXJIVE1MLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyhvKVxuICAgIH0pKSwgLi4udF07XG4gIH1cbiAgX2dldENTU1ZhbHVlKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiBgJHt0fXB4YDtcbiAgfVxuICBfZ2V0T3B0aW9ucyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLll2LFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBMKHhpLCBlLCBGdiksIGU7XG4gIH1cbiAgX3NldEFjdGl2ZVJvd3MoKSB7XG4gICAgZC5maW5kKGRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzLl9zZWxlY3RlZC5pbmNsdWRlcyhjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKSkgPyBjLmFkZENsYXNzKHQsIGBhY3RpdmUgJHt0aGlzLl9jbGFzc2VzLnNlbGVjdGFibGVSb3d9YCkgOiBjLnJlbW92ZUNsYXNzKHQsIGBhY3RpdmUgJHt0aGlzLl9jbGFzc2VzLnNlbGVjdGFibGVSb3d9YCk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEVudHJpZXModCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zKHtcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICBlbnRyaWVzOiB0LnRhcmdldC52YWx1ZVxuICAgIH0pLCB0aGlzLl9hY3RpdmVQYWdlID4gdGhpcy5wYWdlcyAtIDEgJiYgKHRoaXMuX2FjdGl2ZVBhZ2UgPSB0aGlzLnBhZ2VzIC0gMSksIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX3NldFNlbGVjdGVkKCkge1xuICAgIGQuZmluZChYbiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJyb3dJbmRleFwiKTtcbiAgICAgICAgdC5jaGVja2VkID0gdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoZSk7XG4gICAgICB9XG4gICAgKSwgdGhpcy5fc2V0QWN0aXZlUm93cygpO1xuICB9XG4gIF9zZXRBY3RpdmVTb3J0SWNvbih0KSB7XG4gICAgZC5maW5kKFVuLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPT09IFwiZGVzY1wiICYmIGUgPT09IHQgPyAxODAgOiAwO1xuICAgICAgYy5zdHlsZShlLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgke2l9ZGVnKWBcbiAgICAgIH0pLCBlID09PSB0ICYmIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID8gYy5hZGRDbGFzcyhlLCBcIm9wYWNpdHktMTAwXCIpIDogYy5yZW1vdmVDbGFzcyhlLCBcIm9wYWNpdHktMTAwXCIpO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLl9yZW5kZXJUYWJsZSgpLCB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fc2V0dXBQYWdpbmF0aW9uKCksIHRoaXMuX29wdGlvbnMuZWRpdCAmJiB0aGlzLl9zZXR1cEVkaXRhYmxlKCksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiB0aGlzLl9zZXR1cENsaWNrYWJsZVJvd3MoKSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmIHRoaXMuX3NldHVwU2VsZWN0YWJsZSgpLCB0aGlzLl9zZXR1cFNjcm9sbCgpLCB0aGlzLl9zZXR1cFNvcnQoKTtcbiAgfVxuICBfc2V0dXBDbGlja2FibGVSb3dzKCkge1xuICAgIGQuZmluZChkaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcImluZGV4XCIpO1xuICAgICAgYy5hZGRDbGFzcyh0LCBcImN1cnNvci1wb2ludGVyXCIpLCBoLm9uKHQsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgZC5tYXRjaGVzKGkudGFyZ2V0LCBYbikgfHwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGpiLCB7XG4gICAgICAgICAgaW5kZXg6IGUsXG4gICAgICAgICAgcm93OiB0aGlzLnJvd3NbZV1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBFZGl0YWJsZSgpIHtcbiAgICBkLmZpbmQoZGksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKTtcbiAgICAgIGQuZmluZCh6biwgdCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBoLm9uKGksIFwiaW5wdXRcIiwgKG4pID0+IHRoaXMuX3VwZGF0ZVJvdyhuLCBlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBTY3JvbGwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShNYiwgdGhpcy5fZWxlbWVudCksIGUgPSB7fTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5tYXhIZWlnaHQgJiYgKGUubWF4SGVpZ2h0ID0gdGhpcy5fZ2V0Q1NTVmFsdWUodGhpcy5fb3B0aW9ucy5tYXhIZWlnaHQpKSwgdGhpcy5fb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldENTU1ZhbHVlKHRoaXMuX29wdGlvbnMubWF4V2lkdGgpO1xuICAgICAgZS5tYXhXaWR0aCA9IGksIGMuc3R5bGUodGhpcy5fZWxlbWVudCwgeyBtYXhXaWR0aDogaSB9KTtcbiAgICB9XG4gICAgaWYgKGMuc3R5bGUodCwgZSksIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5zY3JvbGx9YCksIHRoaXMuX29wdGlvbnMuZml4ZWRIZWFkZXIpIHtcbiAgICAgIGxldCBpID0gZC5maW5kKE5iLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAoaSA9IGkuZmlsdGVyKChuLCBvKSA9PiAoYy5hZGRDbGFzcyhcbiAgICAgICAgbixcbiAgICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5maXhlZEhlYWRlcn0gJHt0aGlzLl9jbGFzc2VzLmNvbG9yfWBcbiAgICAgICksIG8gIT09IDApKSksIGkuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgICBjLmFkZENsYXNzKFxuICAgICAgICAgIG4sXG4gICAgICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5maXhlZEhlYWRlcn0gJHt0aGlzLl9jbGFzc2VzLmNvbG9yfWBcbiAgICAgICAgKSwgdGhpcy5jb2x1bW5zW29dLmZpeGVkICYmIGMuYWRkQ2xhc3MobiwgXCIhei00MFwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbmV3IHljKHQpO1xuICB9XG4gIF9zZXR1cFNvcnQoKSB7XG4gICAgZC5maW5kKFVuLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwic29ydFwiKSwgW2ldID0gZC5wYXJlbnRzKHQsIFwidGhcIik7XG4gICAgICBpZiAodGhpcy5jb2x1bW5zLnNvcnQpXG4gICAgICAgIGMuYWRkQ2xhc3MoaSwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZSA9PT0gdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgJiYgdGhpcy5fc2V0QWN0aXZlU29ydEljb24odCksIGgub24oaSwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID09PSBlICYmIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImFzY1wiID8gdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPSBcImRlc2NcIiA6IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID09PSBlICYmIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImRlc2NcIiA/IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gdGhpcy5fb3B0aW9ucy5mb3JjZVNvcnQgPyBcImFzY1wiIDogbnVsbCA6IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gXCJhc2NcIiwgdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgPSBlLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fcGVyZm9ybVNvcnQoKSwgdGhpcy5fc2V0QWN0aXZlU29ydEljb24odCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfcGVyZm9ybVNvcnQoKSB7XG4gICAgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3JlbmRlclJvd3MoKTtcbiAgfVxuICBfc2V0dXBTZWxlY3RhYmxlKCkge1xuICAgIHRoaXMuX2NoZWNrYm94ZXMgPSBkLmZpbmQoWG4sIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9oZWFkZXJDaGVja2JveCA9IGQuZmluZE9uZShcbiAgICAgIFJiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9oZWFkZXJDaGVja2JveCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgICh0KSA9PiB0aGlzLl90b2dnbGVTZWxlY3RBbGwodClcbiAgICApLCB0aGlzLl9jaGVja2JveGVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJyb3dJbmRleFwiKTtcbiAgICAgIGgub24oXG4gICAgICAgIHQsXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgKGkpID0+IHRoaXMuX3RvZ2dsZVNlbGVjdFJvdyhpLCBlKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBQYWdpbmF0aW9uKCkge1xuICAgIHRoaXMuX3BhZ2luYXRpb25SaWdodCA9IGQuZmluZE9uZShcbiAgICAgIFBiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3BhZ2luYXRpb25MZWZ0ID0gZC5maW5kT25lKFxuICAgICAgQmIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25SaWdodCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5fYWN0aXZlUGFnZSArIDEpXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25MZWZ0LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgKCkgPT4gdGhpcy5fY2hhbmdlQWN0aXZlUGFnZSh0aGlzLl9hY3RpdmVQYWdlIC0gMSlcbiAgICApLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmICh0aGlzLl9wYWdpbmF0aW9uU3RhcnQgPSBkLmZpbmRPbmUoXG4gICAgICBIYixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9wYWdpbmF0aW9uRW5kID0gZC5maW5kT25lKFxuICAgICAgV2IsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25TdGFydCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UoMClcbiAgICApLCBoLm9uKFxuICAgICAgdGhpcy5fcGFnaW5hdGlvbkVuZCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5wYWdlcyAtIDEpXG4gICAgKSksIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9zZXR1cFBhZ2luYXRpb25TZWxlY3QoKTtcbiAgfVxuICBfc2V0dXBQYWdpbmF0aW9uU2VsZWN0KCkge1xuICAgIHRoaXMuX3NlbGVjdCA9IGQuZmluZE9uZShGYiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX3NlbGVjdEluc3RhbmNlID0gbmV3ICRvKHRoaXMuX3NlbGVjdCksIGgub24oXG4gICAgICB0aGlzLl9zZWxlY3QsXG4gICAgICBcInZhbHVlQ2hhbmdlLnRlLnNlbGVjdFwiLFxuICAgICAgKHQpID0+IHRoaXMuX3NldEVudHJpZXModClcbiAgICApO1xuICB9XG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24gJiYgKGgub2ZmKHRoaXMuX3BhZ2luYXRpb25SaWdodCwgXCJjbGlja1wiKSwgaC5vZmYodGhpcy5fcGFnaW5hdGlvbkxlZnQsIFwiY2xpY2tcIiksIGgub2ZmKHRoaXMuX3NlbGVjdCwgXCJ2YWx1ZUNoYW5nZS50ZS5zZWxlY3RcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgKGgub2ZmKHRoaXMuX3BhZ2luYXRpb25TdGFydCwgXCJjbGlja1wiKSwgaC5vZmYodGhpcy5fcGFnaW5hdGlvbkVuZCwgXCJjbGlja1wiKSkpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgZC5maW5kKHpuLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLm9mZih0LCBcImlucHV0XCIpO1xuICAgIH0pLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgZC5maW5kKGRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLm9mZih0LCBcImNsaWNrXCIpO1xuICAgIH0pLCBkLmZpbmQoVW4sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IFtlXSA9IGQucGFyZW50cyh0LCBcInRoXCIpO1xuICAgICAgaC5vZmYoZSwgXCJjbGlja1wiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmIChoLm9mZih0aGlzLl9oZWFkZXJDaGVja2JveCwgXCJpbnB1dFwiKSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLm9mZih0LCBcImlucHV0XCIpO1xuICAgIH0pKTtcbiAgfVxuICBfcmVuZGVyVGFibGUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSBWYSh0aGlzLnRhYmxlT3B0aW9ucykudGFibGUsIHRoaXMuX2Zvcm1hdENlbGxzKCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZYSk7XG4gIH1cbiAgX3JlbmRlclJvd3MoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcInRib2R5XCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24pIHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIFZiLFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgZS5pbm5lclRleHQgPSB0aGlzLm5hdmlnYXRpb25UZXh0O1xuICAgIH1cbiAgICB0LmlubmVySFRNTCA9IFZhKHRoaXMudGFibGVPcHRpb25zKS5yb3dzLCB0aGlzLl9mb3JtYXRDZWxscygpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgdGhpcy5fc2V0dXBFZGl0YWJsZSgpLCB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKHRoaXMuX3NldHVwU2VsZWN0YWJsZSgpLCB0aGlzLl9zZXRTZWxlY3RlZCgpKSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIHRoaXMuX3NldHVwQ2xpY2thYmxlUm93cygpLCBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWWEpO1xuICB9XG4gIF9mb3JtYXRDZWxscygpIHtcbiAgICBkLmZpbmQoZGksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBjLmdldERhdGFBdHRyaWJ1dGUoZSwgXCJpbmRleFwiKTtcbiAgICAgIGQuZmluZCh6biwgZSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBjb25zdCByID0gYy5nZXREYXRhQXR0cmlidXRlKG8sIFwiZmllbGRcIiksIGEgPSB0aGlzLmNvbHVtbnMuZmluZCgobCkgPT4gbC5maWVsZCA9PT0gcik7XG4gICAgICAgIGEgJiYgYS5mb3JtYXQgIT09IG51bGwgJiYgYS5mb3JtYXQobywgdGhpcy5yb3dzW2ldW3JdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVEaXNhYmxlU3RhdGUoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICE9PSAhMSAmJiAodGhpcy5fYWN0aXZlUGFnZSA9PT0gMCB8fCB0aGlzLl9vcHRpb25zLmxvYWRpbmcgPyAodGhpcy5fcGFnaW5hdGlvbkxlZnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpKSA6ICh0aGlzLl9wYWdpbmF0aW9uTGVmdC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uU3RhcnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpLCB0aGlzLl9hY3RpdmVQYWdlID09PSB0aGlzLnBhZ2VzIC0gMSB8fCB0aGlzLl9vcHRpb25zLmxvYWRpbmcgfHwgdGhpcy5wYWdlcyA9PT0gMCA/ICh0aGlzLl9wYWdpbmF0aW9uUmlnaHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvbkVuZC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkgOiAodGhpcy5fcGFnaW5hdGlvblJpZ2h0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25FbmQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpKTtcbiAgfVxuICBfdG9nZ2xlU2VsZWN0QWxsKHQpIHtcbiAgICB0LnRhcmdldC5jaGVja2VkID8gdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLnJvd3MubWFwKChlKSA9PiBlLnJvd0luZGV4KSA6IHRoaXMuX3NlbGVjdGVkID0gW10sIHRoaXMuX3NldFNlbGVjdGVkKCksIHRoaXMuX2VtaXRTZWxlY3RFdmVudCgpO1xuICB9XG4gIF90b2dnbGVTZWxlY3RSb3codCwgZSkge1xuICAgIHQudGFyZ2V0LmNoZWNrZWQgPyB0aGlzLl9vcHRpb25zLm11bHRpICYmICF0aGlzLl9zZWxlY3RlZC5pbmNsdWRlcyhlKSA/IHRoaXMuX3NlbGVjdGVkID0gWy4uLnRoaXMuX3NlbGVjdGVkLCBlXSA6ICh0aGlzLl9zZWxlY3RlZCA9IFtlXSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpICE9PSB0LnRhcmdldCAmJiAoaS5jaGVja2VkID0gITEpO1xuICAgIH0pKSA6IHRoaXMuX3NlbGVjdGVkID0gdGhpcy5fc2VsZWN0ZWQuZmlsdGVyKChpKSA9PiBpICE9PSBlKSwgdGhpcy5fb3B0aW9ucy5tdWx0aSAmJiAhdC50YXJnZXQuY2hlY2tlZCAmJiAodGhpcy5faGVhZGVyQ2hlY2tib3guY2hlY2tlZCA9ICExKSwgdGhpcy5fc2V0QWN0aXZlUm93cygpLCB0aGlzLl9lbWl0U2VsZWN0RXZlbnQoKTtcbiAgfVxuICBfdXBkYXRlUm93KHQsIGUpIHtcbiAgICBjb25zdCBpID0gYy5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcImZpZWxkXCIpLCBuID0gdC50YXJnZXQudGV4dENvbnRlbnQsIG8gPSB0aGlzLl9yb3dzW2VdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5jb2x1bW5zLmZpbmQoKGwpID0+IGwuZmllbGQgPT09IGkpLmNvbHVtbkluZGV4O1xuICAgICAgb1thXSA9IG47XG4gICAgfSBlbHNlXG4gICAgICBvW2ldID0gbjtcbiAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgS2IsIHtcbiAgICAgIHJvd3M6IHRoaXMuX3Jvd3MsXG4gICAgICBjb2x1bW5zOiB0aGlzLl9jb2x1bW5zXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBuID0gSS5nZXREYXRhKHRoaXMsIGdpKTtcbiAgICAgIGNvbnN0IG8gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghbiAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKG4gfHwgKG4gPSBuZXcgd2ModGhpcywgbywgZSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIG5bdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgblt0XShlLCBpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgZ2kpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGphID0gXCJyYXRpbmdcIiwgJHMgPSBcInRlLnJhdGluZ1wiLCBYdiA9IFwiZGF0YS10ZS1yYXRpbmctaW5pdFwiLCBHdiA9IFwiW2RhdGEtdGUtcmF0aW5nLWljb24tcmVmXVwiLCB0aSA9IGAuJHskc31gLCBxdiA9IFwiQXJyb3dMZWZ0XCIsIFp2ID0gXCJBcnJvd1JpZ2h0XCIsIFF2ID0ge1xuICB0b29sdGlwOiBcInN0cmluZ1wiLFxuICB2YWx1ZTogXCIoc3RyaW5nfG51bWJlcilcIixcbiAgcmVhZG9ubHk6IFwiYm9vbGVhblwiLFxuICBhZnRlcjogXCJzdHJpbmdcIixcbiAgYmVmb3JlOiBcInN0cmluZ1wiLFxuICBkeW5hbWljOiBcImJvb2xlYW5cIixcbiAgYWN0aXZlOiBcInN0cmluZ1wiXG59LCBKdiA9IHtcbiAgdG9vbHRpcDogXCJ0b3BcIixcbiAgdmFsdWU6IFwiXCIsXG4gIHJlYWRvbmx5OiAhMSxcbiAgYWZ0ZXI6IFwiXCIsXG4gIGJlZm9yZTogXCJcIixcbiAgZHluYW1pYzogITEsXG4gIGFjdGl2ZTogXCJmaWxsLWN1cnJlbnRcIlxufSwgS2EgPSBgb25TZWxlY3Qke3RpfWAsIHQwID0gYG9uSG92ZXIke3RpfWAsIHphID0gYGtleXVwJHt0aX1gLCBVYSA9IGBmb2N1c291dCR7dGl9YCwgWGEgPSBga2V5ZG93biR7dGl9YCwgR2EgPSBgbW91c2Vkb3duJHt0aX1gO1xuY2xhc3MgejAge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2ljb25zID0gZC5maW5kKEd2LCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faW5kZXggPSAtMSwgdGhpcy5fc2F2ZWRJbmRleCA9IG51bGwsIHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0ID0gW10sIHRoaXMuX29yaWdpbmFsSWNvbnMgPSBbXSwgdGhpcy5fZm4gPSB7fSwgdGhpcy5fdG9vbHRpcHMgPSBbXSwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsICRzLCB0aGlzKSwgdGhpcy5faW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gamE7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgJHMpLCB0aGlzLl9vcHRpb25zLnJlYWRvbmx5IHx8IChoLm9mZih0aGlzLl9lbGVtZW50LCB6YSksIGgub2ZmKHRoaXMuX2VsZW1lbnQsIFVhKSwgaC5vZmYodGhpcy5fZWxlbWVudCwgWGEpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX2ZuLm1vdXNlbGVhdmUpLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBoLm9mZih0LCBHYSksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy5fZm4ubW91c2VlbnRlcltlXSksIGMucmVtb3ZlQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICB9KSwgdGhpcy5fdG9vbHRpcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoWHYpLCB0LmRpc3Bvc2UoKTtcbiAgICB9KSwgdGhpcy5faWNvbnMucmVtb3ZlQXR0cmlidXRlKFwidGFiSW5kZXhcIikpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX29wdGlvbnMucmVhZG9ubHkgfHwgKHRoaXMuX2JpbmRNb3VzZUVudGVyKCksIHRoaXMuX2JpbmRNb3VzZUxlYXZlKCksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleURvd24oKSwgdGhpcy5fYmluZEtleVVwKCksIHRoaXMuX2JpbmRGb2N1c0xvc3QoKSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyh0LCBcImN1cnNvci1wb2ludGVyXCIpO1xuICAgIH0pKSwgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmICh0aGlzLl9zYXZlT3JpZ2luYWxDbGFzc0xpc3QoKSwgdGhpcy5fc2F2ZU9yaWdpbmFsSWNvbnMoKSksIHRoaXMuX3NldEN1c3RvbVRleHQoKSwgdGhpcy5fc2V0VG9vbFRpcHMoKSwgdGhpcy5fb3B0aW9ucy52YWx1ZSAmJiAodGhpcy5faW5kZXggPSB0aGlzLl9vcHRpb25zLnZhbHVlIC0gMSwgdGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX2luZGV4KSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5KdixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTChqYSwgdCwgUXYpLCB0O1xuICB9XG4gIF9iaW5kTW91c2VFbnRlcigpIHtcbiAgICB0aGlzLl9mbi5tb3VzZWVudGVyID0gW10sIHRoaXMuX2ljb25zLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZWVudGVyXCIsXG4gICAgICAgIC8vIHRoaXMuX2ZuLm1vdXNlZW50ZXJbaV0gaXMgbmVlZGVkIHRvIGNyZWF0ZSByZWZlcmVuY2UgYW5kIHVucGluIGV2ZW50cyBhZnRlciBjYWxsIGRpc3Bvc2VcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHRoaXMuX2ZuLm1vdXNlZW50ZXJbZV0gPSAoaSkgPT4ge1xuICAgICAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5faWNvbnMuaW5kZXhPZihpLnRhcmdldCksIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9pbmRleCksIHRoaXMuX3RyaWdnZXJFdmVudHModCwgdDApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kTW91c2VMZWF2ZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcIm1vdXNlbGVhdmVcIixcbiAgICAgIC8vIHRoaXMuX2ZuLm1vdXNlbGVhdmUgaXMgbmVlZGVkIHRvIGNyZWF0ZSByZWZlcmVuY2UgYW5kIHVucGluIGV2ZW50cyBhZnRlciBjYWxsIGRpc3Bvc2VcbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgdGhpcy5fZm4ubW91c2VsZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2F2ZWRJbmRleCAhPT0gbnVsbCA/ICh0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fc2F2ZWRJbmRleCksIHRoaXMuX2luZGV4ID0gdGhpcy5fc2F2ZWRJbmRleCkgOiB0aGlzLl9vcHRpb25zLnZhbHVlID8gKHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9vcHRpb25zLnZhbHVlIC0gMSksIHRoaXMuX2luZGV4ID0gdGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEpIDogKHRoaXMuX2luZGV4ID0gLTEsIHRoaXMuX2NsZWFyUmF0aW5nKCkpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2JpbmRNb3VzZURvd24oKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5vbih0LCBHYSwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50T3V0bGluZShcIm5vbmVcIiksIHRoaXMuX3NhdmVkSW5kZXggPSB0aGlzLl9pbmRleCwgdGhpcy5fdHJpZ2dlckV2ZW50cyh0LCBLYSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEtleURvd24oKSB7XG4gICAgdGhpcy5fZWxlbWVudC50YWJJbmRleCA9IDAsIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgWGEsXG4gICAgICAodCkgPT4gdGhpcy5fdXBkYXRlQWZ0ZXJLZXlEb3duKHQpXG4gICAgKTtcbiAgfVxuICBfYmluZEtleVVwKCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgemEsXG4gICAgICAoKSA9PiB0aGlzLl9zZXRFbGVtZW50T3V0bGluZShcImF1dG9cIilcbiAgICApO1xuICB9XG4gIF9iaW5kRm9jdXNMb3N0KCkge1xuICAgIGgub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgVWEsXG4gICAgICAoKSA9PiB0aGlzLl9zZXRFbGVtZW50T3V0bGluZShcIm5vbmVcIilcbiAgICApO1xuICB9XG4gIF9zZXRFbGVtZW50T3V0bGluZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gdDtcbiAgfVxuICBfdHJpZ2dlckV2ZW50cyh0LCBlKSB7XG4gICAgaC50cmlnZ2VyKHQsIGUsIHtcbiAgICAgIHZhbHVlOiB0aGlzLl9pbmRleCArIDFcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQWZ0ZXJLZXlEb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5faWNvbnMubGVuZ3RoIC0gMSwgaSA9IHRoaXMuX2luZGV4O1xuICAgIHQua2V5ID09PSBadiAmJiB0aGlzLl9pbmRleCA8IGUgJiYgKHRoaXMuX2luZGV4ICs9IDEpLCB0LmtleSA9PT0gcXYgJiYgdGhpcy5faW5kZXggPiAtMSAmJiAodGhpcy5faW5kZXggLT0gMSksIGkgIT09IHRoaXMuX2luZGV4ICYmICh0aGlzLl9zYXZlZEluZGV4ID0gdGhpcy5faW5kZXgsIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9zYXZlZEluZGV4KSwgdGhpcy5fdHJpZ2dlckV2ZW50cyh0aGlzLl9pY29uc1t0aGlzLl9zYXZlZEluZGV4XSwgS2EpKTtcbiAgfVxuICBfdXBkYXRlUmF0aW5nKHQpIHtcbiAgICB0aGlzLl9jbGVhclJhdGluZygpLCB0aGlzLl9vcHRpb25zLmR5bmFtaWMgJiYgdGhpcy5fcmVzdG9yZU9yaWdpbmFsSWNvbih0KSwgdGhpcy5faWNvbnMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgaSA8PSB0ICYmIGMuYWRkQ2xhc3MoZS5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLCB0aGlzLl9vcHRpb25zLmFjdGl2ZSk7XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyUmF0aW5nKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gICAgICB0aGlzLl9vcHRpb25zLmR5bmFtaWMgJiYgKHQuY2xhc3NMaXN0ID0gdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3RbZV0sIGkuaW5uZXJIVE1MID0gdGhpcy5fb3JpZ2luYWxJY29uc1tlXSksIGMucmVtb3ZlQ2xhc3MoaSwgdGhpcy5fb3B0aW9ucy5hY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRUb29sVGlwcygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gYy5nZXREYXRhQXR0cmlidXRlKHQsIFwidG9nZ2xlXCIpO1xuICAgICAgdC50aXRsZSAmJiAhaSAmJiAoYy5zZXREYXRhQXR0cmlidXRlKHQsIFwidG9nZ2xlXCIsIFwidG9vbHRpcFwiKSwgdGhpcy5fdG9vbHRpcHNbZV0gPSBuZXcgUWUodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX29wdGlvbnMudG9vbHRpcFxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRDdXN0b21UZXh0KCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBjLmdldERhdGFBdHRyaWJ1dGUodCwgXCJhZnRlclwiKSwgaSA9IGMuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcImJlZm9yZVwiKTtcbiAgICAgIGUgJiYgdC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlckVuZFwiLCBlKSwgaSAmJiB0Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZUJlZ2luXCIsIGkpO1xuICAgIH0pO1xuICB9XG4gIF9zYXZlT3JpZ2luYWxDbGFzc0xpc3QoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQuY2xhc3NMaXN0LnZhbHVlO1xuICAgICAgdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3QucHVzaChlKTtcbiAgICB9KTtcbiAgfVxuICBfc2F2ZU9yaWdpbmFsSWNvbnMoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5pbm5lckhUTUw7XG4gICAgICB0aGlzLl9vcmlnaW5hbEljb25zLnB1c2goZSk7XG4gICAgfSk7XG4gIH1cbiAgX3Jlc3RvcmVPcmlnaW5hbEljb24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdFt0XSwgaSA9IHRoaXMuX29yaWdpbmFsSWNvbnNbdF07XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgaWYgKG8gPD0gdCkge1xuICAgICAgICBjb25zdCByID0gbi5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgICByLmlubmVySFRNTCA9IGksIG4uY2xhc3NMaXN0ID0gZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsICRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBHbiA9IFwicG9wY29uZmlybVwiLCBiaSA9IFwidGUucG9wY29uZmlybVwiLCB4YyA9IGAuJHtiaX1gLCBlMCA9IGBjYW5jZWwke3hjfWAsIGkwID0gYGNvbmZpcm0ke3hjfWAsIHMwID0gXCJbZGF0YS10ZS1wb3Bjb25maXJtLWJvZHldXCIsIHFuID0gXCJkYXRhLXRlLXBvcGNvbmZpcm0tcG9wb3ZlclwiLCBuMCA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLW1vZGFsXCIsIHFhID0gXCJkYXRhLXRlLXBvcGNvbmZpcm0tYmFja2Ryb3BcIiwgbzAgPSB7XG4gIHBvcGNvbmZpcm1Nb2RlOiBcInN0cmluZ1wiLFxuICBtZXNzYWdlOiBcInN0cmluZ1wiLFxuICBjYW5jZWxUZXh0OiBcIihudWxsfHN0cmluZylcIixcbiAgb2tUZXh0OiBcIihudWxsfHN0cmluZylcIixcbiAgcG9wY29uZmlybUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgY2FuY2VsTGFiZWw6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBjb25maXJtTGFiZWw6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBwb3NpdGlvbjogXCIobnVsbHxzdHJpbmcpXCJcbn0sIHIwID0ge1xuICBwb3Bjb25maXJtTW9kZTogXCJpbmxpbmVcIixcbiAgbWVzc2FnZTogXCJBcmUgeW91IHN1cmU/XCIsXG4gIGNhbmNlbFRleHQ6IFwiQ2FuY2VsXCIsXG4gIG9rVGV4dDogXCJPS1wiLFxuICBwb3Bjb25maXJtSWNvblRlbXBsYXRlOiBcIlwiLFxuICBjYW5jZWxMYWJlbDogXCJDYW5jZWxcIixcbiAgY29uZmlybUxhYmVsOiBcIkNvbmZpcm1cIixcbiAgcG9zaXRpb246IFwiYm90dG9tXCJcbn0sIGEwID0ge1xuICBiYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgYm9keTogXCJzdHJpbmdcIixcbiAgYnRuQ2FuY2VsOiBcInN0cmluZ1wiLFxuICBidG5Db25maXJtOiBcInN0cmluZ1wiLFxuICBidG5zQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBmYWRlOiBcInN0cmluZ1wiLFxuICBpY29uOiBcInN0cmluZ1wiLFxuICBtZXNzYWdlOiBcInN0cmluZ1wiLFxuICBtZXNzYWdlVGV4dDogXCJzdHJpbmdcIixcbiAgbW9kYWw6IFwic3RyaW5nXCIsXG4gIHBvcG92ZXI6IFwic3RyaW5nXCJcbn0sIGwwID0ge1xuICBiYWNrZHJvcDogXCJoLWZ1bGwgdy1mdWxsIHotWzEwNzBdIGZpeGVkIHRvcC0wIGxlZnQtMCBiZy1bIzAwMDAwMDY2XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICBib2R5OiBcInAtWzFyZW1dIGJnLXdoaXRlIHJvdW5kZWQtWzAuNXJlbV0gb3BhY2l0eS0wIGRhcms6YmctbmV1dHJhbC03MDBcIixcbiAgYnRuQ2FuY2VsOiBcImlubGluZS1ibG9jayByb3VuZGVkIGJnLXByaW1hcnktMTAwIHB4LTQgcGItWzVweF0gcHQtWzZweF0gdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdGV4dC1wcmltYXJ5LTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1wcmltYXJ5LWFjY2VudC0xMDAgZm9jdXM6YmctcHJpbWFyeS1hY2NlbnQtMTAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOmJnLXByaW1hcnktYWNjZW50LTIwMFwiLFxuICBidG5Db25maXJtOiBcImlubGluZS1ibG9jayByb3VuZGVkIGJnLXByaW1hcnkgcHgtNCBwYi1bNXB4XSBwdC1bNnB4XSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0ZXh0LXdoaXRlIHNoYWRvdy1bMF80cHhfOXB4Xy00cHhfIzNiNzFjYV0gdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctcHJpbWFyeS02MDAgaG92ZXI6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4zKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMildIGZvY3VzOmJnLXByaW1hcnktNjAwIGZvY3VzOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTpiZy1wcmltYXJ5LTcwMCBhY3RpdmU6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4zKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMildIGRhcms6c2hhZG93LVswXzRweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC41KV0gZGFyazpob3ZlcjpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjIpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4xKV0gZGFyazpmb2N1czpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjIpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4xKV0gZGFyazphY3RpdmU6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldXCIsXG4gIGJ0bnNDb250YWluZXI6IFwiZmxleCBqdXN0aWZ5LWVuZCBzcGFjZS14LTJcIixcbiAgZmFkZTogXCJ0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzE1MG1zXSBlYXNlLWxpbmVhclwiLFxuICBpY29uOiBcInByLTJcIixcbiAgbWVzc2FnZTogXCJmbGV4IG1iLTNcIixcbiAgbWVzc2FnZVRleHQ6IFwidGV4dC1uZXV0cmFsLTYwMCBkYXJrOnRleHQtd2hpdGVcIixcbiAgbW9kYWw6IFwiYWJzb2x1dGUgdy1bMzAwcHhdIHotWzEwODBdIHNoYWRvdy1zbSByb3VuZGVkLVswLjVyZW1dXCIsXG4gIHBvcG92ZXI6IFwidy1bMzAwcHhdIGJvcmRlci0wIHJvdW5kZWQtWzAuNXJlbV0gei1bMTA4MF0gc2hhZG93LXNtXCJcbn07XG5jbGFzcyBrYyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NhbmNlbEJ1dHRvbiA9IFwiXCIsIHRoaXMuX2NvbmZpcm1CdXR0b24gPSBcIlwiLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdWlkID0gdGhpcy5fZWxlbWVudC5pZCA/IGBwb3Bjb25maXJtLSR7dGhpcy5fZWxlbWVudC5pZH1gIDogYnQoXCJwb3Bjb25maXJtLVwiKSwgdCAmJiBJLnNldERhdGEodCwgYmksIHRoaXMpLCB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLm9wZW4uYmluZCh0aGlzKSwgaC5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEduO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShgIyR7dGhpcy5fdWlkfWApO1xuICB9XG4gIGdldCBwb3Bjb25maXJtQm9keSgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgczAsXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgKHRoaXMuX2lzT3BlbiB8fCB0aGlzLmNvbnRhaW5lciAhPT0gbnVsbCkgJiYgdGhpcy5jbG9zZSgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgYmkpLCBoLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlciksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgdGhpcy5faXNPcGVuIHx8ICh0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1Nb2RlID09PSBcImlubGluZVwiID8gdGhpcy5fb3BlblBvcG92ZXIodGhpcy5fZ2V0UG9wb3ZlclRlbXBsYXRlKCkpIDogdGhpcy5fb3Blbk1vZGFsKHRoaXMuX2dldE1vZGFsVGVtcGxhdGUoKSksIHRoaXMuX2hhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKCksIHRoaXMuX2hhbmRsZUNvbmZpcm1CdXR0b25DbGljaygpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUtleSgpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5faXNPcGVuKSB7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsIHx8IGQuZmluZE9uZShgWyR7cW59XWApICE9PSBudWxsKVxuICAgICAgICBoLm9uKFxuICAgICAgICAgIHRoaXMucG9wY29uZmlybUJvZHksXG4gICAgICAgICAgXCJ0cmFuc2l0aW9uZW5kXCIsXG4gICAgICAgICAgdGhpcy5faGFuZGxlUG9wY29uZmlybVRyYW5zaXRpb25FbmQuYmluZCh0aGlzKVxuICAgICAgICApLCBjLnJlbW92ZUNsYXNzKHRoaXMucG9wY29uZmlybUJvZHksIFwib3BhY2l0eS0xMDBcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7cWF9XWBcbiAgICAgICAgKTtcbiAgICAgICAgYy5yZW1vdmVDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9pc09wZW4gPSAhMTtcbiAgICAgIH1cbiAgICAgIGgub2ZmKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX2hhbmRsZU91dHNpZGVDbGljay5iaW5kKHRoaXMpKSwgaC5vZmYoZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVQb3Bjb25maXJtVHJhbnNpdGlvbkVuZCh0KSB7XG4gICAgaWYgKHQudGFyZ2V0ICE9PSB0aGlzLnBvcGNvbmZpcm1Cb2R5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7cW59XWBcbiAgICApO1xuICAgIGgub2ZmKHRoaXMucG9wY29uZmlybUJvZHksIFwidHJhbnNpdGlvbmVuZFwiKSwgdGhpcy5faXNPcGVuICYmIHQgJiYgdC5wcm9wZXJ0eU5hbWUgPT09IFwib3BhY2l0eVwiICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBlICYmIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZSksIHRoaXMuX2lzT3BlbiA9ICExKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRQb3BvdmVyVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9IEQoXCJkaXZcIiksIGUgPSB0aGlzLl9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKTtcbiAgICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUocW4sIFwiXCIpLCBjLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMucG9wb3ZlciksIHQuaWQgPSB0aGlzLl91aWQsIHQuaW5uZXJIVE1MID0gZSwgdDtcbiAgfVxuICBfZ2V0TW9kYWxUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gRChcImRpdlwiKSwgZSA9IHRoaXMuX2dldFBvcGNvbmZpcm1UZW1wbGF0ZSgpO1xuICAgIHJldHVybiB0LnNldEF0dHJpYnV0ZShuMCwgXCJcIiksIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5tb2RhbH1gKSwgdC5pZCA9IHRoaXMuX3VpZCwgdC5pbm5lckhUTUwgPSBlLCB0O1xuICB9XG4gIF9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGA8ZGl2IGRhdGEtdGUtcG9wY29uZmlybS1ib2R5IGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJvZHl9XCI+XG4gICAgICA8cCBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5tZXNzYWdlfVwiPlxuICAgICAgJHt0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1JY29uVGVtcGxhdGUgPyBgPHNwYW4gY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuaWNvbn1cIj4ke3RoaXMuX29wdGlvbnMucG9wY29uZmlybUljb25UZW1wbGF0ZX08L3NwYW4+YCA6IFwiXCJ9XG4gICAgICA8c3BhbiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5tZXNzYWdlVGV4dH1cIj4ke3RoaXMuX29wdGlvbnMubWVzc2FnZX08L3NwYW4+XG4gICAgICA8L3A+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bnNDb250YWluZXJ9XCI+XG4gICAgICAke3RoaXMuX29wdGlvbnMuY2FuY2VsVGV4dCA/IGA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwibGlnaHRcIiBpZD1cInBvcGNvbmZpcm0tYnV0dG9uLWNhbmNlbFwiIGFyaWEtbGFiZWw9XCIke3RoaXMuX29wdGlvbnMuY2FuY2VsTGFiZWx9XCJcbiAgICAgICAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuQ2FuY2VsfVwiPiR7dGhpcy5fb3B0aW9ucy5jYW5jZWxUZXh0fTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImxpZ2h0XCIgaWQ9XCJwb3Bjb25maXJtLWJ1dHRvbi1jb25maXJtXCJcbiAgICAgIGFyaWEtbGFiZWw9XCIke3RoaXMuX29wdGlvbnMuY29uZmlybUxhYmVsfVwiXG4gICAgICBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5Db25maXJtfVwiPiR7dGhpcy5fb3B0aW9ucy5va1RleHQgPyB0aGlzLl9vcHRpb25zLm9rVGV4dCA6IFwiT2tcIn08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmA7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5yMCxcbiAgICAgIC4uLmMuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgTChHbiwgdCwgbzApLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubDAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoR24sIHQsIGEwKSwgdDtcbiAgfVxuICBfb3BlblBvcG92ZXIodCkge1xuICAgIHRoaXMuX3BvcHBlciA9IEVlKHRoaXMuX2VsZW1lbnQsIHQsIHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5fdHJhbnNsYXRlUG9zaXRpb25WYWx1ZSgpLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDVdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy5hZGRDbGFzcyhcbiAgICAgICAgdGhpcy5wb3Bjb25maXJtQm9keSxcbiAgICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5mYWRlfSBvcGFjaXR5LTEwMGBcbiAgICAgICksIHRoaXMuX2lzT3BlbiA9ICEwO1xuICAgIH0sIDApO1xuICB9XG4gIF9vcGVuTW9kYWwodCkge1xuICAgIGNvbnN0IGUgPSBEKFwiZGl2XCIpO1xuICAgIGUuc2V0QXR0cmlidXRlKHFhLCBcIlwiKSwgYy5hZGRDbGFzcyhlLCB0aGlzLl9jbGFzc2VzLmJhY2tkcm9wKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSwgZS5hcHBlbmRDaGlsZCh0KSwgYy5hZGRDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpLCB0aGlzLl9pc09wZW4gPSAhMDtcbiAgfVxuICBfaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMuX2NhbmNlbEJ1dHRvbiA9IGQuZmluZE9uZShcbiAgICAgIFwiI3BvcGNvbmZpcm0tYnV0dG9uLWNhbmNlbFwiLFxuICAgICAgdFxuICAgICksIFVlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcy5fY2FuY2VsQnV0dG9uLCB7IHJpcHBsZUNvbG9yOiBcImxpZ2h0XCIgfSksIHRoaXMuX2NhbmNlbEJ1dHRvbiAhPT0gbnVsbCAmJiBoLm9uKHRoaXMuX2NhbmNlbEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCksIGgudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBlMCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNvbmZpcm1CdXR0b25DbGljaygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5fY29uZmlybUJ1dHRvbiA9IGQuZmluZE9uZShcbiAgICAgIFwiI3BvcGNvbmZpcm0tYnV0dG9uLWNvbmZpcm1cIixcbiAgICAgIHRcbiAgICApLCBVZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2NvbmZpcm1CdXR0b24sIHsgcmlwcGxlQ29sb3I6IFwibGlnaHRcIiB9KSwgaC5vbih0aGlzLl9jb25maXJtQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKSwgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGkwKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Fc2NhcGVLZXkoKSB7XG4gICAgaC5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsIHRoaXMuX2hhbmRsZUVzY2FwZUtleS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlRXNjYXBlS2V5KHQpIHtcbiAgICB0LmtleUNvZGUgPT09IExpICYmIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgaC5vbihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZU91dHNpZGVDbGljayh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29udGFpbmVyLCBpID0gdC50YXJnZXQgPT09IGUsIG4gPSBlICYmIGUuY29udGFpbnModC50YXJnZXQpLCBvID0gdC50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQsIHIgPSB0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuY29udGFpbnModC50YXJnZXQpO1xuICAgICFpICYmICFuICYmICFvICYmICFyICYmIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBfdHJhbnNsYXRlUG9zaXRpb25WYWx1ZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3AgbGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3AtZW5kXCI7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHJldHVybiBcInRvcFwiO1xuICAgICAgY2FzZSBcInRvcCByaWdodFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3Atc3RhcnRcIjtcbiAgICAgIGNhc2UgXCJib3R0b20gbGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b20tZW5kXCI7XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgICAgY2FzZSBcImJvdHRvbSByaWdodFwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b20tc3RhcnRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0IHRvcFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LWVuZFwiO1xuICAgICAgY2FzZSBcImxlZnQgYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtc3RhcnRcIjtcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICByZXR1cm4gXCJyaWdodFwiO1xuICAgICAgY2FzZSBcInJpZ2h0IHRvcFwiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1lbmRcIjtcbiAgICAgIGNhc2UgXCJyaWdodCBib3R0b21cIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtc3RhcnRcIjtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgIH1cbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSBJLmdldERhdGEodGhpcywgYmkpLCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpKSB7XG4gICAgICAgIGlmICghaSlcbiAgICAgICAgICByZXR1cm4gbmV3IGtjKHRoaXMsIG4pO1xuICAgICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgICAgaVt0XShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBiaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgWm4gPSBcImxpZ2h0Ym94XCIsIHZpID0gXCJ0ZS5saWdodGJveFwiLCBjMCA9IGAuJHt2aX1gLCBoMCA9IFwiLmRhdGEtYXBpXCIsIFNlID0gYGNsaWNrJHtjMH0ke2gwfWAsIE9jID0gXCJbZGF0YS10ZS1saWdodGJveC1pbml0XVwiLCBkMCA9IGAke09jfSBpbWc6bm90KFtkYXRhLXRlLWxpZ2h0Ym94LWRpc2FibGVkXSlgLCBaYSA9IFwiZGF0YS10ZS1saWdodGJveC1jYXB0aW9uXCIsIHUwID0gXCJkYXRhLXRlLWxpZ2h0Ym94LWRpc2FibGVkXCIsIFN0ID0gXCJkYXRhLXRlLWxpZ2h0Ym94LWFjdGl2ZVwiLCBwMCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDEyaC0xNW0wIDBsNi43NSA2Ljc1TTQuNSAxMmw2Ljc1LTYuNzVcIiAvPlxuPC9zdmc+XG5gLCBfMCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTJoMTVtMCAwbC02Ljc1LTYuNzVNMTkuNSAxMmwtNi43NSA2Ljc1XCIgLz5cbjwvc3ZnPlxuYCwgZjAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTMuNzUgMy43NXY0LjVtMC00LjVoNC41bS00LjUgMEw5IDlNMy43NSAyMC4yNXYtNC41bTAgNC41aDQuNW0tNC41IDBMOSAxNU0yMC4yNSAzLjc1aC00LjVtNC41IDB2NC41bTAtNC41TDE1IDltNS4yNSAxMS4yNWgtNC41bTQuNSAwdi00LjVtMCA0LjVMMTUgMTVcIiAvPlxuPC9zdmc+XG5gLCBtMCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNOSA5VjQuNU05IDlINC41TTkgOUwzLjc1IDMuNzVNOSAxNXY0LjVNOSAxNUg0LjVNOSAxNWwtNS4yNSA1LjI1TTE1IDloNC41TTE1IDlWNC41TTE1IDlsNS4yNS01LjI1TTE1IDE1aDQuNU0xNSAxNXY0LjVtMC00LjVsNS4yNSA1LjI1XCIgLz5cbjwvc3ZnPlxuYCwgZzAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIxIDIxbC01LjE5Ny01LjE5N20wIDBBNy41IDcuNSAwIDEwNS4xOTYgNS4xOTZhNy41IDcuNSAwIDAwMTAuNjA3IDEwLjYwN3pNMTAuNSA3LjV2Nm0zLTNoLTZcIiAvPlxuPC9zdmc+XG5gLCBiMCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG48cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIxIDIxbC01LjE5Ny01LjE5N20wIDBBNy41IDcuNSAwIDEwNS4xOTYgNS4xOTZhNy41IDcuNSAwIDAwMTAuNjA3IDEwLjYwN3pNMTMuNSAxMC41aC02XCIgLz5cbjwvc3ZnPlxuYCwgdjAgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTYgMThMMTggNk02IDZsMTIgMTJcIiAvPlxuPC9zdmc+XG5gLCBUMCA9IHtcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB6b29tTGV2ZWw6IFwiKG51bWJlcnxzdHJpbmcpXCIsXG4gIHByZXZJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIG5leHRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBoaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgem9vbUluSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBjbG9zZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgem9vbU91dEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgc3Bpbm5lckNvbnRlbnQ6IFwic3RyaW5nXCJcbn0sIEUwID0ge1xuICBjb250YWluZXI6IFwiYm9keVwiLFxuICB6b29tTGV2ZWw6IDEsXG4gIHByZXZJY29uVGVtcGxhdGU6IHAwLFxuICBuZXh0SWNvblRlbXBsYXRlOiBfMCxcbiAgc2hvd0Z1bGxzY3JlZW5JY29uVGVtcGxhdGU6IGYwLFxuICBoaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZTogbTAsXG4gIHpvb21Jbkljb25UZW1wbGF0ZTogZzAsXG4gIHpvb21PdXRJY29uVGVtcGxhdGU6IGIwLFxuICBjbG9zZUljb25UZW1wbGF0ZTogdjAsXG4gIHNwaW5uZXJDb250ZW50OiBcIkxvYWRpbmcuLi5cIlxufSwgQzAgPSB7XG4gIGNhcHRpb246IFwidGV4dC13aGl0ZSB0ZXh0LWVsbGlwc2lzIG92ZXJmbG93LWhpZGRlbiB3aGl0ZXNwYWNlLW5vd3JhcCBteC1bMTBweF0gdGV4dC1jZW50ZXJcIixcbiAgY2FwdGlvbldyYXBwZXI6IFwiZml4ZWQgbGVmdC0wIGJvdHRvbS0wIHctZnVsbCBoLVs1MHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICBjbG9zZUJ0bjogXCJib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB3LVs1MHB4XSBoLVs1MHB4XSBweC00IHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIGZ1bGxzY3JlZW5CdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBnYWxsZXJ5OiBcImludmlzaWJsZSBmaXhlZCBsZWZ0LTAgdG9wLTAgdy1mdWxsIGgtZnVsbCB6LVsxMTAwXSBwb2ludGVyLWV2ZW50cy1ub25lIG9wYWNpdHktMCBiZy1bIzAwMDAwMGU2XSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIGdhbGxlcnlDb250ZW50OiBcImZpeGVkIHRvcC1bNTBweF0gbGVmdC1bNTBweF0gdy1bY2FsYygxMDAlLTEwMHB4KV0gaC1bY2FsYygxMDAlLTEwMHB4KV1cIixcbiAgZ2FsbGVyeUNvdW50ZXI6IFwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgcHgtWzEwcHhdIG1iLTAgaC1mdWxsIHRleHQtWyNiM2IzYjNdXCIsXG4gIGltZzogXCJhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC1oLWZ1bGwgaC1hdXRvIGN1cnNvci1wb2ludGVyIHBvaW50ZXItZXZlbnRzLWF1dG9cIixcbiAgaW1nV3JhcHBlcjogXCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtZnVsbCBvcGFjaXR5LTAgdHJhbnNmb3JtIHNjYWxlLVswLjI1XSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi1bNDAwbXNdIGVhc2Utb3V0IHBvaW50ZXItZXZlbnRzLW5vbmUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZVwiLFxuICBsZWZ0VG9vbHM6IFwiZmxvYXQtbGVmdCBoLWZ1bGxcIixcbiAgbG9hZGVyOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB6LVsyXSB3LWZ1bGwgaC1mdWxsIHRleHQtbmV1dHJhbC01MCBvcGFjaXR5LTEgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgcG9pbnRlci1ldmVudHMtbm9uZSB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzEwMDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgbmV4dEJ0bjogXCJib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgbmV4dEJ0bldyYXBwZXI6IFwiZml4ZWQgcmlnaHQtMCB0b3AtMCB3LVs1MHB4XSBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgcHJldkJ0bjogXCJib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgcHJldkJ0bldyYXBwZXI6IFwiZml4ZWQgbGVmdC0wIHRvcC0wIHctWzUwcHhdIGgtZnVsbCBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICByaWdodFRvb2xzOiBcImZsb2F0LXJpZ2h0XCIsXG4gIHNwaW5uZXI6IFwiaW5saW5lLWJsb2NrIGgtOCB3LTggYW5pbWF0ZS1bc3Bpbm5lci1ncm93XzAuNzVzX2xpbmVhcl9pbmZpbml0ZV0gcm91bmRlZC1mdWxsIGJnLWN1cnJlbnQgYWxpZ24tWy0wLjEyNWVtXSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtW3NwaW5uZXItZ3Jvd18xLjVzX2xpbmVhcl9pbmZpbml0ZV1cIixcbiAgc3Bpbm5lckNvbnRlbnQ6IFwiIWFic29sdXRlICEtbS1weCAhaC1weCAhdy1weCAhb3ZlcmZsb3ctaGlkZGVuICF3aGl0ZXNwYWNlLW5vd3JhcCAhYm9yZGVyLTAgIXAtMCAhW2NsaXA6cmVjdCgwLDAsMCwwKV1cIixcbiAgdG9vbGJhcjogXCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtWzUwcHhdIHotMjAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgdmVydGljYWw6IFwiaC1mdWxsIG1heC1oLWZ1bGwgdy1hdXRvXCIsXG4gIHpvb21CdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiXG59LCBBMCA9IHtcbiAgY2FwdGlvbjogXCJzdHJpbmdcIixcbiAgY2FwdGlvbldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNsb3NlQnRuOiBcInN0cmluZ1wiLFxuICBmdWxsc2NyZWVuQnRuOiBcInN0cmluZ1wiLFxuICBnYWxsZXJ5OiBcInN0cmluZ1wiLFxuICBnYWxsZXJ5Q29udGVudDogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeUNvdW50ZXI6IFwic3RyaW5nXCIsXG4gIGltZzogXCJzdHJpbmdcIixcbiAgaW1nV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbGVmdFRvb2xzOiBcInN0cmluZ1wiLFxuICBsb2FkZXI6IFwic3RyaW5nXCIsXG4gIG5leHRCdG46IFwic3RyaW5nXCIsXG4gIG5leHRCdG5XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBwcmV2QnRuOiBcInN0cmluZ1wiLFxuICBwcmV2QnRuV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcmlnaHRUb29sczogXCJzdHJpbmdcIixcbiAgc3Bpbm5lcjogXCJzdHJpbmdcIixcbiAgc3Bpbm5lckNvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRvb2xiYXI6IFwic3RyaW5nXCIsXG4gIHZlcnRpY2FsOiBcInN0cmluZ1wiLFxuICB6b29tQnRuOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgTHMge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9nZXRDb250YWluZXIoKSwgdGhpcy5faWQgPSBgbGlnaHRib3gtJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCwgdGhpcy5fYWN0aXZlSW1nID0gMCwgdGhpcy5faW1hZ2VzID0gW10sIHRoaXMuX3pvb20gPSAxLCB0aGlzLl9nYWxsZXJ5ID0gbnVsbCwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIgPSBudWxsLCB0aGlzLl9nYWxsZXJ5Q29udGVudCA9IG51bGwsIHRoaXMuX2xvYWRlciA9IG51bGwsIHRoaXMuX2ltZ0NvdW50ZXIgPSBudWxsLCB0aGlzLl9hbmltYXRpbmcgPSAhMSwgdGhpcy5fZnVsbHNjcmVlbiA9ICExLCB0aGlzLl96b29tQnRuID0gbnVsbCwgdGhpcy5fZnVsbHNjcmVlbkJ0biA9IG51bGwsIHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIgPSAwLCB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YID0gMCwgdGhpcy5fbW91c2Vkb3duUG9zaXRpb25ZID0gMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblggPSAwLCB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWSA9IDAsIHRoaXMuX3Bvc2l0aW9uWCA9IDAsIHRoaXMuX3Bvc2l0aW9uWSA9IDAsIHRoaXMuX3pvb21UaW1lciA9IDAsIHRoaXMuX3RhcENvdW50ZXIgPSAwLCB0aGlzLl90YXBUaW1lID0gMCwgdGhpcy5fcmlnaHRBcnJvdyA9IG51bGwsIHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIgPSBudWxsLCB0aGlzLl9yaWdodEFycm93V3JhcHBlciA9IG51bGwsIHRoaXMuX2luaXRpYXRlZCA9ICExLCB0aGlzLl9tdWx0aXRvdWNoID0gITEsIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCB2aSwgdGhpcyksIHRoaXMuaW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWm47XG4gIH1cbiAgZ2V0IGFjdGl2ZUltZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlSW1nO1xuICB9XG4gIGdldCBjdXJyZW50SW1nKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBgWyR7U3R9XWAsXG4gICAgICB0aGlzLl9nYWxsZXJ5Q29udGVudFxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLkUwLFxuICAgICAgLi4uYy5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBMKFpuLCB0LCBUMCksIHQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faW5pdGlhdGVkIHx8ICh0aGlzLl9hcHBlbmRUZW1wbGF0ZSgpLCB0aGlzLl9pbml0aWF0ZWQgPSAhMCk7XG4gIH1cbiAgb3Blbih0ID0gMCkge1xuICAgIHRoaXMuX2dldEltYWdlcygpLCB0aGlzLl9zZXRBY3RpdmVJbWcodCksIHRoaXMuX3NvcnRJbWFnZXMoKSwgdGhpcy5fdHJpZ2dlckV2ZW50cyhcIm9wZW5cIiwgXCJvcGVuZWRcIiksIHRoaXMuX2xvYWRJbWFnZXMoKS50aGVuKChlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNpemVJbWFnZXMoZSksIHRoaXMuX3RvZ2dsZVRlbXBsYXRlKCksIHRoaXMuX2FkZEV2ZW50cygpLCB0aGlzLl9mb2N1c0Z1bGxzY3JlZW5CdG4oKTtcbiAgICB9KTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLnJlc2V0KCksIHRoaXMuX3JlbW92ZUV2ZW50cygpLCB0aGlzLl90b2dnbGVUZW1wbGF0ZSgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKFwiY2xvc2VcIiwgXCJjbG9zZWRcIik7XG4gIH1cbiAgc2xpZGUodCA9IFwicmlnaHRcIikge1xuICAgIHRoaXMuX2FuaW1hdGluZyA9PT0gITAgfHwgdGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwic2xpZGVcIiwgXCJzbGlkZWRcIiksIHRoaXMuX2JlZm9yZVNsaWRlRXZlbnRzKCksIHQgPT09IFwicmlnaHRcIiAmJiB0aGlzLl9zbGlkZUhvcml6b250YWxseSh0KSwgdCA9PT0gXCJsZWZ0XCIgJiYgdGhpcy5fc2xpZGVIb3Jpem9udGFsbHkodCksIHQgPT09IFwiZmlyc3RcIiAmJiB0aGlzLl9zbGlkZVRvVGFyZ2V0KHQpLCB0ID09PSBcImxhc3RcIiAmJiB0aGlzLl9zbGlkZVRvVGFyZ2V0KHQpLCB0aGlzLl9hZnRlclNsaWRlRXZlbnRzKCkpO1xuICB9XG4gIHpvb21JbigpIHtcbiAgICB0aGlzLl96b29tID49IDMgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJ6b29tSW5cIiwgXCJ6b29tZWRJblwiKSwgdGhpcy5fem9vbSArPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTGV2ZWwpLCBjLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3RoaXMuX3pvb219KWBcbiAgICB9KSwgdGhpcy5fdXBkYXRlWm9vbUJ0bigpKTtcbiAgfVxuICB6b29tT3V0KCkge1xuICAgIHRoaXMuX3pvb20gPD0gMSB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInpvb21PdXRcIiwgXCJ6b29tZWRPdXRcIiksIHRoaXMuX3pvb20gLT0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbUxldmVsKSwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSwgdGhpcy5fdXBkYXRlSW1nUG9zaXRpb24oKSk7XG4gIH1cbiAgdG9nZ2xlRnVsbHNjcmVlbigpIHtcbiAgICB0aGlzLl9mdWxsc2NyZWVuID09PSAhMSA/ICh0aGlzLl9mdWxsc2NyZWVuQnRuLnNldEF0dHJpYnV0ZShTdCwgXCJcIiksIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmhpZGVGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0aGlzLl9nYWxsZXJ5LnJlcXVlc3RGdWxsc2NyZWVuICYmIHRoaXMuX2dhbGxlcnkucmVxdWVzdEZ1bGxzY3JlZW4oKSwgdGhpcy5fZnVsbHNjcmVlbiA9ICEwKSA6ICh0aGlzLl9mdWxsc2NyZWVuQnRuLnJlbW92ZUF0dHJpYnV0ZShTdCksIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuICYmIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCksIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzdG9yZURlZmF1bHRGdWxsc2NyZWVuKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0UG9zaXRpb24oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRab29tKCksIGNsZWFyVGltZW91dCh0aGlzLl90b29sc1RvZ2dsZVRpbWVyKSwgY2xlYXJUaW1lb3V0KHRoaXMuX2RvdWJsZVRhcFRpbWVyKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGgub2ZmKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBTZSxcbiAgICAgIGQwLFxuICAgICAgdGhpcy50b2dnbGVcbiAgICApLCB0aGlzLl9nYWxsZXJ5Q29udGVudCAmJiB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fZ2FsbGVyeSAmJiB0aGlzLl9nYWxsZXJ5LnJlbW92ZSgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdmkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gYy5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uQzAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEwoWm4sIHQsIEEwKSwgdDtcbiAgfVxuICBfZ2V0SW1hZ2VzKCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZWxlbWVudCkuZmlsdGVyKFxuICAgICAgKGkpID0+ICFpLmhhc0F0dHJpYnV0ZSh1MClcbiAgICApO1xuICAgIHRoaXMuX2ltYWdlcyA9IGU7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBkLmZpbmRPbmUodGhpcy5vcHRpb25zLmNvbnRhaW5lcik7XG4gIH1cbiAgX3NldEFjdGl2ZUltZyh0KSB7XG4gICAgdGhpcy5fYWN0aXZlSW1nID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IHQgOiB0aGlzLl9pbWFnZXMuaW5kZXhPZih0LnRhcmdldCk7XG4gIH1cbiAgX2FwcGVuZFRlbXBsYXRlKCkge1xuICAgIHRoaXMuX2dhbGxlcnkgPSBEKFwiZGl2XCIpLCBjLmFkZENsYXNzKHRoaXMuX2dhbGxlcnksIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeX1gKSwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LmlkID0gdGhpcy5faWQsIHRoaXMuX2dhbGxlcnkuaWQgPSB0aGlzLl9pZCwgdGhpcy5fYXBwZW5kTG9hZGVyKCksIHRoaXMuX2FwcGVuZFRvb2xiYXIoKSwgdGhpcy5fYXBwZW5kQ29udGVudCgpLCB0aGlzLl9hcHBlbmRBcnJvd3MoKSwgdGhpcy5fYXBwZW5kQ2FwdGlvbigpLCB0aGlzLl9jb250YWluZXIuYXBwZW5kKHRoaXMuX2dhbGxlcnkpO1xuICB9XG4gIF9hcHBlbmRUb29sYmFyKCkge1xuICAgIHRoaXMuX2dhbGxlcnlUb29sYmFyID0gRChcImRpdlwiKSwgdGhpcy5faW1nQ291bnRlciA9IEQoXCJwXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnRuID0gRChcImJ1dHRvblwiKSwgdGhpcy5fem9vbUJ0biA9IEQoXCJidXR0b25cIik7XG4gICAgY29uc3QgdCA9IEQoXCJidXR0b25cIiksIGUgPSBEKFwiZGl2XCIpLCBpID0gRChcImRpdlwiKTtcbiAgICBjLmFkZENsYXNzKHRoaXMuX2dhbGxlcnlUb29sYmFyLCBgJHt0aGlzLl9jbGFzc2VzLnRvb2xiYXJ9YCksIGMuYWRkQ2xhc3ModGhpcy5faW1nQ291bnRlciwgYCR7dGhpcy5fY2xhc3Nlcy5nYWxsZXJ5Q291bnRlcn1gKSwgYy5hZGRDbGFzcyh0aGlzLl9mdWxsc2NyZWVuQnRuLCBgJHt0aGlzLl9jbGFzc2VzLmZ1bGxzY3JlZW5CdG59YCksIGMuYWRkQ2xhc3ModGhpcy5fem9vbUJ0biwgYCR7dGhpcy5fY2xhc3Nlcy56b29tSW5CdG59YCksIGMuYWRkQ2xhc3ModGhpcy5fem9vbUJ0biwgdGhpcy5fY2xhc3Nlcy56b29tQnRuKSwgYy5hZGRDbGFzcyhlLCBgJHt0aGlzLl9jbGFzc2VzLmxlZnRUb29sc31gKSwgYy5hZGRDbGFzcyhpLCBgJHt0aGlzLl9jbGFzc2VzLnJpZ2h0VG9vbHN9YCksIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5jbG9zZUJ0bn1gKSwgdGhpcy5fZnVsbHNjcmVlbkJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc2hvd0Z1bGxzY3JlZW5JY29uVGVtcGxhdGUsIHQuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmNsb3NlSWNvblRlbXBsYXRlLCB0aGlzLl96b29tQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy56b29tSW5JY29uVGVtcGxhdGUsIHRoaXMuX2Z1bGxzY3JlZW5CdG4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlRvZ2dsZSBmdWxsc2NyZWVuXCIpLCB0aGlzLl96b29tQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJab29tIGluXCIpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJDbG9zZVwiKSwgaC5vbihcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW5CdG4sXG4gICAgICBTZSxcbiAgICAgICgpID0+IHRoaXMudG9nZ2xlRnVsbHNjcmVlbigpXG4gICAgKSwgaC5vbihcbiAgICAgIHRoaXMuX3pvb21CdG4sXG4gICAgICBTZSxcbiAgICAgICgpID0+IHRoaXMuX3RvZ2dsZVpvb20oKVxuICAgICksIGgub24odCwgU2UsICgpID0+IHRoaXMuY2xvc2UoKSksIGUuYXBwZW5kKHRoaXMuX2ltZ0NvdW50ZXIpLCBpLmFwcGVuZCh0aGlzLl9mdWxsc2NyZWVuQnRuKSwgaS5hcHBlbmQodGhpcy5fem9vbUJ0biksIGkuYXBwZW5kKHQpLCB0aGlzLl9nYWxsZXJ5VG9vbGJhci5hcHBlbmQoZSksIHRoaXMuX2dhbGxlcnlUb29sYmFyLmFwcGVuZChpKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodGhpcy5fZ2FsbGVyeVRvb2xiYXIpO1xuICB9XG4gIF9hcHBlbmRDb250ZW50KCkge1xuICAgIHRoaXMuX2dhbGxlcnlDb250ZW50ID0gRChcImRpdlwiKSwgYy5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX2dhbGxlcnlDb250ZW50LFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5nYWxsZXJ5Q29udGVudH1gXG4gICAgKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodGhpcy5fZ2FsbGVyeUNvbnRlbnQpO1xuICB9XG4gIF9hcHBlbmRMb2FkZXIoKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gRChcImRpdlwiKTtcbiAgICBjb25zdCB0ID0gRChcImRpdlwiKSwgZSA9IEQoXCJzcGFuXCIpO1xuICAgIGMuYWRkQ2xhc3ModGhpcy5fbG9hZGVyLCBgJHt0aGlzLl9jbGFzc2VzLmxvYWRlcn1gKSwgYy5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnNwaW5uZXJ9YCksIGMuYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyQ29udGVudH1gKSwgdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3RhdHVzXCIpLCBlLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5zcGlubmVyQ29udGVudCwgdC5hcHBlbmQoZSksIHRoaXMuX2xvYWRlci5hcHBlbmQodCksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2xvYWRlcik7XG4gIH1cbiAgX2FwcGVuZEFycm93cygpIHtcbiAgICB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyID0gRChcImRpdlwiKSwgYy5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLnByZXZCdG5XcmFwcGVyfWBcbiAgICApO1xuICAgIGNvbnN0IHQgPSBEKFwiYnV0dG9uXCIpO1xuICAgIHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlByZXZpb3VzXCIpLCBjLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMucHJldkJ0bn1gKSwgaC5vbih0LCBTZSwgKCkgPT4gdGhpcy5zbGlkZShcImxlZnRcIikpLCB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLmFwcGVuZCh0KSwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIgPSBEKFwiZGl2XCIpLCBjLmFkZENsYXNzKFxuICAgICAgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5leHRCdG5XcmFwcGVyfWBcbiAgICApLCB0aGlzLl9yaWdodEFycm93ID0gRChcImJ1dHRvblwiKSwgdGhpcy5fcmlnaHRBcnJvdy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiTmV4dFwiKSwgYy5hZGRDbGFzcyh0aGlzLl9yaWdodEFycm93LCBgJHt0aGlzLl9jbGFzc2VzLm5leHRCdG59YCksIGgub24odGhpcy5fcmlnaHRBcnJvdywgU2UsICgpID0+IHRoaXMuc2xpZGUoKSksIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLmFwcGVuZCh0aGlzLl9yaWdodEFycm93KSwgdGhpcy5fcmlnaHRBcnJvdy5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMubmV4dEljb25UZW1wbGF0ZSwgdC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMucHJldkljb25UZW1wbGF0ZSwgdGhpcy5fZ2V0SW1hZ2VzKCksICEodGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKSAmJiAodGhpcy5fZ2FsbGVyeS5hcHBlbmQodGhpcy5fbGVmdEFycm93V3JhcHBlciksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyKSk7XG4gIH1cbiAgX2FwcGVuZENhcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IEQoXCJkaXZcIiksIGUgPSBEKFwicFwiKTtcbiAgICBlLnNldEF0dHJpYnV0ZShaYSwgXCJcIiksIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5jYXB0aW9uV3JhcHBlcn1gKSwgYy5hZGRDbGFzcyhlLCBgJHt0aGlzLl9jbGFzc2VzLmNhcHRpb259YCksIHQuYXBwZW5kKGUpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0KTtcbiAgfVxuICBfc29ydEltYWdlcygpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuX2FjdGl2ZUltZzsgdCsrKVxuICAgICAgdGhpcy5faW1hZ2VzLnB1c2godGhpcy5faW1hZ2VzLnNoaWZ0KCkpO1xuICB9XG4gIGFzeW5jIF9sb2FkSW1hZ2VzKCkge1xuICAgIGNvbnN0IHQgPSBbXSwgZSA9IFtdO1xuICAgIHRoaXMuX2dhbGxlcnlDb250ZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiB0aGlzLl9pbWFnZXMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgdC5wdXNoKFxuICAgICAgICBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgICAgIGNvbnN0IGEgPSBuZXcgSW1hZ2UoKSwgbCA9IEQoXCJkaXZcIik7XG4gICAgICAgICAgYy5hZGRDbGFzcyhsLCBgJHt0aGlzLl9jbGFzc2VzLmltZ1dyYXBwZXJ9YCksIGMuYWRkQ2xhc3MoYSwgYCR7dGhpcy5fY2xhc3Nlcy5pbWd9YCksIHRoaXMuX2FkZEltZ1N0eWxlcyhhLCBsLCBpLCBvLCBuKSwgbC5hcHBlbmQoYSksIHRoaXMuX2dhbGxlcnlDb250ZW50LmFwcGVuZChsKSwgYS5vbmxvYWQgPSByLCBhLnNyYyA9IG4uZGF0YXNldC50ZUltZyB8fCBuLnNyYywgZS5wdXNoKGEpLCBpICs9IDEwMDtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSksIGF3YWl0IFByb21pc2UuYWxsKHQpLCBlO1xuICB9XG4gIF9hZGRJbWdTdHlsZXModCwgZSwgaSwgbiwgbykge1xuICAgIHQuYWx0ID0gby5hbHQsIHQuZHJhZ2dhYmxlID0gITEsIGMuc3R5bGUoZSwge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGxlZnQ6IGAke2l9JWAsXG4gICAgICB0b3A6IDBcbiAgICB9KSwgKG8uZGF0YXNldC50ZUNhcHRpb24gfHwgby5kYXRhc2V0LnRlQ2FwdGlvbiA9PT0gXCJcIikgJiYgKHQuZGF0YXNldC5jYXB0aW9uID0gby5kYXRhc2V0LnRlQ2FwdGlvbiksIGkgPT09IDAgPyAoby53aWR0aCA8IG8uaGVpZ2h0ICYmIGMuYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy52ZXJ0aWNhbH1gKSwgYy5zdHlsZShlLCB7IG9wYWNpdHk6IDEgfSksIHQuc2V0QXR0cmlidXRlKFN0LCBcIlwiKSkgOiB0LnJlbW92ZUF0dHJpYnV0ZShTdCksIG4gPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxICYmIHRoaXMuX2ltYWdlcy5sZW5ndGggPiAxICYmIGMuc3R5bGUoZSwgeyBsZWZ0OiBcIi0xMDAlXCIgfSk7XG4gIH1cbiAgX3Jlc2l6ZUltYWdlcyh0KSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKGUpO1xuICAgIH0pO1xuICB9XG4gIF9jYWxjdWxhdGVJbWdTaXplKHQpIHtcbiAgICB0LndpZHRoID49IHQuaGVpZ2h0ID8gKHQuc3R5bGUud2lkdGggPSBcIjEwMCVcIiwgdC5zdHlsZS5tYXhXaWR0aCA9IFwiMTAwJVwiLCB0LnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiLCB0LnN0eWxlLnRvcCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gdC5oZWlnaHQpIC8gMn1weGAsIHQuc3R5bGUubGVmdCA9IDApIDogKHQuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCIsIHQuc3R5bGUubWF4SGVpZ2h0ID0gXCIxMDAlXCIsIHQuc3R5bGUud2lkdGggPSBcImF1dG9cIiwgdC5zdHlsZS5sZWZ0ID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAtIHQud2lkdGgpIC8gMn1weGAsIHQuc3R5bGUudG9wID0gMCksIHQud2lkdGggPj0gdC5wYXJlbnROb2RlLm9mZnNldFdpZHRoICYmICh0LnN0eWxlLndpZHRoID0gYCR7dC5wYXJlbnROb2RlLm9mZnNldFdpZHRofXB4YCwgdC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIiwgdC5zdHlsZS5sZWZ0ID0gMCwgdC5zdHlsZS50b3AgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAtIHQuaGVpZ2h0KSAvIDJ9cHhgKSwgdC5oZWlnaHQgPj0gdC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAmJiAodC5zdHlsZS5oZWlnaHQgPSBgJHt0LnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0fXB4YCwgdC5zdHlsZS53aWR0aCA9IFwiYXV0b1wiLCB0LnN0eWxlLnRvcCA9IDAsIHQuc3R5bGUubGVmdCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggLSB0LndpZHRoKSAvIDJ9cHhgKSwgdGhpcy5fcG9zaXRpb25YID0gcGFyc2VGbG9hdCh0LnN0eWxlLmxlZnQpIHx8IDAsIHRoaXMuX3Bvc2l0aW9uWSA9IHBhcnNlRmxvYXQodC5zdHlsZS50b3ApIHx8IDA7XG4gIH1cbiAgX29uUmVzaXplKCkge1xuICAgIHRoaXMuX2ltYWdlcyA9IGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCksIHRoaXMuX2ltYWdlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKHQpO1xuICAgIH0pO1xuICB9XG4gIF9vbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgKGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbiB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuIHx8IGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpID09PSB2b2lkIDAgJiYgKHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgdGhpcy5fZnVsbHNjcmVlbkJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc2hvd0Z1bGxzY3JlZW5JY29uVGVtcGxhdGUsIHRoaXMuX2Z1bGxzY3JlZW5CdG4ucmVtb3ZlQXR0cmlidXRlKFN0KSk7XG4gIH1cbiAgX2JlZm9yZVNsaWRlRXZlbnRzKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvblN0YXJ0KCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCksIHRoaXMuX3Jlc2V0RG91YmxlVGFwKCk7XG4gIH1cbiAgX3NsaWRlSG9yaXpvbnRhbGx5KHQpIHtcbiAgICB0aGlzLl9pbWFnZXMgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLCB0aGlzLl9pbWFnZXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGk7XG4gICAgICB0ID09PSBcInJpZ2h0XCIgPyAoaSA9IHBhcnNlSW50KGUucGFyZW50Tm9kZS5zdHlsZS5sZWZ0LCAxMCkgLSAxMDAsIGkgPCAtMTAwICYmIChpID0gKHRoaXMuX2ltYWdlcy5sZW5ndGggLSAyKSAqIDEwMCkpIDogKGkgPSBwYXJzZUludChlLnBhcmVudE5vZGUuc3R5bGUubGVmdCwgMTApICsgMTAwLCBpID09PSAodGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEpICogMTAwICYmIChpID0gLTEwMCkpLCB0aGlzLl9zbGlkZUltZyhlLCBpKTtcbiAgICB9KSwgdGhpcy5fdXBkYXRlQWN0aXZlSW1nKHQpO1xuICB9XG4gIF9zbGlkZUltZyh0LCBlKSB7XG4gICAgZSA9PT0gMCA/ICh0LnNldEF0dHJpYnV0ZShTdCwgXCJcIiksIGMuc3R5bGUodC5wYXJlbnROb2RlLCB7IG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiIH0pKSA6ICh0LnJlbW92ZUF0dHJpYnV0ZShTdCksIGMuc3R5bGUodC5wYXJlbnROb2RlLCB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDAuMjUpXCJcbiAgICB9KSksIHQucGFyZW50Tm9kZS5zdHlsZS5sZWZ0ID0gYCR7ZX0lYDtcbiAgfVxuICBfc2xpZGVUb1RhcmdldCh0KSB7XG4gICAgdCA9PT0gXCJmaXJzdFwiICYmIHRoaXMuX2FjdGl2ZUltZyA9PT0gMCB8fCB0ID09PSBcImxhc3RcIiAmJiB0aGlzLl9hY3RpdmVJbWcgPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxIHx8ICh0aGlzLnJlc2V0KCksIHRoaXMuX3JlbW92ZUV2ZW50cygpLCB0aGlzLl9zaG93TG9hZGVyKCksIHRoaXMuX2dldEltYWdlcygpLCB0aGlzLl9hY3RpdmVJbWcgPSB0ID09PSBcImZpcnN0XCIgPyAwIDogdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEsIHRoaXMuX3NvcnRJbWFnZXMoKSwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDAuMjUpXCIsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbG9hZEltYWdlcygpLnRoZW4oKGUpID0+IHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2VzKGUpLCB0aGlzLl9hZGRFdmVudHMoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpLCB0aGlzLl9oaWRlTG9hZGVyKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9KTtcbiAgICB9LCA0MDApKTtcbiAgfVxuICBfdXBkYXRlQWN0aXZlSW1nKHQpIHtcbiAgICB0ID09PSBcInJpZ2h0XCIgJiYgKHRoaXMuX2FjdGl2ZUltZyA9PT0gdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEgPyB0aGlzLl9hY3RpdmVJbWcgPSAwIDogdGhpcy5fYWN0aXZlSW1nKyspLCB0ID09PSBcImxlZnRcIiAmJiAodGhpcy5fYWN0aXZlSW1nID09PSAwID8gdGhpcy5fYWN0aXZlSW1nID0gdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEgOiB0aGlzLl9hY3RpdmVJbWctLSk7XG4gIH1cbiAgX2FmdGVyU2xpZGVFdmVudHMoKSB7XG4gICAgdGhpcy5fdXBkYXRlQ291bnRlcigpLCB0aGlzLl91cGRhdGVDYXB0aW9uKCk7XG4gIH1cbiAgX3VwZGF0ZUNvdW50ZXIoKSB7XG4gICAgdGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faW1nQ291bnRlci5pbm5lckhUTUwgPSBgJHt0aGlzLl9hY3RpdmVJbWcgKyAxfSAvICR7dGhpcy5faW1hZ2VzLmxlbmd0aH1gO1xuICAgIH0sIDIwMCk7XG4gIH1cbiAgX3VwZGF0ZUNhcHRpb24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgdCA9IHRoaXMuY3VycmVudEltZy5hbHQ7XG4gICAgICAodGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiB8fCB0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uID09PSBcIlwiKSAmJiAodCA9IHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24pLCBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtaYX1dYCxcbiAgICAgICAgdGhpcy5fZ2FsbGVyeVxuICAgICAgKS5pbm5lckhUTUwgPSB0O1xuICAgIH0sIDIwMCk7XG4gIH1cbiAgX3RvZ2dsZVRlbXBsYXRlKCkge1xuICAgIHRoaXMuX2dhbGxlcnkuc3R5bGUudmlzaWJpbGl0eSA9PT0gXCJ2aXNpYmxlXCIgPyAoYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDAuMjUpXCJcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9oaWRlR2FsbGVyeSgpLCB0aGlzLl9lbmFibGVTY3JvbGwoKSwgdGhpcy5fc2hvd0xvYWRlcigpO1xuICAgIH0sIDEwMCkpIDogKHRoaXMuX3Nob3dHYWxsZXJ5KCksIHRoaXMuX2Rpc2FibGVTY3JvbGwoKSwgdGhpcy5fdXBkYXRlQ291bnRlcigpLCB0aGlzLl91cGRhdGVDYXB0aW9uKCksIHRoaXMuX3NldFRvb2xzVG9nZ2xlVGltb3V0KCksIHRoaXMuX2hpZGVMb2FkZXIoKSk7XG4gIH1cbiAgX3Nob3dMb2FkZXIoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9sb2FkZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgfVxuICBfaGlkZUxvYWRlcigpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2xvYWRlciwgeyBvcGFjaXR5OiAwIH0pO1xuICB9XG4gIF9oaWRlR2FsbGVyeSgpIHtcbiAgICBjLnN0eWxlKHRoaXMuX2dhbGxlcnksIHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgICB9KTtcbiAgfVxuICBfc2hvd0dhbGxlcnkoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9nYWxsZXJ5LCB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJpbml0aWFsXCIsXG4gICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIlxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHsgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIgfSk7XG4gICAgfSwgNTApO1xuICB9XG4gIF90b2dnbGVab29tKCkge1xuICAgIHRoaXMuX3pvb20gIT09IDEgPyB0aGlzLnpvb21PdXQoKSA6IHRoaXMuem9vbUluKCk7XG4gIH1cbiAgX3VwZGF0ZVpvb21CdG4oKSB7XG4gICAgdGhpcy5fem9vbSA+IDEgPyAodGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoU3QsIFwiXCIpLCB0aGlzLl96b29tQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJab29tIG91dFwiKSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbU91dEljb25UZW1wbGF0ZSkgOiAodGhpcy5fem9vbUJ0bi5yZW1vdmVBdHRyaWJ1dGUoU3QpLCB0aGlzLl96b29tQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJab29tIGluXCIpLCB0aGlzLl96b29tQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy56b29tSW5JY29uVGVtcGxhdGUpO1xuICB9XG4gIF91cGRhdGVJbWdQb3NpdGlvbigpIHtcbiAgICB0aGlzLl96b29tID09PSAxICYmIHRoaXMuX3Jlc3RvcmVEZWZhdWx0UG9zaXRpb24oKTtcbiAgfVxuICBfYWRkRXZlbnRzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpO1xuICAgIHRoaXMuX29uV2luZG93VG91Y2htb3ZlID0gdGhpcy5fb25XaW5kb3dUb3VjaG1vdmUuYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0ID0gdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0LmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2Vkb3duID0gdGhpcy5fb25Nb3VzZWRvd24uYmluZCh0aGlzKSwgdGhpcy5fb25JbWdNb3VzZW1vdmUgPSB0aGlzLl9vbk1vdXNlbW92ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ1doZWVsID0gdGhpcy5fb25ab29tLmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2V1cCA9IHRoaXMuX29uTW91c2V1cC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ1RvdWNoZW5kID0gdGhpcy5fb25Ub3VjaGVuZC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrID0gdGhpcy5fb25Eb3VibGVDbGljay5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93RnVsbHNjcmVlbkNoYW5nZSA9IHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZS5iaW5kKHRoaXMpLCB0aGlzLl9vbkFueUltZ0FjdGlvbiA9IHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyLmJpbmQodGhpcyksIHRoaXMuX29uR2FsbGVyeUNsaWNrID0gdGhpcy5fb25CYWNrZHJvcENsaWNrLmJpbmQodGhpcyksIHRoaXMuX29uS2V5dXBFdmVudCA9IHRoaXMuX29uS2V5dXAuYmluZCh0aGlzKSwgdGhpcy5fb25SaWdodEFycm93S2V5ZG93bkV2ZW50ID0gdGhpcy5fb25SaWdodEFycm93S2V5ZG93bi5iaW5kKHRoaXMpLCB0aGlzLl9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duRXZlbnQgPSB0aGlzLl9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duLmJpbmQodGhpcyksIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5vbihlLCBcIm1vdXNlZG93blwiLCB0aGlzLl9vbkltZ01vdXNlZG93biwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGgub24oZSwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uSW1nTW91c2Vkb3duLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgaC5vbihlLCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGgub24oZSwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBoLm9uKGUsIFwid2hlZWxcIiwgdGhpcy5fb25JbWdXaGVlbCwgeyBwYXNzaXZlOiAhMCB9KSwgaC5vbihlLCBcImRibGNsaWNrXCIsIHRoaXMuX29uSW1nRG91YmxlQ2xpY2ssIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pO1xuICAgIH0pLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX29uV2luZG93VG91Y2htb3ZlLCB7XG4gICAgICBwYXNzaXZlOiAhMVxuICAgIH0pLCBoLm9uKHdpbmRvdywgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCksIGgub24od2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5fb25JbWdNb3VzZXVwKSwgaC5vbih3aW5kb3csIFwidG91Y2hlbmRcIiwgdGhpcy5fb25JbWdUb3VjaGVuZCksIGgub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGgub24od2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgaC5vbih3aW5kb3csIFwia2V5dXBcIiwgdGhpcy5fb25LZXl1cEV2ZW50KSwgaC5vbih3aW5kb3csIFwiZnVsbHNjcmVlbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2UpLCBoLm9uKHRoaXMuX2dhbGxlcnksIFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uQW55SW1nQWN0aW9uKSwgaC5vbih0aGlzLl9nYWxsZXJ5LCBcImNsaWNrXCIsIHRoaXMuX29uR2FsbGVyeUNsaWNrKSwgaC5vbihcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3csXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudFxuICAgICksIGgub24oXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duRXZlbnRcbiAgICApO1xuICB9XG4gIF9yZW1vdmVFdmVudHMoKSB7XG4gICAgZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLm9mZihlLCBcIm1vdXNlZG93blwiLCB0aGlzLl9vbkltZ01vdXNlZG93biksIGgub2ZmKGUsIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbkltZ01vdXNlZG93biksIGgub2ZmKGUsIFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlKSwgaC5vZmYoZSwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUpLCBoLm9mZihlLCBcIndoZWVsXCIsIHRoaXMuX29uSW1nV2hlZWwpLCBoLm9mZihlLCBcImRibGNsaWNrXCIsIHRoaXMuX29uSW1nRG91YmxlQ2xpY2spO1xuICAgIH0pLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX29uV2luZG93VG91Y2htb3ZlLCB7XG4gICAgICBwYXNzaXZlOiAhMVxuICAgIH0pLCBoLm9mZih3aW5kb3csIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQpLCBoLm9mZih3aW5kb3csIFwibW91c2V1cFwiLCB0aGlzLl9vbkltZ01vdXNldXApLCBoLm9mZih3aW5kb3csIFwidG91Y2hlbmRcIiwgdGhpcy5fb25JbWdUb3VjaGVuZCksIGgub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBoLm9mZih3aW5kb3csIFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBoLm9mZih3aW5kb3csIFwia2V5dXBcIiwgdGhpcy5fb25LZXl1cEV2ZW50KSwgaC5vZmYoXG4gICAgICB3aW5kb3csXG4gICAgICBcImZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICAgIHRoaXMuX29uV2luZG93RnVsbHNjcmVlbkNoYW5nZVxuICAgICksIGgub2ZmKHRoaXMuX2dhbGxlcnksIFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uQW55SW1nQWN0aW9uKSwgaC5vZmYodGhpcy5fZ2FsbGVyeSwgXCJjbGlja1wiLCB0aGlzLl9vbkdhbGxlcnlDbGljayksIGgub2ZmKFxuICAgICAgdGhpcy5fcmlnaHRBcnJvdyxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25SaWdodEFycm93S2V5ZG93bkV2ZW50XG4gICAgKSwgaC5vZmYoXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duRXZlbnRcbiAgICApO1xuICB9XG4gIF9vbk1vdXNlZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQudG91Y2hlcywgaSA9IGUgPyBlWzBdLmNsaWVudFggOiB0LmNsaWVudFgsIG4gPSBlID8gZVswXS5jbGllbnRZIDogdC5jbGllbnRZO1xuICAgIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YID0gcGFyc2VGbG9hdCh0aGlzLmN1cnJlbnRJbWcuc3R5bGUubGVmdCkgfHwgMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblkgPSBwYXJzZUZsb2F0KHRoaXMuY3VycmVudEltZy5zdHlsZS50b3ApIHx8IDAsIHRoaXMuX3Bvc2l0aW9uWCA9IHRoaXMuX29yaWdpbmFsUG9zaXRpb25YLCB0aGlzLl9wb3NpdGlvblkgPSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWSwgdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9wb3NpdGlvblgsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSA9IG4gKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fcG9zaXRpb25ZLCB0aGlzLl9tb3VzZWRvd24gPSAhMCwgdC50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiB0LnRvdWNoZXMubGVuZ3RoID4gMSAmJiAodGhpcy5fbXVsdGl0b3VjaCA9ICEwLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uTW91c2Vtb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX21vdXNlZG93bilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdC50b3VjaGVzLCBpID0gZSA/IGVbMF0uY2xpZW50WCA6IHQuY2xpZW50WCwgbiA9IGUgPyBlWzBdLmNsaWVudFkgOiB0LmNsaWVudFk7XG4gICAgaWYgKGUgJiYgdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgIXRoaXMuX211bHRpdG91Y2gpXG4gICAgICBpZiAodGhpcy5fem9vbSAhPT0gMSlcbiAgICAgICAgdGhpcy5fcG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblgsIHRoaXMuX3Bvc2l0aW9uWSA9IG4gKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25ZLCBjLnN0eWxlKHRoaXMuY3VycmVudEltZywge1xuICAgICAgICAgIGxlZnQ6IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAsXG4gICAgICAgICAgdG9wOiBgJHt0aGlzLl9wb3NpdGlvbll9cHhgXG4gICAgICAgIH0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9pbWFnZXMubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wb3NpdGlvblggPSBpICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHsgbGVmdDogYCR7dGhpcy5fcG9zaXRpb25YfXB4YCB9KTtcbiAgICAgIH1cbiAgfVxuICBfb25Nb3VzZXVwKHQpIHtcbiAgICB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbW92ZUltZyh0LnRhcmdldCk7XG4gIH1cbiAgX29uVG91Y2hlbmQodCkge1xuICAgIHRoaXMuX21vdXNlZG93biA9ICExLCB0aGlzLl9tdWx0aXRvdWNoID8gdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5fbXVsdGl0b3VjaCA9ICExLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IFtdKSA6IHRoaXMuX211bHRpdG91Y2ggfHwgKHRoaXMuX2NoZWNrRG91YmxlVGFwKHQpLCB0aGlzLl9tb3ZlSW1nKHQudGFyZ2V0KSk7XG4gIH1cbiAgX2NhbGN1bGF0ZVRvdWNoWm9vbSh0KSB7XG4gICAgY29uc3QgZSA9IE1hdGguaHlwb3QoXG4gICAgICB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblsxXS5wYWdlWCAtIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzBdLnBhZ2VYLFxuICAgICAgdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMV0ucGFnZVkgLSB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblswXS5wYWdlWVxuICAgICksIGkgPSBNYXRoLmh5cG90KFxuICAgICAgdC50b3VjaGVzWzFdLnBhZ2VYIC0gdC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgdC50b3VjaGVzWzFdLnBhZ2VZIC0gdC50b3VjaGVzWzBdLnBhZ2VZXG4gICAgKSwgbiA9IE1hdGguYWJzKGUgLSBpKSwgbyA9IHQudmlldy5zY3JlZW4ud2lkdGg7XG4gICAgbiA+IG8gKiAwLjAzICYmIChlIDw9IGkgPyB0aGlzLnpvb21JbigpIDogdGhpcy56b29tT3V0KCksIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uID0gdC50b3VjaGVzKTtcbiAgfVxuICBfb25XaW5kb3dUb3VjaHN0YXJ0KHQpIHtcbiAgICB0LnRvdWNoZXMubGVuZ3RoID4gMSAmJiAodGhpcy5fbXVsdGl0b3VjaCA9ICEwLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uV2luZG93VG91Y2htb3ZlKHQpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSAmJiB0aGlzLl9jYWxjdWxhdGVUb3VjaFpvb20odCk7XG4gIH1cbiAgX29uUmlnaHRBcnJvd0tleWRvd24odCkge1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIDk6XG4gICAgICAgIGlmICh0LnNoaWZ0S2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZvY3VzRnVsbHNjcmVlbkJ0bigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgX29uRnVsbHNjcmVlbkJ0bktleWRvd24odCkge1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIDk6XG4gICAgICAgIGlmICghdC5zaGlmdEtleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mb2N1c1JpZ2h0QXJyb3coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9vbktleXVwKHQpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksIHQua2V5Q29kZSkge1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdGhpcy5zbGlkZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzc6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJsZWZ0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM2OlxuICAgICAgICB0aGlzLnNsaWRlKFwiZmlyc3RcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNTpcbiAgICAgICAgdGhpcy5zbGlkZShcImxhc3RcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgdGhpcy56b29tSW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQwOlxuICAgICAgICB0aGlzLnpvb21PdXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9mb2N1c0Z1bGxzY3JlZW5CdG4oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLmZvY3VzKCk7XG4gICAgfSwgMTAwKTtcbiAgfVxuICBfZm9jdXNSaWdodEFycm93KCkge1xuICAgIHRoaXMuX3JpZ2h0QXJyb3cuZm9jdXMoKTtcbiAgfVxuICBfbW92ZUltZyh0KSB7XG4gICAgaWYgKHRoaXMuX211bHRpdG91Y2ggfHwgdGhpcy5fem9vbSAhPT0gMSB8fCB0ICE9PSB0aGlzLmN1cnJlbnRJbWcgfHwgdGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9wb3NpdGlvblggLSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWDtcbiAgICBlID4gMCA/IHRoaXMuc2xpZGUoXCJsZWZ0XCIpIDogZSA8IDAgJiYgdGhpcy5zbGlkZSgpO1xuICB9XG4gIF9jaGVja0RvdWJsZVRhcCh0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RvdWJsZVRhcFRpbWVyKTtcbiAgICBjb25zdCBpID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLl90YXBUaW1lO1xuICAgIHRoaXMuX3RhcENvdW50ZXIgPiAwICYmIGkgPCA1MDAgPyAodGhpcy5fb25Eb3VibGVDbGljayh0KSwgdGhpcy5fZG91YmxlVGFwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3RhcFRpbWUgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgdGhpcy5fdGFwQ291bnRlciA9IDA7XG4gICAgfSwgMzAwKSkgOiAodGhpcy5fdGFwQ291bnRlcisrLCB0aGlzLl90YXBUaW1lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICB9XG4gIF9yZXNldERvdWJsZVRhcCgpIHtcbiAgICB0aGlzLl90YXBUaW1lID0gMCwgdGhpcy5fdGFwQ291bnRlciA9IDAsIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gIH1cbiAgX29uRG91YmxlQ2xpY2sodCkge1xuICAgIHRoaXMuX211bHRpdG91Y2ggfHwgKHQudG91Y2hlcyB8fCB0aGlzLl9zZXROZXdQb3NpdGlvbk9uWm9vbUluKHQpLCB0aGlzLl96b29tICE9PSAxID8gdGhpcy5fcmVzdG9yZURlZmF1bHRab29tKCkgOiB0aGlzLnpvb21JbigpKTtcbiAgfVxuICBfb25ab29tKHQpIHtcbiAgICBpZiAodC5kZWx0YVkgPiAwKVxuICAgICAgdGhpcy56b29tT3V0KCk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy5fem9vbSA+PSAzKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9zZXROZXdQb3NpdGlvbk9uWm9vbUluKHQpLCB0aGlzLnpvb21JbigpO1xuICAgIH1cbiAgfVxuICBfb25CYWNrZHJvcENsaWNrKHQpIHtcbiAgICB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCB0LnRhcmdldC50YWdOYW1lID09PSBcIkRJVlwiICYmIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBfc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3pvb21UaW1lciksIHRoaXMuX3Bvc2l0aW9uWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIHQub2Zmc2V0WCAtIDUwLCB0aGlzLl9wb3NpdGlvblkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gdC5vZmZzZXRZIC0gNTAsIHRoaXMuY3VycmVudEltZy5zdHlsZS50cmFuc2l0aW9uID0gXCJhbGwgMC41cyBlYXNlLW91dFwiLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUubGVmdCA9IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAsIHRoaXMuY3VycmVudEltZy5zdHlsZS50b3AgPSBgJHt0aGlzLl9wb3NpdGlvbll9cHhgLCB0aGlzLl96b29tVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEltZy5zdHlsZS50cmFuc2l0aW9uID0gXCJub25lXCI7XG4gICAgfSwgNTAwKTtcbiAgfVxuICBfcmVzZXRUb29sc1RvZ2dsZXIoKSB7XG4gICAgdGhpcy5fc2hvd1Rvb2xzKCksIGNsZWFyVGltZW91dCh0aGlzLl90b29sc1RvZ2dsZVRpbWVyKSwgdGhpcy5fc2V0VG9vbHNUb2dnbGVUaW1vdXQoKTtcbiAgfVxuICBfc2V0VG9vbHNUb2dnbGVUaW1vdXQoKSB7XG4gICAgdGhpcy5fdG9vbHNUb2dnbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZVRvb2xzKCksIGNsZWFyVGltZW91dCh0aGlzLl90b29sc1RvZ2dsZVRpbWVyKTtcbiAgICB9LCA0ZTMpO1xuICB9XG4gIF9oaWRlVG9vbHMoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgeyBvcGFjaXR5OiAwIH0pLCBjLnN0eWxlKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMCB9KSwgYy5zdHlsZSh0aGlzLl9yaWdodEFycm93V3JhcHBlciwgeyBvcGFjaXR5OiAwIH0pO1xuICB9XG4gIF9zaG93VG9vbHMoKSB7XG4gICAgYy5zdHlsZSh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgeyBvcGFjaXR5OiAxIH0pLCBjLnN0eWxlKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMSB9KSwgYy5zdHlsZSh0aGlzLl9yaWdodEFycm93V3JhcHBlciwgeyBvcGFjaXR5OiAxIH0pO1xuICB9XG4gIF9kaXNhYmxlU2Nyb2xsKCkge1xuICAgIGMuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy15LWhpZGRlbiByZWxhdGl2ZVwiKSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgJiYgYy5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm1kOnByLVsxN3B4XVwiKTtcbiAgfVxuICBfZW5hYmxlU2Nyb2xsKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm92ZXJmbG93LXktaGlkZGVuIHJlbGF0aXZlXCIpLCBjLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIFwibWQ6cHItWzE3cHhdXCIpO1xuICAgIH0sIDMwMCk7XG4gIH1cbiAgX2FuaW1hdGlvblN0YXJ0KCkge1xuICAgIHRoaXMuX2FuaW1hdGluZyA9ICEwLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdGluZyA9ICExO1xuICAgIH0sIDQwMCk7XG4gIH1cbiAgX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpIHtcbiAgICB0aGlzLl96b29tICE9PSAxICYmICh0aGlzLl96b29tID0gMSwgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSwgdGhpcy5fdXBkYXRlSW1nUG9zaXRpb24oKSk7XG4gIH1cbiAgX3Jlc3RvcmVEZWZhdWx0RnVsbHNjcmVlbigpIHtcbiAgICB0aGlzLl9mdWxsc2NyZWVuICYmIHRoaXMudG9nZ2xlRnVsbHNjcmVlbigpO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl96b29tVGltZXIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRJbWc7XG4gICAgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwgeyBsZWZ0OiAwLCB0b3A6IDAgfSksIGMuc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7XG4gICAgICB0cmFuc2l0aW9uOiBcImFsbCAwLjVzIGVhc2Utb3V0XCIsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSksIHRoaXMuX2NhbGN1bGF0ZUltZ1NpemUodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHsgdHJhbnNpdGlvbjogXCJub25lXCIgfSk7XG4gICAgfSwgNTAwKTtcbiAgfVxuICBhc3luYyBfdHJpZ2dlckV2ZW50cyh0LCBlKSB7XG4gICAgaC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke3R9LnRlLmxpZ2h0Ym94YCksIGUgJiYgYXdhaXQgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7ZX0udGUubGlnaHRib3hgKTtcbiAgICB9LCA1MDUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCB2aSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgdG9nZ2xlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb25zdCBlID0gZC5jbG9zZXN0KFxuICAgICAgICB0LnRhcmdldCxcbiAgICAgICAgYCR7T2N9YFxuICAgICAgKTtcbiAgICAgIChMcy5nZXRJbnN0YW5jZShlKSB8fCBuZXcgTHMoZSkpLm9wZW4odCk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBJLmdldERhdGEodGhpcywgdmkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBMcyh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCB5MCA9IChzLCB0ID0gXCJoaWRlXCIpID0+IHtcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtzLkVWRU5UX0tFWX1gLCBpID0gcy5OQU1FO1xuICBoLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGUsXG4gICAgYFtkYXRhLXRlLSR7aX0tZGlzbWlzc11gLFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIG4ucHJldmVudERlZmF1bHQoKSwgbWUodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSBRdCh0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke2l9YCkgfHwgdGhpcy5jbG9zZXN0KGBbZGF0YS10ZS0ke2l9LWluaXRdYCk7XG4gICAgICBpZiAoIW8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShvKVt0XSgpO1xuICAgIH1cbiAgKTtcbn0sIHcwID0gKHMpID0+IHtcbiAgaWwoKCkgPT4ge1xuICAgIGNvbnN0IHQgPSBlbCgpO1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBlID0gcy5OQU1FLCBpID0gdC5mbltlXTtcbiAgICAgIHQuZm5bZV0gPSBzLmpRdWVyeUludGVyZmFjZSwgdC5mbltlXS5Db25zdHJ1Y3RvciA9IHMsIHQuZm5bZV0ubm9Db25mbGljdCA9ICgpID0+ICh0LmZuW2VdID0gaSwgcy5qUXVlcnlJbnRlcmZhY2UpO1xuICAgIH1cbiAgfSk7XG59LCB4MCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBrMCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIG1lKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xuICAgIH1cbiAgKTtcbn0sIE8wID0gKHMsIHQpID0+IHtcbiAgaC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNvbnN0IGkgPSBRdCh0aGlzKTtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgbWUodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGgub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgIEx0KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGQuZmluZE9uZShzLk9QRU5fU0VMRUNUT1IpO1xuICAgICAgbiAmJiBuICE9PSBpICYmIHMuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKHRoaXMpO1xuICAgIH1cbiAgKTtcbn0sIFMwID0gKHMsIHQpID0+IHtcbiAgaC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gZS50YXJnZXQuY2xvc2VzdCh0KTtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBJMCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gUXQodGhpcyk7XG4gICAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgaC5vbmUoaSwgcy5FVkVOVF9TSE9XLCAocikgPT4ge1xuICAgICAgICByLmRlZmF1bHRQcmV2ZW50ZWQgfHwgaC5vbmUoaSwgcy5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgICBMdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgICBgWyR7cy5PUEVOX1NFTEVDVE9SfT1cInRydWVcIl1gXG4gICAgICApO1xuICAgICAgbiAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBEMCA9IChzLCB0KSA9PiB7XG4gIGgub25lKFxuICAgIGRvY3VtZW50LFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgdCxcbiAgICBzLmF1dG9Jbml0aWFsKG5ldyBzKCkpXG4gICk7XG59LCAkMCA9IChzLCB0KSA9PiB7XG4gIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgfHwgZS5kZWxlZ2F0ZVRhcmdldCAmJiBlLmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gZm8odGhpcyk7XG4gICAgICBkLmZpbmQoaSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobywgeyB0b2dnbGU6ICExIH0pLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufSwgTDAgPSAocywgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgcyhpKTtcbiAgfSk7XG59LCBNMCA9IChzLCB0KSA9PiB7XG4gIFtdLnNsaWNlLmNhbGwoXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KVxuICApLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5ldyBzKGkpO1xuICB9KTtcbn0sIE4wID0gKHMsIHQpID0+IHtcbiAgZC5maW5kKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICBuZXcgcyhlKTtcbiAgfSksIGgub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgYCR7dH0gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCxcbiAgICBzLnRvZ2dsZSgpXG4gICk7XG59LCBSMCA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSAobykgPT4gb1swXSA9PT0gXCJ7XCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIn1cIiB8fCBvWzBdID09PSBcIltcIiAmJiBvW28ubGVuZ3RoIC0gMV0gPT09IFwiXVwiLCBpID0gKG8pID0+IHR5cGVvZiBvICE9IFwic3RyaW5nXCIgPyBvIDogZShvKSA/IEpTT04ucGFyc2Uoby5yZXBsYWNlKC8nL2csICdcIicpKSA6IG8sIG4gPSAobykgPT4ge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgaWYgKGEubWF0Y2goL2RhdGFzZXQuKi8pKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLnNsaWNlKDcsIDgpLnRvTG93ZXJDYXNlKCkuY29uY2F0KGEuc2xpY2UoOCkpO1xuICAgICAgICByW2xdID0gaShvW2FdKTtcbiAgICAgIH1cbiAgICB9KSwgcjtcbiAgfTtcbiAgZC5maW5kKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICBpZiAoYy5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwiYnViYmxlXCIgJiYgYy5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwic2NhdHRlclwiKSB7XG4gICAgICBjb25zdCByID0gYy5nZXREYXRhQXR0cmlidXRlcyhvKSwgYSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGFzZXRzOiBbbihyKV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmNoYXJ0ICYmIChhLnR5cGUgPSByLmNoYXJ0KSwgci5sYWJlbHMgJiYgKGEuZGF0YS5sYWJlbHMgPSBKU09OLnBhcnNlKHIubGFiZWxzLnJlcGxhY2UoLycvZywgJ1wiJykpKSwgbmV3IHMobywge1xuICAgICAgICAuLi5hLFxuICAgICAgICAuLi5taVthLnR5cGVdXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufTtcbmNsYXNzIFAwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0cyA9IFtdO1xuICB9XG4gIGdldCBpbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0cztcbiAgfVxuICBpc0luaXRlZCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHMuaW5jbHVkZXModCk7XG4gIH1cbiAgYWRkKHQpIHtcbiAgICB0aGlzLmluaXRzLnB1c2godCk7XG4gIH1cbn1cbmNvbnN0IF9vID0gbmV3IFAwKCksIFRpID0ge1xuICBhbGVydDoge1xuICAgIG5hbWU6IFwiQWxlcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbGVydC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgZGlzbWlzc01ldGhvZDogXCJjbG9zZVwiXG4gIH0sXG4gIGFuaW1hdGlvbjoge1xuICAgIG5hbWU6IFwiQW5pbWF0ZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWFuaW1hdGlvbi1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2Fyb3VzZWw6IHtcbiAgICBuYW1lOiBcIkNhcm91c2VsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNoaXBzOiB7XG4gICAgbmFtZTogXCJDaGlwc0lucHV0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2hpcHMtaW5wdXQtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNoaXA6IHtcbiAgICBuYW1lOiBcIkNoaXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGlwLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMSxcbiAgICBvbkluaXQ6IFwiaW5pdFwiXG4gIH0sXG4gIGRhdGVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIkRhdGVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRlcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBpbnB1dDoge1xuICAgIG5hbWU6IFwiSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBwZXJmZWN0U2Nyb2xsYmFyOiB7XG4gICAgbmFtZTogXCJQZXJmZWN0U2Nyb2xsYmFyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtcGVyZmVjdC1zY3JvbGxiYXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHJhdGluZzoge1xuICAgIG5hbWU6IFwiUmF0aW5nXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtcmF0aW5nLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzY3JvbGxzcHk6IHtcbiAgICBuYW1lOiBcIlNjcm9sbFNweVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNweT0nc2Nyb2xsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNlbGVjdDoge1xuICAgIG5hbWU6IFwiU2VsZWN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2VsZWN0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzaWRlbmF2OiB7XG4gICAgbmFtZTogXCJTaWRlbmF2XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2lkZW5hdi1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc3RlcHBlcjoge1xuICAgIG5hbWU6IFwiU3RlcHBlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXN0ZXBwZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHRpbWVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIlRpbWVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10aW1lcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0b2FzdDoge1xuICAgIG5hbWU6IFwiVG9hc3RcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2FzdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgZGlzbWlzc01ldGhvZDogXCJoaWRlXCJcbiAgfSxcbiAgZGF0YXRhYmxlOiB7XG4gICAgbmFtZTogXCJEYXRhdGFibGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRhdGFibGUtaW5pdF1cIlxuICB9LFxuICBwb3Bjb25maXJtOiB7XG4gICAgbmFtZTogXCJQb3Bjb25maXJtXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdwb3Bjb25maXJtJ11cIlxuICB9LFxuICAvLyBhZHZhbmNlZEluaXRzXG4gIGNoYXJ0OiB7XG4gICAgbmFtZTogXCJDaGFydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoYXJ0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgYWR2YW5jZWQ6IFIwXG4gIH0sXG4gIC8vIHRvZ2dsZXJzXG4gIGJ1dHRvbjoge1xuICAgIG5hbWU6IFwiQnV0dG9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFMwXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogJDBcbiAgfSxcbiAgZHJvcGRvd246IHtcbiAgICBuYW1lOiBcIkRyb3Bkb3duXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiB4MFxuICB9LFxuICBtb2RhbDoge1xuICAgIG5hbWU6IFwiTW9kYWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBkaXNtaXNzTWV0aG9kOiBcImhpZGVcIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBJMFxuICB9LFxuICByaXBwbGU6IHtcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IEQwXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtb2ZmY2FudmFzLXRvZ2dsZV1cIixcbiAgICBkaXNtaXNzTWV0aG9kOiBcImhpZGVcIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBPMFxuICB9LFxuICB0YWI6IHtcbiAgICBuYW1lOiBcIlRhYlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ndGFiJ10sIFtkYXRhLXRlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10ZS10b2dnbGU9J2xpc3QnXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IGswXG4gIH0sXG4gIHRvb2x0aXA6IHtcbiAgICBuYW1lOiBcIlRvb2x0aXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3Rvb2x0aXAnXVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgY2FsbGJhY2s6IEwwXG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBuYW1lOiBcIlBvcG92ZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IE0wXG4gIH0sXG4gIGxpZ2h0Ym94OiB7XG4gICAgbmFtZTogXCJMaWdodGJveFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxpZ2h0Ym94LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTjBcbiAgfVxufSwgQjAgPSAocykgPT4gVGlbcy5OQU1FXSB8fCBudWxsLCBIMCA9IChzKSA9PiB7XG4gIGlmICghcyB8fCBfby5pc0luaXRlZChzLk5BTUUpKVxuICAgIHJldHVybjtcbiAgX28uYWRkKHMuTkFNRSk7XG4gIGNvbnN0IHQgPSBCMChzKSwgZSA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlzVG9nZ2xlcikgfHwgITE7XG4gIGlmICh3MChzKSwgdCAhPSBudWxsICYmIHQuZGlzbWlzc01ldGhvZCAmJiB5MChzLCB0LmRpc21pc3NNZXRob2QpLCB0ICE9IG51bGwgJiYgdC5hZHZhbmNlZCkge1xuICAgIHQgPT0gbnVsbCB8fCB0LmFkdmFuY2VkKHMsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZSkge1xuICAgIHQgPT0gbnVsbCB8fCB0LmNhbGxiYWNrKHMsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBkLmZpbmQodCA9PSBudWxsID8gdm9pZCAwIDogdC5zZWxlY3RvcikuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGxldCBuID0gcy5nZXRJbnN0YW5jZShpKTtcbiAgICBuIHx8IChuID0gbmV3IHMoaSksIHQgIT0gbnVsbCAmJiB0Lm9uSW5pdCAmJiBuW3Qub25Jbml0XSgpKTtcbiAgfSk7XG59LCBXMCA9IChzKSA9PiB7XG4gIHMuZm9yRWFjaCgodCkgPT4gSDAodCkpO1xufSwgVTAgPSAocywgdCA9ICExKSA9PiB7XG4gIGNvbnN0IGUgPSBPYmplY3Qua2V5cyhUaSkubWFwKChpKSA9PiB7XG4gICAgaWYgKCEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihUaVtpXS5zZWxlY3RvcikpIHtcbiAgICAgIGNvbnN0IG8gPSBzW1RpW2ldLm5hbWVdO1xuICAgICAgcmV0dXJuICFvICYmICFfby5pc0luaXRlZChpKSAmJiB0ICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgYFBsZWFzZSBpbXBvcnQgJHtUaVtpXS5uYW1lfSBmcm9tIFwidHctZWxlbWVudHNcIiBwYWNrYWdlIGFuZCBhZGQgaXQgdG8gYSBvYmplY3QgcGFyYW1ldGVyIGluc2lkZSBcImluaXRURVwiIGZ1bmN0aW9uYFxuICAgICAgKSwgbztcbiAgICB9XG4gIH0pO1xuICBXMChlKTtcbn07XG5leHBvcnQge1xuICBIbCBhcyBBbGVydCxcbiAgSmwgYXMgQW5pbWF0ZSxcbiAgZGwgYXMgQnV0dG9uLFxuICBVdCBhcyBDYXJvdXNlbCxcbiAgdmMgYXMgQ2hhcnQsXG4gIGhpIGFzIENoaXAsXG4gIEswIGFzIENoaXBzSW5wdXQsXG4gIHF0IGFzIENvbGxhcHNlLFxuICB3YyBhcyBEYXRhdGFibGUsXG4gIEYwIGFzIERhdGVwaWNrZXIsXG4gIEl0IGFzIERyb3Bkb3duLFxuICBXIGFzIElucHV0LFxuICBMcyBhcyBMaWdodGJveCxcbiAgRmwgYXMgTW9kYWwsXG4gIG5vIGFzIE9mZmNhbnZhcyxcbiAgeWMgYXMgUGVyZmVjdFNjcm9sbGJhcixcbiAga2MgYXMgUG9wY29uZmlybSxcbiAgWWwgYXMgUG9wb3ZlcixcbiAgejAgYXMgUmF0aW5nLFxuICBVZSBhcyBSaXBwbGUsXG4gIHpsIGFzIFNjcm9sbFNweSxcbiAgJG8gYXMgU2VsZWN0LFxuICBwaSBhcyBTaWRlbmF2LFxuICBqMCBhcyBTdGVwcGVyLFxuICBVbCBhcyBUYWIsXG4gIFkwIGFzIFRpbWVwaWNrZXIsXG4gIFhsIGFzIFRvYXN0LFxuICBRZSBhcyBUb29sdGlwLFxuICBVMCBhcyBpbml0VEVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dy1lbGVtZW50cy5lcy5taW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=